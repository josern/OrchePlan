/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/page"],{

/***/ "(app-pages-browser)/../node_modules/lucide-react/dist/esm/Icon.js":
/*!*****************************************************!*\
  !*** ../node_modules/lucide-react/dist/esm/Icon.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Icon)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/../node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _defaultAttributes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./defaultAttributes.js */ \"(app-pages-browser)/../node_modules/lucide-react/dist/esm/defaultAttributes.js\");\n/* harmony import */ var _shared_src_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shared/src/utils.js */ \"(app-pages-browser)/../node_modules/lucide-react/dist/esm/shared/src/utils.js\");\n/**\n * @license lucide-react v0.475.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \n\n\nconst Icon = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(_c = (param, ref)=>{\n    let { color = \"currentColor\", size = 24, strokeWidth = 2, absoluteStrokeWidth, className = \"\", children, iconNode, ...rest } = param;\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"svg\", {\n        ref,\n        ..._defaultAttributes_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n        width: size,\n        height: size,\n        stroke: color,\n        strokeWidth: absoluteStrokeWidth ? Number(strokeWidth) * 24 / Number(size) : strokeWidth,\n        className: (0,_shared_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.mergeClasses)(\"lucide\", className),\n        ...rest\n    }, [\n        ...iconNode.map((param)=>{\n            let [tag, attrs] = param;\n            return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(tag, attrs);\n        }),\n        ...Array.isArray(children) ? children : [\n            children\n        ]\n    ]);\n});\n_c1 = Icon;\n //# sourceMappingURL=Icon.js.map\nvar _c, _c1;\n$RefreshReg$(_c, \"Icon$forwardRef\");\n$RefreshReg$(_c1, \"Icon\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbHVjaWRlLXJlYWN0L2Rpc3QvZXNtL0ljb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBd0JBLENBQU0sU0FBTyx3RUFDWCxRQVdFLEdBQ0c7UUFYSCxFQUNFLEtBQVEsbUJBQ1IsSUFBTyxPQUNQLFdBQWMsTUFDZCxxQkFDQSxTQUFZLE9BQ1osVUFDQSxVQUNBLEdBQUc7SUFJRSwyRUFDTCxNQUNBO1FBQ0U7UUFDQSxHQUFHO1FBQ0gsS0FBTztRQUNQLE1BQVE7UUFDUixNQUFRO1FBQ1IsWUFBYSxxQkFBdUIsUUFBTyxFQUFXLFlBQUksSUFBTSxVQUFPLENBQUksSUFBSTtRQUMvRSxVQUFXLG1FQUFhLFdBQVUsU0FBUztRQUMzQyxHQUFHO0lBQ0wsR0FDQTtXQUNLLENBQVMsWUFBSTtnQkFBQyxDQUFDLENBQUssS0FBSyxLQUFNO2lDQUFBLHFEQUFjLEdBQUssT0FBSyxDQUFDOztXQUN2RCxLQUFNLFNBQVEsUUFBUSxDQUFJLGNBQVc7WUFBQyxRQUFRO1NBQUE7S0FDcEQ7QUFFSiIsInNvdXJjZXMiOlsiL2hvbWUvY29kZXIvc3JjL0ljb24udHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlRWxlbWVudCwgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBkZWZhdWx0QXR0cmlidXRlcyBmcm9tICcuL2RlZmF1bHRBdHRyaWJ1dGVzJztcbmltcG9ydCB7IEljb25Ob2RlLCBMdWNpZGVQcm9wcyB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgbWVyZ2VDbGFzc2VzIH0gZnJvbSAnQGx1Y2lkZS9zaGFyZWQnO1xuXG5pbnRlcmZhY2UgSWNvbkNvbXBvbmVudFByb3BzIGV4dGVuZHMgTHVjaWRlUHJvcHMge1xuICBpY29uTm9kZTogSWNvbk5vZGU7XG59XG5cbi8qKlxuICogTHVjaWRlIGljb24gY29tcG9uZW50XG4gKlxuICogQGNvbXBvbmVudCBJY29uXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wcy5jb2xvciAtIFRoZSBjb2xvciBvZiB0aGUgaWNvblxuICogQHBhcmFtIHtudW1iZXJ9IHByb3BzLnNpemUgLSBUaGUgc2l6ZSBvZiB0aGUgaWNvblxuICogQHBhcmFtIHtudW1iZXJ9IHByb3BzLnN0cm9rZVdpZHRoIC0gVGhlIHN0cm9rZSB3aWR0aCBvZiB0aGUgaWNvblxuICogQHBhcmFtIHtib29sZWFufSBwcm9wcy5hYnNvbHV0ZVN0cm9rZVdpZHRoIC0gV2hldGhlciB0byB1c2UgYWJzb2x1dGUgc3Ryb2tlIHdpZHRoXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcHMuY2xhc3NOYW1lIC0gVGhlIGNsYXNzIG5hbWUgb2YgdGhlIGljb25cbiAqIEBwYXJhbSB7SWNvbk5vZGV9IHByb3BzLmNoaWxkcmVuIC0gVGhlIGNoaWxkcmVuIG9mIHRoZSBpY29uXG4gKiBAcGFyYW0ge0ljb25Ob2RlfSBwcm9wcy5pY29uTm9kZSAtIFRoZSBpY29uIG5vZGUgb2YgdGhlIGljb25cbiAqXG4gKiBAcmV0dXJucyB7Rm9yd2FyZFJlZkV4b3RpY0NvbXBvbmVudH0gTHVjaWRlSWNvblxuICovXG5jb25zdCBJY29uID0gZm9yd2FyZFJlZjxTVkdTVkdFbGVtZW50LCBJY29uQ29tcG9uZW50UHJvcHM+KFxuICAoXG4gICAge1xuICAgICAgY29sb3IgPSAnY3VycmVudENvbG9yJyxcbiAgICAgIHNpemUgPSAyNCxcbiAgICAgIHN0cm9rZVdpZHRoID0gMixcbiAgICAgIGFic29sdXRlU3Ryb2tlV2lkdGgsXG4gICAgICBjbGFzc05hbWUgPSAnJyxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgaWNvbk5vZGUsXG4gICAgICAuLi5yZXN0XG4gICAgfSxcbiAgICByZWYsXG4gICkgPT4ge1xuICAgIHJldHVybiBjcmVhdGVFbGVtZW50KFxuICAgICAgJ3N2ZycsXG4gICAgICB7XG4gICAgICAgIHJlZixcbiAgICAgICAgLi4uZGVmYXVsdEF0dHJpYnV0ZXMsXG4gICAgICAgIHdpZHRoOiBzaXplLFxuICAgICAgICBoZWlnaHQ6IHNpemUsXG4gICAgICAgIHN0cm9rZTogY29sb3IsXG4gICAgICAgIHN0cm9rZVdpZHRoOiBhYnNvbHV0ZVN0cm9rZVdpZHRoID8gKE51bWJlcihzdHJva2VXaWR0aCkgKiAyNCkgLyBOdW1iZXIoc2l6ZSkgOiBzdHJva2VXaWR0aCxcbiAgICAgICAgY2xhc3NOYW1lOiBtZXJnZUNsYXNzZXMoJ2x1Y2lkZScsIGNsYXNzTmFtZSksXG4gICAgICAgIC4uLnJlc3QsXG4gICAgICB9LFxuICAgICAgW1xuICAgICAgICAuLi5pY29uTm9kZS5tYXAoKFt0YWcsIGF0dHJzXSkgPT4gY3JlYXRlRWxlbWVudCh0YWcsIGF0dHJzKSksXG4gICAgICAgIC4uLihBcnJheS5pc0FycmF5KGNoaWxkcmVuKSA/IGNoaWxkcmVuIDogW2NoaWxkcmVuXSksXG4gICAgICBdLFxuICAgICk7XG4gIH0sXG4pO1xuXG5leHBvcnQgZGVmYXVsdCBJY29uO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/lucide-react/dist/esm/Icon.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/lucide-react/dist/esm/createLucideIcon.js":
/*!*****************************************************************!*\
  !*** ../node_modules/lucide-react/dist/esm/createLucideIcon.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ createLucideIcon)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/../node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _shared_src_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shared/src/utils.js */ \"(app-pages-browser)/../node_modules/lucide-react/dist/esm/shared/src/utils.js\");\n/* harmony import */ var _Icon_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Icon.js */ \"(app-pages-browser)/../node_modules/lucide-react/dist/esm/Icon.js\");\n/**\n * @license lucide-react v0.475.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \n\n\nconst createLucideIcon = (iconName, iconNode)=>{\n    const Component = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((param, ref)=>{\n        let { className, ...props } = param;\n        return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(_Icon_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {\n            ref,\n            iconNode,\n            className: (0,_shared_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.mergeClasses)(\"lucide-\".concat((0,_shared_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.toKebabCase)(iconName)), className),\n            ...props\n        });\n    });\n    Component.displayName = \"\".concat(iconName);\n    return Component;\n};\n //# sourceMappingURL=createLucideIcon.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbHVjaWRlLXJlYWN0L2Rpc3QvZXNtL2NyZWF0ZUx1Y2lkZUljb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBV00sdUJBQW1CLEdBQUMsVUFBa0IsUUFBdUI7SUFDakUsTUFBTSxDQUFZLG1GQUFpRTtZQUF6QixFQUFFLENBQVcsV0FBRyxRQUFTOzZCQUNqRixvREFBYSxDQUFDLGdEQUFNO1lBQ2xCO1lBQ0E7WUFDQSxXQUFXLGtFQUFhLFdBQStCLE9BQXJCLGlFQUFXLENBQUMsUUFBUSxDQUFDLEdBQUksU0FBUztZQUNwRSxHQUFHO1FBQUEsQ0FDSjs7SUFHTyx3QkFBYyxDQUFHLEVBQVEsT0FBUixRQUFRO0lBRTVCO0FBQ1QiLCJzb3VyY2VzIjpbIi9ob21lL2NvZGVyL3NyYy9jcmVhdGVMdWNpZGVJY29uLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZUVsZW1lbnQsIGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBtZXJnZUNsYXNzZXMsIHRvS2ViYWJDYXNlIH0gZnJvbSAnQGx1Y2lkZS9zaGFyZWQnO1xuaW1wb3J0IHsgSWNvbk5vZGUsIEx1Y2lkZVByb3BzIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgSWNvbiBmcm9tICcuL0ljb24nO1xuXG4vKipcbiAqIENyZWF0ZSBhIEx1Y2lkZSBpY29uIGNvbXBvbmVudFxuICogQHBhcmFtIHtzdHJpbmd9IGljb25OYW1lXG4gKiBAcGFyYW0ge2FycmF5fSBpY29uTm9kZVxuICogQHJldHVybnMge0ZvcndhcmRSZWZFeG90aWNDb21wb25lbnR9IEx1Y2lkZUljb25cbiAqL1xuY29uc3QgY3JlYXRlTHVjaWRlSWNvbiA9IChpY29uTmFtZTogc3RyaW5nLCBpY29uTm9kZTogSWNvbk5vZGUpID0+IHtcbiAgY29uc3QgQ29tcG9uZW50ID0gZm9yd2FyZFJlZjxTVkdTVkdFbGVtZW50LCBMdWNpZGVQcm9wcz4oKHsgY2xhc3NOYW1lLCAuLi5wcm9wcyB9LCByZWYpID0+XG4gICAgY3JlYXRlRWxlbWVudChJY29uLCB7XG4gICAgICByZWYsXG4gICAgICBpY29uTm9kZSxcbiAgICAgIGNsYXNzTmFtZTogbWVyZ2VDbGFzc2VzKGBsdWNpZGUtJHt0b0tlYmFiQ2FzZShpY29uTmFtZSl9YCwgY2xhc3NOYW1lKSxcbiAgICAgIC4uLnByb3BzLFxuICAgIH0pLFxuICApO1xuXG4gIENvbXBvbmVudC5kaXNwbGF5TmFtZSA9IGAke2ljb25OYW1lfWA7XG5cbiAgcmV0dXJuIENvbXBvbmVudDtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZUx1Y2lkZUljb247XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/lucide-react/dist/esm/createLucideIcon.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/lucide-react/dist/esm/defaultAttributes.js":
/*!******************************************************************!*\
  !*** ../node_modules/lucide-react/dist/esm/defaultAttributes.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ defaultAttributes)\n/* harmony export */ });\n/**\n * @license lucide-react v0.475.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ var defaultAttributes = {\n    xmlns: \"http://www.w3.org/2000/svg\",\n    width: 24,\n    height: 24,\n    viewBox: \"0 0 24 24\",\n    fill: \"none\",\n    stroke: \"currentColor\",\n    strokeWidth: 2,\n    strokeLinecap: \"round\",\n    strokeLinejoin: \"round\"\n};\n //# sourceMappingURL=defaultAttributes.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbHVjaWRlLXJlYWN0L2Rpc3QvZXNtL2RlZmF1bHRBdHRyaWJ1dGVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztJQUFBLENBQWU7SUFDYixLQUFPO0lBQ1AsS0FBTztJQUNQLE1BQVE7SUFDUixPQUFTO0lBQ1QsSUFBTTtJQUNOLE1BQVE7SUFDUixXQUFhO0lBQ2IsYUFBZTtJQUNmLGNBQWdCO0FBQ2xCIiwic291cmNlcyI6WyIvaG9tZS9jb2Rlci9zcmMvZGVmYXVsdEF0dHJpYnV0ZXMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQge1xuICB4bWxuczogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcbiAgd2lkdGg6IDI0LFxuICBoZWlnaHQ6IDI0LFxuICB2aWV3Qm94OiAnMCAwIDI0IDI0JyxcbiAgZmlsbDogJ25vbmUnLFxuICBzdHJva2U6ICdjdXJyZW50Q29sb3InLFxuICBzdHJva2VXaWR0aDogMixcbiAgc3Ryb2tlTGluZWNhcDogJ3JvdW5kJyxcbiAgc3Ryb2tlTGluZWpvaW46ICdyb3VuZCcsXG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/lucide-react/dist/esm/defaultAttributes.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/lucide-react/dist/esm/icons/loader-circle.js":
/*!********************************************************************!*\
  !*** ../node_modules/lucide-react/dist/esm/icons/loader-circle.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __iconNode: () => (/* binding */ __iconNode),\n/* harmony export */   \"default\": () => (/* binding */ LoaderCircle)\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/../node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.475.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \nconst __iconNode = [\n    [\n        \"path\",\n        {\n            d: \"M21 12a9 9 0 1 1-6.219-8.56\",\n            key: \"13zald\"\n        }\n    ]\n];\nconst LoaderCircle = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"LoaderCircle\", __iconNode);\n //# sourceMappingURL=loader-circle.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbHVjaWRlLXJlYWN0L2Rpc3QvZXNtL2ljb25zL2xvYWRlci1jaXJjbGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBR2EsaUJBQXVCO0lBQUM7UUFBQyxNQUFRO1FBQUEsQ0FBRTtZQUFBLEVBQUcsOEJBQStCO1lBQUEsS0FBSyxDQUFTO1FBQUEsQ0FBQztLQUFDO0NBQUE7QUFhNUYsbUJBQWUsa0VBQWlCLGlCQUFnQixDQUFVIiwic291cmNlcyI6WyIvaG9tZS9zcmMvaWNvbnMvbG9hZGVyLWNpcmNsZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY3JlYXRlTHVjaWRlSWNvbiBmcm9tICcuLi9jcmVhdGVMdWNpZGVJY29uJztcbmltcG9ydCB7IEljb25Ob2RlIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgY29uc3QgX19pY29uTm9kZTogSWNvbk5vZGUgPSBbWydwYXRoJywgeyBkOiAnTTIxIDEyYTkgOSAwIDEgMS02LjIxOS04LjU2Jywga2V5OiAnMTN6YWxkJyB9XV07XG5cbi8qKlxuICogQGNvbXBvbmVudCBAbmFtZSBMb2FkZXJDaXJjbGVcbiAqIEBkZXNjcmlwdGlvbiBMdWNpZGUgU1ZHIGljb24gY29tcG9uZW50LCByZW5kZXJzIFNWRyBFbGVtZW50IHdpdGggY2hpbGRyZW4uXG4gKlxuICogQHByZXZpZXcgIVtpbWddKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QWdlRzFzYm5NOUltaDBkSEE2THk5M2QzY3Vkek11YjNKbkx6SXdNREF2YzNabklnb2dJSGRwWkhSb1BTSXlOQ0lLSUNCb1pXbG5hSFE5SWpJMElnb2dJSFpwWlhkQ2IzZzlJakFnTUNBeU5DQXlOQ0lLSUNCbWFXeHNQU0p1YjI1bElnb2dJSE4wY205clpUMGlJekF3TUNJZ2MzUjViR1U5SW1KaFkydG5jbTkxYm1RdFkyOXNiM0k2SUNObVptWTdJR0p2Y21SbGNpMXlZV1JwZFhNNklESndlQ0lLSUNCemRISnZhMlV0ZDJsa2RHZzlJaklpQ2lBZ2MzUnliMnRsTFd4cGJtVmpZWEE5SW5KdmRXNWtJZ29nSUhOMGNtOXJaUzFzYVc1bGFtOXBiajBpY205MWJtUWlDajRLSUNBOGNHRjBhQ0JrUFNKTk1qRWdNVEpoT1NBNUlEQWdNU0F4TFRZdU1qRTVMVGd1TlRZaUlDOCtDand2YzNablBnbz0pIC0gaHR0cHM6Ly9sdWNpZGUuZGV2L2ljb25zL2xvYWRlci1jaXJjbGVcbiAqIEBzZWUgaHR0cHM6Ly9sdWNpZGUuZGV2L2d1aWRlL3BhY2thZ2VzL2x1Y2lkZS1yZWFjdCAtIERvY3VtZW50YXRpb25cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgLSBMdWNpZGUgaWNvbnMgcHJvcHMgYW5kIGFueSB2YWxpZCBTVkcgYXR0cmlidXRlXG4gKiBAcmV0dXJucyB7SlNYLkVsZW1lbnR9IEpTWCBFbGVtZW50XG4gKlxuICovXG5jb25zdCBMb2FkZXJDaXJjbGUgPSBjcmVhdGVMdWNpZGVJY29uKCdMb2FkZXJDaXJjbGUnLCBfX2ljb25Ob2RlKTtcblxuZXhwb3J0IGRlZmF1bHQgTG9hZGVyQ2lyY2xlO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/lucide-react/dist/esm/icons/loader-circle.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/lucide-react/dist/esm/shared/src/utils.js":
/*!*****************************************************************!*\
  !*** ../node_modules/lucide-react/dist/esm/shared/src/utils.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   mergeClasses: () => (/* binding */ mergeClasses),\n/* harmony export */   toKebabCase: () => (/* binding */ toKebabCase)\n/* harmony export */ });\n/**\n * @license lucide-react v0.475.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ const toKebabCase = (string)=>string.replace(/([a-z0-9])([A-Z])/g, \"$1-$2\").toLowerCase();\nconst mergeClasses = function() {\n    for(var _len = arguments.length, classes = new Array(_len), _key = 0; _key < _len; _key++){\n        classes[_key] = arguments[_key];\n    }\n    return classes.filter((className, index, array)=>{\n        return Boolean(className) && className.trim() !== \"\" && array.indexOf(className) === index;\n    }).join(\" \").trim();\n};\n //# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbHVjaWRlLXJlYWN0L2Rpc3QvZXNtL3NoYXJlZC9zcmMvdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztJQVFhLG9CQUFjLENBQUMsTUFDMUIsVUFBTyxRQUFRLG9CQUFzQixTQUFPLEVBQUUsV0FBWTtBQStCL0MsbUJBQWUsSUFBMkM7O1FBQUEsT0FDckU7O1dBQUEsUUFDRyxPQUFPLENBQUMsV0FBVyxPQUFPLEtBQVU7UUFFakMsZUFBUSxTQUFTLEVBQ2hCLFlBQXFCLFlBQVcsQ0FDakMsV0FBTSxPQUFRLEVBQVMsU0FBTTtJQUVqQyxDQUFDLENBQ0EsTUFBSyxDQUFHLElBQ1IsQ0FBSyIsInNvdXJjZXMiOlsiL3NoYXJlZC9zcmMvdXRpbHMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ2FtZWxUb1Bhc2NhbCB9IGZyb20gJy4vdXRpbGl0eS10eXBlcyc7XG5cbi8qKlxuICogQ29udmVydHMgc3RyaW5nIHRvIGtlYmFiIGNhc2VcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBBIGtlYmFiaXplZCBzdHJpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IHRvS2ViYWJDYXNlID0gKHN0cmluZzogc3RyaW5nKSA9PlxuICBzdHJpbmcucmVwbGFjZSgvKFthLXowLTldKShbQS1aXSkvZywgJyQxLSQyJykudG9Mb3dlckNhc2UoKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBzdHJpbmcgdG8gY2FtZWwgY2FzZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEEgY2FtZWxpemVkIHN0cmluZ1xuICovXG5leHBvcnQgY29uc3QgdG9DYW1lbENhc2UgPSA8VCBleHRlbmRzIHN0cmluZz4oc3RyaW5nOiBUKSA9PlxuICBzdHJpbmcucmVwbGFjZSgvXihbQS1aXSl8W1xccy1fXSsoXFx3KS9nLCAobWF0Y2gsIHAxLCBwMikgPT5cbiAgICBwMiA/IHAyLnRvVXBwZXJDYXNlKCkgOiBwMS50b0xvd2VyQ2FzZSgpLFxuICApO1xuXG4vKipcbiAqIENvbnZlcnRzIHN0cmluZyB0byBwYXNjYWwgY2FzZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEEgcGFzY2FsaXplZCBzdHJpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IHRvUGFzY2FsQ2FzZSA9IDxUIGV4dGVuZHMgc3RyaW5nPihzdHJpbmc6IFQpOiBDYW1lbFRvUGFzY2FsPFQ+ID0+IHtcbiAgY29uc3QgY2FtZWxDYXNlID0gdG9DYW1lbENhc2Uoc3RyaW5nKTtcblxuICByZXR1cm4gKGNhbWVsQ2FzZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGNhbWVsQ2FzZS5zbGljZSgxKSkgYXMgQ2FtZWxUb1Bhc2NhbDxUPjtcbn07XG5cbi8qKlxuICogTWVyZ2VzIGNsYXNzZXMgaW50byBhIHNpbmdsZSBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge2FycmF5fSBjbGFzc2VzXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBBIHN0cmluZyBvZiBjbGFzc2VzXG4gKi9cbmV4cG9ydCBjb25zdCBtZXJnZUNsYXNzZXMgPSA8Q2xhc3NUeXBlID0gc3RyaW5nIHwgdW5kZWZpbmVkIHwgbnVsbD4oLi4uY2xhc3NlczogQ2xhc3NUeXBlW10pID0+XG4gIGNsYXNzZXNcbiAgICAuZmlsdGVyKChjbGFzc05hbWUsIGluZGV4LCBhcnJheSkgPT4ge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgQm9vbGVhbihjbGFzc05hbWUpICYmXG4gICAgICAgIChjbGFzc05hbWUgYXMgc3RyaW5nKS50cmltKCkgIT09ICcnICYmXG4gICAgICAgIGFycmF5LmluZGV4T2YoY2xhc3NOYW1lKSA9PT0gaW5kZXhcbiAgICAgICk7XG4gICAgfSlcbiAgICAuam9pbignICcpXG4gICAgLnRyaW0oKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/lucide-react/dist/esm/shared/src/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/next/dist/api/navigation.js":
/*!***************************************************!*\
  !*** ../node_modules/next/dist/api/navigation.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _client_components_navigation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../client/components/navigation */ \"(app-pages-browser)/../node_modules/next/dist/client/components/navigation.js\");\n/* harmony import */ var _client_components_navigation__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_client_components_navigation__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _client_components_navigation__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _client_components_navigation__WEBPACK_IMPORTED_MODULE_0__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n\n//# sourceMappingURL=navigation.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2FwaS9uYXZpZ2F0aW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFnRDs7QUFFaEQiLCJzb3VyY2VzIjpbIi9ob21lL2NvZGVyL09yY2hlUGxhbi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2FwaS9uYXZpZ2F0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gJy4uL2NsaWVudC9jb21wb25lbnRzL25hdmlnYXRpb24nO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1uYXZpZ2F0aW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/api/navigation.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2Fhome%2Fcoder%2FOrchePlan%2Ffrontend%2Fsrc%2Fapp%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!":
/*!*******************************************************************************************************************************************************************************************************************************!*\
  !*** ../node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2Fhome%2Fcoder%2FOrchePlan%2Ffrontend%2Fsrc%2Fapp%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false! ***!
  \*******************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/app/page.tsx */ \"(app-pages-browser)/./src/app/page.tsx\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWZsaWdodC1jbGllbnQtZW50cnktbG9hZGVyLmpzP21vZHVsZXM9JTdCJTIycmVxdWVzdCUyMiUzQSUyMiUyRmhvbWUlMkZjb2RlciUyRk9yY2hlUGxhbiUyRmZyb250ZW5kJTJGc3JjJTJGYXBwJTJGcGFnZS50c3glMjIlMkMlMjJpZHMlMjIlM0ElNUIlNUQlN0Qmc2VydmVyPWZhbHNlISIsIm1hcHBpbmdzIjoiQUFBQSw4SkFBb0YiLCJzb3VyY2VzIjpbIiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIi9ob21lL2NvZGVyL09yY2hlUGxhbi9mcm9udGVuZC9zcmMvYXBwL3BhZ2UudHN4XCIpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2Fhome%2Fcoder%2FOrchePlan%2Ffrontend%2Fsrc%2Fapp%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!*****************************************************************************************!*\
  !*** ../node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n true &&\n  (function () {\n    function getComponentNameFromType(type) {\n      if (null == type) return null;\n      if (\"function\" === typeof type)\n        return type.$$typeof === REACT_CLIENT_REFERENCE\n          ? null\n          : type.displayName || type.name || null;\n      if (\"string\" === typeof type) return type;\n      switch (type) {\n        case REACT_FRAGMENT_TYPE:\n          return \"Fragment\";\n        case REACT_PROFILER_TYPE:\n          return \"Profiler\";\n        case REACT_STRICT_MODE_TYPE:\n          return \"StrictMode\";\n        case REACT_SUSPENSE_TYPE:\n          return \"Suspense\";\n        case REACT_SUSPENSE_LIST_TYPE:\n          return \"SuspenseList\";\n        case REACT_ACTIVITY_TYPE:\n          return \"Activity\";\n      }\n      if (\"object\" === typeof type)\n        switch (\n          (\"number\" === typeof type.tag &&\n            console.error(\n              \"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"\n            ),\n          type.$$typeof)\n        ) {\n          case REACT_PORTAL_TYPE:\n            return \"Portal\";\n          case REACT_CONTEXT_TYPE:\n            return type.displayName || \"Context\";\n          case REACT_CONSUMER_TYPE:\n            return (type._context.displayName || \"Context\") + \".Consumer\";\n          case REACT_FORWARD_REF_TYPE:\n            var innerType = type.render;\n            type = type.displayName;\n            type ||\n              ((type = innerType.displayName || innerType.name || \"\"),\n              (type = \"\" !== type ? \"ForwardRef(\" + type + \")\" : \"ForwardRef\"));\n            return type;\n          case REACT_MEMO_TYPE:\n            return (\n              (innerType = type.displayName || null),\n              null !== innerType\n                ? innerType\n                : getComponentNameFromType(type.type) || \"Memo\"\n            );\n          case REACT_LAZY_TYPE:\n            innerType = type._payload;\n            type = type._init;\n            try {\n              return getComponentNameFromType(type(innerType));\n            } catch (x) {}\n        }\n      return null;\n    }\n    function testStringCoercion(value) {\n      return \"\" + value;\n    }\n    function checkKeyStringCoercion(value) {\n      try {\n        testStringCoercion(value);\n        var JSCompiler_inline_result = !1;\n      } catch (e) {\n        JSCompiler_inline_result = !0;\n      }\n      if (JSCompiler_inline_result) {\n        JSCompiler_inline_result = console;\n        var JSCompiler_temp_const = JSCompiler_inline_result.error;\n        var JSCompiler_inline_result$jscomp$0 =\n          (\"function\" === typeof Symbol &&\n            Symbol.toStringTag &&\n            value[Symbol.toStringTag]) ||\n          value.constructor.name ||\n          \"Object\";\n        JSCompiler_temp_const.call(\n          JSCompiler_inline_result,\n          \"The provided key is an unsupported type %s. This value must be coerced to a string before using it here.\",\n          JSCompiler_inline_result$jscomp$0\n        );\n        return testStringCoercion(value);\n      }\n    }\n    function getTaskName(type) {\n      if (type === REACT_FRAGMENT_TYPE) return \"<>\";\n      if (\n        \"object\" === typeof type &&\n        null !== type &&\n        type.$$typeof === REACT_LAZY_TYPE\n      )\n        return \"<...>\";\n      try {\n        var name = getComponentNameFromType(type);\n        return name ? \"<\" + name + \">\" : \"<...>\";\n      } catch (x) {\n        return \"<...>\";\n      }\n    }\n    function getOwner() {\n      var dispatcher = ReactSharedInternals.A;\n      return null === dispatcher ? null : dispatcher.getOwner();\n    }\n    function UnknownOwner() {\n      return Error(\"react-stack-top-frame\");\n    }\n    function hasValidKey(config) {\n      if (hasOwnProperty.call(config, \"key\")) {\n        var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n        if (getter && getter.isReactWarning) return !1;\n      }\n      return void 0 !== config.key;\n    }\n    function defineKeyPropWarningGetter(props, displayName) {\n      function warnAboutAccessingKey() {\n        specialPropKeyWarningShown ||\n          ((specialPropKeyWarningShown = !0),\n          console.error(\n            \"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)\",\n            displayName\n          ));\n      }\n      warnAboutAccessingKey.isReactWarning = !0;\n      Object.defineProperty(props, \"key\", {\n        get: warnAboutAccessingKey,\n        configurable: !0\n      });\n    }\n    function elementRefGetterWithDeprecationWarning() {\n      var componentName = getComponentNameFromType(this.type);\n      didWarnAboutElementRef[componentName] ||\n        ((didWarnAboutElementRef[componentName] = !0),\n        console.error(\n          \"Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release.\"\n        ));\n      componentName = this.props.ref;\n      return void 0 !== componentName ? componentName : null;\n    }\n    function ReactElement(type, key, props, owner, debugStack, debugTask) {\n      var refProp = props.ref;\n      type = {\n        $$typeof: REACT_ELEMENT_TYPE,\n        type: type,\n        key: key,\n        props: props,\n        _owner: owner\n      };\n      null !== (void 0 !== refProp ? refProp : null)\n        ? Object.defineProperty(type, \"ref\", {\n            enumerable: !1,\n            get: elementRefGetterWithDeprecationWarning\n          })\n        : Object.defineProperty(type, \"ref\", { enumerable: !1, value: null });\n      type._store = {};\n      Object.defineProperty(type._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: 0\n      });\n      Object.defineProperty(type, \"_debugInfo\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: null\n      });\n      Object.defineProperty(type, \"_debugStack\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: debugStack\n      });\n      Object.defineProperty(type, \"_debugTask\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: debugTask\n      });\n      Object.freeze && (Object.freeze(type.props), Object.freeze(type));\n      return type;\n    }\n    function jsxDEVImpl(\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      debugStack,\n      debugTask\n    ) {\n      var children = config.children;\n      if (void 0 !== children)\n        if (isStaticChildren)\n          if (isArrayImpl(children)) {\n            for (\n              isStaticChildren = 0;\n              isStaticChildren < children.length;\n              isStaticChildren++\n            )\n              validateChildKeys(children[isStaticChildren]);\n            Object.freeze && Object.freeze(children);\n          } else\n            console.error(\n              \"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\"\n            );\n        else validateChildKeys(children);\n      if (hasOwnProperty.call(config, \"key\")) {\n        children = getComponentNameFromType(type);\n        var keys = Object.keys(config).filter(function (k) {\n          return \"key\" !== k;\n        });\n        isStaticChildren =\n          0 < keys.length\n            ? \"{key: someKey, \" + keys.join(\": ..., \") + \": ...}\"\n            : \"{key: someKey}\";\n        didWarnAboutKeySpread[children + isStaticChildren] ||\n          ((keys =\n            0 < keys.length ? \"{\" + keys.join(\": ..., \") + \": ...}\" : \"{}\"),\n          console.error(\n            'A props object containing a \"key\" prop is being spread into JSX:\\n  let props = %s;\\n  <%s {...props} />\\nReact keys must be passed directly to JSX without using spread:\\n  let props = %s;\\n  <%s key={someKey} {...props} />',\n            isStaticChildren,\n            children,\n            keys,\n            children\n          ),\n          (didWarnAboutKeySpread[children + isStaticChildren] = !0));\n      }\n      children = null;\n      void 0 !== maybeKey &&\n        (checkKeyStringCoercion(maybeKey), (children = \"\" + maybeKey));\n      hasValidKey(config) &&\n        (checkKeyStringCoercion(config.key), (children = \"\" + config.key));\n      if (\"key\" in config) {\n        maybeKey = {};\n        for (var propName in config)\n          \"key\" !== propName && (maybeKey[propName] = config[propName]);\n      } else maybeKey = config;\n      children &&\n        defineKeyPropWarningGetter(\n          maybeKey,\n          \"function\" === typeof type\n            ? type.displayName || type.name || \"Unknown\"\n            : type\n        );\n      return ReactElement(\n        type,\n        children,\n        maybeKey,\n        getOwner(),\n        debugStack,\n        debugTask\n      );\n    }\n    function validateChildKeys(node) {\n      \"object\" === typeof node &&\n        null !== node &&\n        node.$$typeof === REACT_ELEMENT_TYPE &&\n        node._store &&\n        (node._store.validated = 1);\n    }\n    var React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/../node_modules/next/dist/compiled/react/index.js\"),\n      REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\n      REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"),\n      REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"),\n      REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"),\n      REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\"),\n      REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"),\n      REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"),\n      REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"),\n      REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"),\n      REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"),\n      REACT_MEMO_TYPE = Symbol.for(\"react.memo\"),\n      REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"),\n      REACT_ACTIVITY_TYPE = Symbol.for(\"react.activity\"),\n      REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"),\n      ReactSharedInternals =\n        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n      hasOwnProperty = Object.prototype.hasOwnProperty,\n      isArrayImpl = Array.isArray,\n      createTask = console.createTask\n        ? console.createTask\n        : function () {\n            return null;\n          };\n    React = {\n      react_stack_bottom_frame: function (callStackForError) {\n        return callStackForError();\n      }\n    };\n    var specialPropKeyWarningShown;\n    var didWarnAboutElementRef = {};\n    var unknownOwnerDebugStack = React.react_stack_bottom_frame.bind(\n      React,\n      UnknownOwner\n    )();\n    var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));\n    var didWarnAboutKeySpread = {};\n    exports.Fragment = REACT_FRAGMENT_TYPE;\n    exports.jsxDEV = function (type, config, maybeKey, isStaticChildren) {\n      var trackActualOwner =\n        1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;\n      return jsxDEVImpl(\n        type,\n        config,\n        maybeKey,\n        isStaticChildren,\n        trackActualOwner\n          ? Error(\"react-stack-top-frame\")\n          : unknownOwnerDebugStack,\n        trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask\n      );\n    };\n  })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhO0FBQ2IsS0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsK0NBQStDLDZCQUE2QjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZ0JBQWdCLGdEQUFnRDtBQUNoRSxnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBO0FBQ0EsZ0NBQWdDLGtDQUFrQyxPQUFPO0FBQ3pFO0FBQ0EsZ0dBQWdHLFNBQVMsVUFBVSxzRkFBc0YsYUFBYSxVQUFVLFVBQVU7QUFDMU87QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLHVHQUEwQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdCQUFnQjtBQUNwQixJQUFJLGNBQWM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHIiwic291cmNlcyI6WyIvaG9tZS9jb2Rlci9PcmNoZVBsYW4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgJiZcbiAgKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkge1xuICAgICAgaWYgKG51bGwgPT0gdHlwZSkgcmV0dXJuIG51bGw7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZSlcbiAgICAgICAgcmV0dXJuIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0VcbiAgICAgICAgICA/IG51bGxcbiAgICAgICAgICA6IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHR5cGUpIHJldHVybiB0eXBlO1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJGcmFnbWVudFwiO1xuICAgICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiUHJvZmlsZXJcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN0cmljdE1vZGVcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlTGlzdFwiO1xuICAgICAgICBjYXNlIFJFQUNUX0FDVElWSVRZX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiQWN0aXZpdHlcIjtcbiAgICAgIH1cbiAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZSlcbiAgICAgICAgc3dpdGNoIChcbiAgICAgICAgICAoXCJudW1iZXJcIiA9PT0gdHlwZW9mIHR5cGUudGFnICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlJlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSgpLiBUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICksXG4gICAgICAgICAgdHlwZS4kJHR5cGVvZilcbiAgICAgICAgKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiBcIlBvcnRhbFwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgXCJDb250ZXh0XCI7XG4gICAgICAgICAgY2FzZSBSRUFDVF9DT05TVU1FUl9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuICh0eXBlLl9jb250ZXh0LmRpc3BsYXlOYW1lIHx8IFwiQ29udGV4dFwiKSArIFwiLkNvbnN1bWVyXCI7XG4gICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgICAgdmFyIGlubmVyVHlwZSA9IHR5cGUucmVuZGVyO1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUuZGlzcGxheU5hbWU7XG4gICAgICAgICAgICB0eXBlIHx8XG4gICAgICAgICAgICAgICgodHlwZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCBcIlwiKSxcbiAgICAgICAgICAgICAgKHR5cGUgPSBcIlwiICE9PSB0eXBlID8gXCJGb3J3YXJkUmVmKFwiICsgdHlwZSArIFwiKVwiIDogXCJGb3J3YXJkUmVmXCIpKTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKGlubmVyVHlwZSA9IHR5cGUuZGlzcGxheU5hbWUgfHwgbnVsbCksXG4gICAgICAgICAgICAgIG51bGwgIT09IGlubmVyVHlwZVxuICAgICAgICAgICAgICAgID8gaW5uZXJUeXBlXG4gICAgICAgICAgICAgICAgOiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCBcIk1lbW9cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgIGlubmVyVHlwZSA9IHR5cGUuX3BheWxvYWQ7XG4gICAgICAgICAgICB0eXBlID0gdHlwZS5faW5pdDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZShpbm5lclR5cGUpKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiBcIlwiICsgdmFsdWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7XG4gICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSAhMTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gITA7XG4gICAgICB9XG4gICAgICBpZiAoSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0KSB7XG4gICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9IGNvbnNvbGU7XG4gICAgICAgIHZhciBKU0NvbXBpbGVyX3RlbXBfY29uc3QgPSBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQuZXJyb3I7XG4gICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDAgPVxuICAgICAgICAgIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBTeW1ib2wgJiZcbiAgICAgICAgICAgIFN5bWJvbC50b1N0cmluZ1RhZyAmJlxuICAgICAgICAgICAgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSkgfHxcbiAgICAgICAgICB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIHx8XG4gICAgICAgICAgXCJPYmplY3RcIjtcbiAgICAgICAgSlNDb21waWxlcl90ZW1wX2NvbnN0LmNhbGwoXG4gICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0LFxuICAgICAgICAgIFwiVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLiBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgdXNpbmcgaXQgaGVyZS5cIixcbiAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDBcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFRhc2tOYW1lKHR5cGUpIHtcbiAgICAgIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSByZXR1cm4gXCI8PlwiO1xuICAgICAgaWYgKFxuICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZSAmJlxuICAgICAgICBudWxsICE9PSB0eXBlICYmXG4gICAgICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRVxuICAgICAgKVxuICAgICAgICByZXR1cm4gXCI8Li4uPlwiO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG4gICAgICAgIHJldHVybiBuYW1lID8gXCI8XCIgKyBuYW1lICsgXCI+XCIgOiBcIjwuLi4+XCI7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIHJldHVybiBcIjwuLi4+XCI7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldE93bmVyKCkge1xuICAgICAgdmFyIGRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5BO1xuICAgICAgcmV0dXJuIG51bGwgPT09IGRpc3BhdGNoZXIgPyBudWxsIDogZGlzcGF0Y2hlci5nZXRPd25lcigpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBVbmtub3duT3duZXIoKSB7XG4gICAgICByZXR1cm4gRXJyb3IoXCJyZWFjdC1zdGFjay10b3AtZnJhbWVcIik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBcImtleVwiKSkge1xuICAgICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsIFwia2V5XCIpLmdldDtcbiAgICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2b2lkIDAgIT09IGNvbmZpZy5rZXk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICAgICAgZnVuY3Rpb24gd2FybkFib3V0QWNjZXNzaW5nS2V5KCkge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biB8fFxuICAgICAgICAgICgoc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSAhMCksXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSB2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50IHByb3AuIChodHRwczovL3JlYWN0LmRldi9saW5rL3NwZWNpYWwtcHJvcHMpXCIsXG4gICAgICAgICAgICBkaXNwbGF5TmFtZVxuICAgICAgICAgICkpO1xuICAgICAgfVxuICAgICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gITA7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsIFwia2V5XCIsIHtcbiAgICAgICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXksXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbGVtZW50UmVmR2V0dGVyV2l0aERlcHJlY2F0aW9uV2FybmluZygpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHRoaXMudHlwZSk7XG4gICAgICBkaWRXYXJuQWJvdXRFbGVtZW50UmVmW2NvbXBvbmVudE5hbWVdIHx8XG4gICAgICAgICgoZGlkV2FybkFib3V0RWxlbWVudFJlZltjb21wb25lbnROYW1lXSA9ICEwKSxcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIkFjY2Vzc2luZyBlbGVtZW50LnJlZiB3YXMgcmVtb3ZlZCBpbiBSZWFjdCAxOS4gcmVmIGlzIG5vdyBhIHJlZ3VsYXIgcHJvcC4gSXQgd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIEpTWCBFbGVtZW50IHR5cGUgaW4gYSBmdXR1cmUgcmVsZWFzZS5cIlxuICAgICAgICApKTtcbiAgICAgIGNvbXBvbmVudE5hbWUgPSB0aGlzLnByb3BzLnJlZjtcbiAgICAgIHJldHVybiB2b2lkIDAgIT09IGNvbXBvbmVudE5hbWUgPyBjb21wb25lbnROYW1lIDogbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgcHJvcHMsIG93bmVyLCBkZWJ1Z1N0YWNrLCBkZWJ1Z1Rhc2spIHtcbiAgICAgIHZhciByZWZQcm9wID0gcHJvcHMucmVmO1xuICAgICAgdHlwZSA9IHtcbiAgICAgICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAga2V5OiBrZXksXG4gICAgICAgIHByb3BzOiBwcm9wcyxcbiAgICAgICAgX293bmVyOiBvd25lclxuICAgICAgfTtcbiAgICAgIG51bGwgIT09ICh2b2lkIDAgIT09IHJlZlByb3AgPyByZWZQcm9wIDogbnVsbClcbiAgICAgICAgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZSwgXCJyZWZcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgICAgICBnZXQ6IGVsZW1lbnRSZWZHZXR0ZXJXaXRoRGVwcmVjYXRpb25XYXJuaW5nXG4gICAgICAgICAgfSlcbiAgICAgICAgOiBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZSwgXCJyZWZcIiwgeyBlbnVtZXJhYmxlOiAhMSwgdmFsdWU6IG51bGwgfSk7XG4gICAgICB0eXBlLl9zdG9yZSA9IHt9O1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUuX3N0b3JlLCBcInZhbGlkYXRlZFwiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgIHZhbHVlOiAwXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcIl9kZWJ1Z0luZm9cIiwge1xuICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZSwgXCJfZGVidWdTdGFja1wiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgIHZhbHVlOiBkZWJ1Z1N0YWNrXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcIl9kZWJ1Z1Rhc2tcIiwge1xuICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICB2YWx1ZTogZGVidWdUYXNrXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5mcmVlemUgJiYgKE9iamVjdC5mcmVlemUodHlwZS5wcm9wcyksIE9iamVjdC5mcmVlemUodHlwZSkpO1xuICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGpzeERFVkltcGwoXG4gICAgICB0eXBlLFxuICAgICAgY29uZmlnLFxuICAgICAgbWF5YmVLZXksXG4gICAgICBpc1N0YXRpY0NoaWxkcmVuLFxuICAgICAgZGVidWdTdGFjayxcbiAgICAgIGRlYnVnVGFza1xuICAgICkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gY29uZmlnLmNoaWxkcmVuO1xuICAgICAgaWYgKHZvaWQgMCAhPT0gY2hpbGRyZW4pXG4gICAgICAgIGlmIChpc1N0YXRpY0NoaWxkcmVuKVxuICAgICAgICAgIGlmIChpc0FycmF5SW1wbChjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgIGlzU3RhdGljQ2hpbGRyZW4gPSAwO1xuICAgICAgICAgICAgICBpc1N0YXRpY0NoaWxkcmVuIDwgY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgICBpc1N0YXRpY0NoaWxkcmVuKytcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baXNTdGF0aWNDaGlsZHJlbl0pO1xuICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZSAmJiBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiUmVhY3QuanN4OiBTdGF0aWMgY2hpbGRyZW4gc2hvdWxkIGFsd2F5cyBiZSBhbiBhcnJheS4gWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiBVc2UgdGhlIEJhYmVsIHRyYW5zZm9ybSBpbnN0ZWFkLlwiXG4gICAgICAgICAgICApO1xuICAgICAgICBlbHNlIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuKTtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgXCJrZXlcIikpIHtcbiAgICAgICAgY2hpbGRyZW4gPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoY29uZmlnKS5maWx0ZXIoZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICByZXR1cm4gXCJrZXlcIiAhPT0gaztcbiAgICAgICAgfSk7XG4gICAgICAgIGlzU3RhdGljQ2hpbGRyZW4gPVxuICAgICAgICAgIDAgPCBrZXlzLmxlbmd0aFxuICAgICAgICAgICAgPyBcIntrZXk6IHNvbWVLZXksIFwiICsga2V5cy5qb2luKFwiOiAuLi4sIFwiKSArIFwiOiAuLi59XCJcbiAgICAgICAgICAgIDogXCJ7a2V5OiBzb21lS2V5fVwiO1xuICAgICAgICBkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY2hpbGRyZW4gKyBpc1N0YXRpY0NoaWxkcmVuXSB8fFxuICAgICAgICAgICgoa2V5cyA9XG4gICAgICAgICAgICAwIDwga2V5cy5sZW5ndGggPyBcIntcIiArIGtleXMuam9pbihcIjogLi4uLCBcIikgKyBcIjogLi4ufVwiIDogXCJ7fVwiKSxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgJ0EgcHJvcHMgb2JqZWN0IGNvbnRhaW5pbmcgYSBcImtleVwiIHByb3AgaXMgYmVpbmcgc3ByZWFkIGludG8gSlNYOlxcbiAgbGV0IHByb3BzID0gJXM7XFxuICA8JXMgey4uLnByb3BzfSAvPlxcblJlYWN0IGtleXMgbXVzdCBiZSBwYXNzZWQgZGlyZWN0bHkgdG8gSlNYIHdpdGhvdXQgdXNpbmcgc3ByZWFkOlxcbiAgbGV0IHByb3BzID0gJXM7XFxuICA8JXMga2V5PXtzb21lS2V5fSB7Li4ucHJvcHN9IC8+JyxcbiAgICAgICAgICAgIGlzU3RhdGljQ2hpbGRyZW4sXG4gICAgICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgICAgIGtleXMsXG4gICAgICAgICAgICBjaGlsZHJlblxuICAgICAgICAgICksXG4gICAgICAgICAgKGRpZFdhcm5BYm91dEtleVNwcmVhZFtjaGlsZHJlbiArIGlzU3RhdGljQ2hpbGRyZW5dID0gITApKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkcmVuID0gbnVsbDtcbiAgICAgIHZvaWQgMCAhPT0gbWF5YmVLZXkgJiZcbiAgICAgICAgKGNoZWNrS2V5U3RyaW5nQ29lcmNpb24obWF5YmVLZXkpLCAoY2hpbGRyZW4gPSBcIlwiICsgbWF5YmVLZXkpKTtcbiAgICAgIGhhc1ZhbGlkS2V5KGNvbmZpZykgJiZcbiAgICAgICAgKGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSksIChjaGlsZHJlbiA9IFwiXCIgKyBjb25maWcua2V5KSk7XG4gICAgICBpZiAoXCJrZXlcIiBpbiBjb25maWcpIHtcbiAgICAgICAgbWF5YmVLZXkgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gY29uZmlnKVxuICAgICAgICAgIFwia2V5XCIgIT09IHByb3BOYW1lICYmIChtYXliZUtleVtwcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdKTtcbiAgICAgIH0gZWxzZSBtYXliZUtleSA9IGNvbmZpZztcbiAgICAgIGNoaWxkcmVuICYmXG4gICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKFxuICAgICAgICAgIG1heWJlS2V5LFxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGVcbiAgICAgICAgICAgID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgXCJVbmtub3duXCJcbiAgICAgICAgICAgIDogdHlwZVxuICAgICAgICApO1xuICAgICAgcmV0dXJuIFJlYWN0RWxlbWVudChcbiAgICAgICAgdHlwZSxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIG1heWJlS2V5LFxuICAgICAgICBnZXRPd25lcigpLFxuICAgICAgICBkZWJ1Z1N0YWNrLFxuICAgICAgICBkZWJ1Z1Rhc2tcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUpIHtcbiAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBub2RlICYmXG4gICAgICAgIG51bGwgIT09IG5vZGUgJiZcbiAgICAgICAgbm9kZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFICYmXG4gICAgICAgIG5vZGUuX3N0b3JlICYmXG4gICAgICAgIChub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSAxKTtcbiAgICB9XG4gICAgdmFyIFJlYWN0ID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9yZWFjdFwiKSxcbiAgICAgIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC50cmFuc2l0aW9uYWwuZWxlbWVudFwiKSxcbiAgICAgIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnBvcnRhbFwiKSxcbiAgICAgIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZnJhZ21lbnRcIiksXG4gICAgICBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN0cmljdF9tb2RlXCIpLFxuICAgICAgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm9maWxlclwiKSxcbiAgICAgIFJFQUNUX0NPTlNVTUVSX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuY29uc3VtZXJcIiksXG4gICAgICBSRUFDVF9DT05URVhUX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuY29udGV4dFwiKSxcbiAgICAgIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZm9yd2FyZF9yZWZcIiksXG4gICAgICBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlXCIpLFxuICAgICAgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlX2xpc3RcIiksXG4gICAgICBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QubWVtb1wiKSxcbiAgICAgIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5sYXp5XCIpLFxuICAgICAgUkVBQ1RfQUNUSVZJVFlfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5hY3Rpdml0eVwiKSxcbiAgICAgIFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UgPSBTeW1ib2wuZm9yKFwicmVhY3QuY2xpZW50LnJlZmVyZW5jZVwiKSxcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzID1cbiAgICAgICAgUmVhY3QuX19DTElFTlRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfV0FSTl9VU0VSU19USEVZX0NBTk5PVF9VUEdSQURFLFxuICAgICAgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LFxuICAgICAgaXNBcnJheUltcGwgPSBBcnJheS5pc0FycmF5LFxuICAgICAgY3JlYXRlVGFzayA9IGNvbnNvbGUuY3JlYXRlVGFza1xuICAgICAgICA/IGNvbnNvbGUuY3JlYXRlVGFza1xuICAgICAgICA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH07XG4gICAgUmVhY3QgPSB7XG4gICAgICByZWFjdF9zdGFja19ib3R0b21fZnJhbWU6IGZ1bmN0aW9uIChjYWxsU3RhY2tGb3JFcnJvcikge1xuICAgICAgICByZXR1cm4gY2FsbFN0YWNrRm9yRXJyb3IoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bjtcbiAgICB2YXIgZGlkV2FybkFib3V0RWxlbWVudFJlZiA9IHt9O1xuICAgIHZhciB1bmtub3duT3duZXJEZWJ1Z1N0YWNrID0gUmVhY3QucmVhY3Rfc3RhY2tfYm90dG9tX2ZyYW1lLmJpbmQoXG4gICAgICBSZWFjdCxcbiAgICAgIFVua25vd25Pd25lclxuICAgICkoKTtcbiAgICB2YXIgdW5rbm93bk93bmVyRGVidWdUYXNrID0gY3JlYXRlVGFzayhnZXRUYXNrTmFtZShVbmtub3duT3duZXIpKTtcbiAgICB2YXIgZGlkV2FybkFib3V0S2V5U3ByZWFkID0ge307XG4gICAgZXhwb3J0cy5GcmFnbWVudCA9IFJFQUNUX0ZSQUdNRU5UX1RZUEU7XG4gICAgZXhwb3J0cy5qc3hERVYgPSBmdW5jdGlvbiAodHlwZSwgY29uZmlnLCBtYXliZUtleSwgaXNTdGF0aWNDaGlsZHJlbikge1xuICAgICAgdmFyIHRyYWNrQWN0dWFsT3duZXIgPVxuICAgICAgICAxZTQgPiBSZWFjdFNoYXJlZEludGVybmFscy5yZWNlbnRseUNyZWF0ZWRPd25lclN0YWNrcysrO1xuICAgICAgcmV0dXJuIGpzeERFVkltcGwoXG4gICAgICAgIHR5cGUsXG4gICAgICAgIGNvbmZpZyxcbiAgICAgICAgbWF5YmVLZXksXG4gICAgICAgIGlzU3RhdGljQ2hpbGRyZW4sXG4gICAgICAgIHRyYWNrQWN0dWFsT3duZXJcbiAgICAgICAgICA/IEVycm9yKFwicmVhY3Qtc3RhY2stdG9wLWZyYW1lXCIpXG4gICAgICAgICAgOiB1bmtub3duT3duZXJEZWJ1Z1N0YWNrLFxuICAgICAgICB0cmFja0FjdHVhbE93bmVyID8gY3JlYXRlVGFzayhnZXRUYXNrTmFtZSh0eXBlKSkgOiB1bmtub3duT3duZXJEZWJ1Z1Rhc2tcbiAgICAgICk7XG4gICAgfTtcbiAgfSkoKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!*******************************************************************!*\
  !*** ../node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/../node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2pzeC1kZXYtcnVudGltZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixJQUFJLEtBQXFDLEVBQUUsRUFFMUMsQ0FBQztBQUNGLEVBQUUsK0xBQXNFO0FBQ3hFIiwic291cmNlcyI6WyIvaG9tZS9jb2Rlci9PcmNoZVBsYW4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9qc3gtZGV2LXJ1bnRpbWUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5wcm9kdWN0aW9uLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/page.tsx":
/*!**************************!*\
  !*** ./src/app/page.tsx ***!
  \**************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ RootPage)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/../node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/../node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/navigation */ \"(app-pages-browser)/../node_modules/next/dist/api/navigation.js\");\n/* harmony import */ var _context_app_context__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/context/app-context */ \"(app-pages-browser)/./src/context/app-context.tsx\");\n/* harmony import */ var _barrel_optimize_names_Loader2_lucide_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! __barrel_optimize__?names=Loader2!=!lucide-react */ \"(app-pages-browser)/../node_modules/lucide-react/dist/esm/icons/loader-circle.js\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\nfunction RootPage() {\n    _s();\n    const { currentUser, loading } = (0,_context_app_context__WEBPACK_IMPORTED_MODULE_3__.useApp)();\n    const router = (0,next_navigation__WEBPACK_IMPORTED_MODULE_2__.useRouter)();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"RootPage.useEffect\": ()=>{\n            if (!loading) {\n                if (currentUser) {\n                    router.replace('/dashboard');\n                } else {\n                    router.replace('/login');\n                }\n            }\n        }\n    }[\"RootPage.useEffect\"], [\n        currentUser,\n        loading,\n        router\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"flex h-screen items-center justify-center\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Loader2_lucide_react__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n            className: \"h-8 w-8 animate-spin\"\n        }, void 0, false, {\n            fileName: \"/home/coder/OrchePlan/frontend/src/app/page.tsx\",\n            lineNumber: 24,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"/home/coder/OrchePlan/frontend/src/app/page.tsx\",\n        lineNumber: 23,\n        columnNumber: 5\n    }, this);\n}\n_s(RootPage, \"MZ80Zrk+647IDsRvLOaw3J1haJI=\", false, function() {\n    return [\n        _context_app_context__WEBPACK_IMPORTED_MODULE_3__.useApp,\n        next_navigation__WEBPACK_IMPORTED_MODULE_2__.useRouter\n    ];\n});\n_c = RootPage;\nvar _c;\n$RefreshReg$(_c, \"RootPage\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvcGFnZS50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBRWtDO0FBQ1U7QUFDRztBQUNSO0FBRXhCLFNBQVNJOztJQUN0QixNQUFNLEVBQUVDLFdBQVcsRUFBRUMsT0FBTyxFQUFFLEdBQUdKLDREQUFNQTtJQUN2QyxNQUFNSyxTQUFTTiwwREFBU0E7SUFFeEJELGdEQUFTQTs4QkFBQztZQUNSLElBQUksQ0FBQ00sU0FBUztnQkFDWixJQUFJRCxhQUFhO29CQUNmRSxPQUFPQyxPQUFPLENBQUM7Z0JBQ2pCLE9BQU87b0JBQ0xELE9BQU9DLE9BQU8sQ0FBQztnQkFDakI7WUFDRjtRQUNGOzZCQUFHO1FBQUNIO1FBQWFDO1FBQVNDO0tBQU87SUFFakMscUJBQ0UsOERBQUNFO1FBQUlDLFdBQVU7a0JBQ2IsNEVBQUNQLG1GQUFPQTtZQUFDTyxXQUFVOzs7Ozs7Ozs7OztBQUd6QjtHQW5Cd0JOOztRQUNXRix3REFBTUE7UUFDeEJELHNEQUFTQTs7O0tBRkZHIiwic291cmNlcyI6WyIvaG9tZS9jb2Rlci9PcmNoZVBsYW4vZnJvbnRlbmQvc3JjL2FwcC9wYWdlLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5cbmltcG9ydCB7IHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZVJvdXRlciB9IGZyb20gJ25leHQvbmF2aWdhdGlvbic7XG5pbXBvcnQgeyB1c2VBcHAgfSBmcm9tICdAL2NvbnRleHQvYXBwLWNvbnRleHQnO1xuaW1wb3J0IHsgTG9hZGVyMiB9IGZyb20gJ2x1Y2lkZS1yZWFjdCc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFJvb3RQYWdlKCkge1xuICBjb25zdCB7IGN1cnJlbnRVc2VyLCBsb2FkaW5nIH0gPSB1c2VBcHAoKTtcbiAgY29uc3Qgcm91dGVyID0gdXNlUm91dGVyKCk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWxvYWRpbmcpIHtcbiAgICAgIGlmIChjdXJyZW50VXNlcikge1xuICAgICAgICByb3V0ZXIucmVwbGFjZSgnL2Rhc2hib2FyZCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm91dGVyLnJlcGxhY2UoJy9sb2dpbicpO1xuICAgICAgfVxuICAgIH1cbiAgfSwgW2N1cnJlbnRVc2VyLCBsb2FkaW5nLCByb3V0ZXJdKTtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBoLXNjcmVlbiBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXJcIj5cbiAgICAgIDxMb2FkZXIyIGNsYXNzTmFtZT1cImgtOCB3LTggYW5pbWF0ZS1zcGluXCIgLz5cbiAgICA8L2Rpdj5cbiAgKTtcbn1cbiJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VSb3V0ZXIiLCJ1c2VBcHAiLCJMb2FkZXIyIiwiUm9vdFBhZ2UiLCJjdXJyZW50VXNlciIsImxvYWRpbmciLCJyb3V0ZXIiLCJyZXBsYWNlIiwiZGl2IiwiY2xhc3NOYW1lIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/page.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/context/app-context.tsx":
/*!*************************************!*\
  !*** ./src/context/app-context.tsx ***!
  \*************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AppProvider: () => (/* binding */ AppProvider),\n/* harmony export */   useApp: () => (/* binding */ useApp)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/../node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/../node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _lib_api__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/api */ \"(app-pages-browser)/./src/lib/api.ts\");\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/navigation */ \"(app-pages-browser)/../node_modules/next/dist/api/navigation.js\");\n/* harmony import */ var _lib_realtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../lib/realtime */ \"(app-pages-browser)/./src/lib/realtime.ts\");\n/* harmony import */ var _lib_logger__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/lib/logger */ \"(app-pages-browser)/./src/lib/logger.ts\");\n/* harmony import */ var _lib_cached_api__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/lib/cached-api */ \"(app-pages-browser)/./src/lib/cached-api.ts\");\n/* __next_internal_client_entry_do_not_use__ AppProvider,useApp auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\n\n\n\nconst AppContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\nconst logger = (0,_lib_logger__WEBPACK_IMPORTED_MODULE_5__.createComponentLogger)('AppContext');\nfunction AppProvider(param) {\n    let { children } = param;\n    _s();\n    const [users, setUsers] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(new Map());\n    const [projects, setProjects] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [tasks, setTasks] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [currentUser, setCurrentUser] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [isKanbanHeaderVisible, setIsKanbanHeaderVisible] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [isSidebarOpenByDefault, setIsSidebarOpenByDefault] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [cardDensity, setCardDensityState] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('comfortable');\n    const [defaultView, setDefaultViewState] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('board');\n    const [groupByStatus, setGroupByStatusState] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const router = (0,next_navigation__WEBPACK_IMPORTED_MODULE_3__.useRouter)();\n    const pathname = (0,next_navigation__WEBPACK_IMPORTED_MODULE_3__.usePathname)();\n    // Debounced task updates for drag operations\n    const pendingTaskUpdates = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Map());\n    const updateTaskTimeouts = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Map());\n    // Realtime client for SSE updates\n    const realtimeClient = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [isRealtimeConnected, setIsRealtimeConnected] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // normalize a single project object from backend into frontend shape\n    const normalizeProject = (p)=>{\n        if (!p) return p;\n        const taskStatusOptions = Array.isArray(p.statuses) ? p.statuses.map((s)=>{\n            const label = (s.label || '').toString();\n            // fallback color map when DB doesn't have a color\n            const fallback = (()=>{\n                const key = label.trim().toLowerCase();\n                if (key === 'to-do' || key === 'todo' || key === 'to do') return '#3B82F6';\n                if (key === 'in progress' || key === 'in-progress') return '#EAB308';\n                if (key === 'done') return '#22C55E';\n                if (key === 'remove' || key === 'removed' || key === 'archive') return '#EF4444';\n                return '#E5E7EB';\n            })();\n            return {\n                id: s.id,\n                name: s.label,\n                color: s.color || fallback,\n                order: s.order,\n                showStrikeThrough: s.showStrikeThrough || false,\n                hidden: s.hidden || false,\n                requiresComment: s.requiresComment || false,\n                allowsComment: s.allowsComment || false\n            };\n        }) : [];\n        // normalize members array -> map if needed\n        if (Array.isArray(p.members)) {\n            const map = {};\n            p.members.forEach((m)=>{\n                if (m && m.userId && m.role) map[m.userId] = m.role;\n            });\n            return {\n                ...p,\n                members: map,\n                taskStatusOptions\n            };\n        }\n        return {\n            ...p,\n            members: p.members || {},\n            taskStatusOptions\n        };\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"AppProvider.useEffect\": ()=>{\n            var _document_cookie_split_find;\n            const cookieValue = (_document_cookie_split_find = document.cookie.split('; ').find({\n                \"AppProvider.useEffect\": (row)=>row.startsWith('sidebar_default_open=')\n            }[\"AppProvider.useEffect\"])) === null || _document_cookie_split_find === void 0 ? void 0 : _document_cookie_split_find.split('=')[1];\n            if (cookieValue) {\n                setIsSidebarOpenByDefault(cookieValue === 'true');\n            }\n        }\n    }[\"AppProvider.useEffect\"], []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"AppProvider.useEffect\": ()=>{\n            try {\n                const stored = window.localStorage.getItem('card_density');\n                if (stored === 'compact' || stored === 'comfortable') setCardDensityState(stored);\n                const dv = window.localStorage.getItem('default_view');\n                if (dv === 'board' || dv === 'list') setDefaultViewState(dv);\n                const gb = window.localStorage.getItem('group_by_status');\n                if (gb === 'true' || gb === 'false') setGroupByStatusState(gb === 'true');\n            } catch (e) {\n            // ignore\n            }\n        }\n    }[\"AppProvider.useEffect\"], []);\n    const toggleSidebarDefault = ()=>{\n        setIsSidebarOpenByDefault((prevState)=>{\n            const newState = !prevState;\n            document.cookie = \"sidebar_default_open=\".concat(newState, \";path=/;max-age=31536000\"); // Expires in 1 year\n            return newState;\n        });\n    };\n    const setCardDensity = (d)=>{\n        setCardDensityState(d);\n        try {\n            window.localStorage.setItem('card_density', d);\n        } catch (e) {\n        // ignore\n        }\n    };\n    const setDefaultView = (v)=>{\n        setDefaultViewState(v);\n        try {\n            window.localStorage.setItem('default_view', v);\n        } catch (e) {\n        // ignore\n        }\n    };\n    const setGroupByStatus = (v)=>{\n        setGroupByStatusState(v);\n        try {\n            window.localStorage.setItem('group_by_status', v ? 'true' : 'false');\n        } catch (e) {\n        // ignore\n        }\n    };\n    // apply global body class for consumption by other components/styles\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"AppProvider.useEffect\": ()=>{\n            try {\n                if (cardDensity === 'compact') {\n                    document.body.classList.add('compact');\n                } else {\n                    document.body.classList.remove('compact');\n                }\n            } catch (e) {\n            // ignore\n            }\n        }\n    }[\"AppProvider.useEffect\"], [\n        cardDensity\n    ]);\n    const toggleKanbanHeader = ()=>{\n        setIsKanbanHeaderVisible((prevState)=>!prevState);\n    };\n    const clearState = ()=>{\n        setUsers(new Map());\n        setProjects([]);\n        setTasks([]);\n        setCurrentUser(null);\n    };\n    // Clear all authentication data including cookies\n    const clearAllAuthData = ()=>{\n        clearState();\n        // Clear authentication cookie\n        document.cookie = 'orcheplan_token=; Path=/; Expires=Thu, 01 Jan 1970 00:00:01 GMT;';\n        // Clear any cached data\n        (0,_lib_cached_api__WEBPACK_IMPORTED_MODULE_6__.clearAllCaches)();\n    };\n    const fetchData = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"AppProvider.useCallback[fetchData]\": async (currentUserId)=>{\n            setLoading(true);\n            try {\n                // Use cached API calls with stale-while-revalidate strategy\n                const projectsResp = await (0,_lib_cached_api__WEBPACK_IMPORTED_MODULE_6__.getCachedProjects)({\n                    staleWhileRevalidate: true\n                });\n                const allProjectsFlat = projectsResp || [];\n                // Build nested structure\n                const projectMap = new Map();\n                allProjectsFlat.forEach({\n                    \"AppProvider.useCallback[fetchData]\": (p)=>projectMap.set(p.id, {\n                            ...normalizeProject(p),\n                            subProjects: []\n                        })\n                }[\"AppProvider.useCallback[fetchData]\"]);\n                const nestedProjects = [];\n                projectMap.forEach({\n                    \"AppProvider.useCallback[fetchData]\": (project)=>{\n                        if (project.parentProjectId) {\n                            const parent = projectMap.get(project.parentProjectId);\n                            if (parent) parent.subProjects.push(project);\n                            else nestedProjects.push(project);\n                        } else {\n                            nestedProjects.push(project);\n                        }\n                    }\n                }[\"AppProvider.useCallback[fetchData]\"]);\n                setProjects(nestedProjects);\n                // Fetch users with caching\n                const usersResp = await (0,_lib_cached_api__WEBPACK_IMPORTED_MODULE_6__.getCachedUsers)({\n                    staleWhileRevalidate: true\n                });\n                const userList = usersResp || [];\n                const userMap = new Map();\n                userList.forEach({\n                    \"AppProvider.useCallback[fetchData]\": (u)=>userMap.set(u.id, u)\n                }[\"AppProvider.useCallback[fetchData]\"]);\n                setUsers(userMap);\n                // Log cache performance\n                const stats = (0,_lib_cached_api__WEBPACK_IMPORTED_MODULE_6__.getCacheStats)();\n                logger.debug('Cache performance', {\n                    component: 'fetchData',\n                    stats: {\n                        hitRate: \"\".concat((stats.hitRate * 100).toFixed(1), \"%\"),\n                        hits: stats.hits,\n                        misses: stats.misses,\n                        size: stats.size\n                    }\n                });\n            } catch (error) {\n                console.error('Error fetching data:', error);\n                // If we get authentication errors, the stored auth might be stale\n                if ((error === null || error === void 0 ? void 0 : error.status) === 401 || (error === null || error === void 0 ? void 0 : error.status) === 404) {\n                    console.warn('Authentication appears stale, clearing all authentication data');\n                    clearAllAuthData();\n                    router === null || router === void 0 ? void 0 : router.push('/login');\n                } else if ((error === null || error === void 0 ? void 0 : error.status) === 403) {\n                    console.warn('Access forbidden, clearing cached data');\n                    (0,_lib_cached_api__WEBPACK_IMPORTED_MODULE_6__.clearAllCaches)();\n                // Don't re-fetch automatically to avoid infinite loops\n                }\n            } finally{\n                setLoading(false);\n            }\n        }\n    }[\"AppProvider.useCallback[fetchData]\"], []);\n    // Refresh projects without changing loading state\n    const refreshProjects = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"AppProvider.useCallback[refreshProjects]\": async ()=>{\n            try {\n                // Force refresh to bypass cache\n                const projectsResp = await (0,_lib_cached_api__WEBPACK_IMPORTED_MODULE_6__.getCachedProjects)({\n                    forceRefresh: true\n                });\n                const allProjectsFlat = projectsResp || [];\n                const projectMap = new Map();\n                allProjectsFlat.forEach({\n                    \"AppProvider.useCallback[refreshProjects]\": (p)=>projectMap.set(p.id, {\n                            ...normalizeProject(p),\n                            subProjects: []\n                        })\n                }[\"AppProvider.useCallback[refreshProjects]\"]);\n                const nestedProjects = [];\n                projectMap.forEach({\n                    \"AppProvider.useCallback[refreshProjects]\": (project)=>{\n                        if (project.parentProjectId) {\n                            const parent = projectMap.get(project.parentProjectId);\n                            if (parent) parent.subProjects.push(project);\n                            else nestedProjects.push(project);\n                        } else {\n                            nestedProjects.push(project);\n                        }\n                    }\n                }[\"AppProvider.useCallback[refreshProjects]\"]);\n                setProjects(nestedProjects);\n            } catch (error) {\n                console.error('Error refreshing projects:', error);\n            }\n        }\n    }[\"AppProvider.useCallback[refreshProjects]\"], []);\n    // Expose cache clearing function globally for debugging\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"AppProvider.useEffect\": ()=>{\n            window.clearOrchePlanCache = ({\n                \"AppProvider.useEffect\": ()=>{\n                    (0,_lib_cached_api__WEBPACK_IMPORTED_MODULE_6__.clearAllCaches)();\n                    if (currentUser === null || currentUser === void 0 ? void 0 : currentUser.id) {\n                        fetchData(currentUser.id);\n                    }\n                }\n            })[\"AppProvider.useEffect\"];\n            return ({\n                \"AppProvider.useEffect\": ()=>{\n                    delete window.clearOrchePlanCache;\n                }\n            })[\"AppProvider.useEffect\"];\n        }\n    }[\"AppProvider.useEffect\"], [\n        currentUser,\n        fetchData\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"AppProvider.useEffect\": ()=>{\n            let mounted = true;\n            ({\n                \"AppProvider.useEffect\": async ()=>{\n                    try {\n                        setLoading(true);\n                        const resp = await (0,_lib_api__WEBPACK_IMPORTED_MODULE_2__.authMe)();\n                        const user = resp === null || resp === void 0 ? void 0 : resp.user;\n                        if (mounted && user) {\n                            setCurrentUser(user);\n                            await fetchData(user.id);\n                        } else if (mounted) {\n                            // No user logged in (resp is null) - this is normal, not an error\n                            clearState();\n                        }\n                    } catch (err) {\n                        console.warn('Error checking authentication', err);\n                        clearState();\n                    } finally{\n                        if (mounted) setLoading(false);\n                    }\n                }\n            })[\"AppProvider.useEffect\"]();\n            return ({\n                \"AppProvider.useEffect\": ()=>{\n                    mounted = false;\n                }\n            })[\"AppProvider.useEffect\"];\n        }\n    }[\"AppProvider.useEffect\"], [\n        fetchData\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"AppProvider.useEffect\": ()=>{\n            if (loading) return;\n            if (!currentUser && pathname !== '/login' && pathname !== '/signup') {\n                router.push('/login');\n            }\n        }\n    }[\"AppProvider.useEffect\"], [\n        currentUser,\n        loading,\n        pathname,\n        router\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"AppProvider.useEffect\": ()=>{\n            if (!currentUser || projects.length === 0) {\n                setTasks([]);\n                return;\n            }\n            // Initial fetch of tasks\n            const getAllProjectIds = {\n                \"AppProvider.useEffect.getAllProjectIds\": (projs)=>{\n                    let ids = [];\n                    projs.forEach({\n                        \"AppProvider.useEffect.getAllProjectIds\": (p)=>{\n                            ids.push(p.id);\n                            if (p.subProjects) {\n                                ids = ids.concat(getAllProjectIds(p.subProjects));\n                            }\n                        }\n                    }[\"AppProvider.useEffect.getAllProjectIds\"]);\n                    return ids;\n                }\n            }[\"AppProvider.useEffect.getAllProjectIds\"];\n            const allProjectIds = getAllProjectIds(projects);\n            if (allProjectIds.length === 0) {\n                setTasks([]);\n                return;\n            }\n            const CHUNK_SIZE = 100; // Increased from 30 to reduce API calls\n            const projectChunks = [];\n            for(let i = 0; i < allProjectIds.length; i += CHUNK_SIZE){\n                projectChunks.push(allProjectIds.slice(i, i + CHUNK_SIZE));\n            }\n            // Normalize task data\n            const normalizeTask = {\n                \"AppProvider.useEffect.normalizeTask\": (t)=>{\n                    var _t_statusId, _t_assigneeId, _t_parentId;\n                    return {\n                        ...t,\n                        status: (_t_statusId = t.statusId) !== null && _t_statusId !== void 0 ? _t_statusId : typeof t.status === 'string' && /^[0-9a-fA-F-]{36}$/.test(t.status) ? t.status : null,\n                        assigneeId: (_t_assigneeId = t.assigneeId) !== null && _t_assigneeId !== void 0 ? _t_assigneeId : undefined,\n                        parentId: (_t_parentId = t.parentId) !== null && _t_parentId !== void 0 ? _t_parentId : undefined\n                    };\n                }\n            }[\"AppProvider.useEffect.normalizeTask\"];\n            // Task fetching function for both initial load and fallback polling\n            const fetchTasks = {\n                \"AppProvider.useEffect.fetchTasks\": async function() {\n                    let forceRefresh = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;\n                    try {\n                        const results = await Promise.all(projectChunks.map({\n                            \"AppProvider.useEffect.fetchTasks\": (chunk)=>(0,_lib_cached_api__WEBPACK_IMPORTED_MODULE_6__.getCachedTasksByProjectIds)(chunk, {\n                                    forceRefresh,\n                                    staleWhileRevalidate: !forceRefresh\n                                })\n                        }[\"AppProvider.useEffect.fetchTasks\"]));\n                        const combined = results.flat();\n                        const normalizedTasks = combined.map(normalizeTask);\n                        setTasks(normalizedTasks);\n                        return normalizedTasks;\n                    } catch (err) {\n                        console.error('Error fetching tasks:', err);\n                        console.error('[DEBUG] Failed to fetch tasks for project IDs:', allProjectIds);\n                        // If we get a 403 error, it's likely due to requesting tasks for projects\n                        // the user no longer has access to. Clear caches but don't retry automatically.\n                        if ((err === null || err === void 0 ? void 0 : err.status) === 403) {\n                            console.warn('Forbidden error fetching tasks, clearing caches');\n                            (0,_lib_cached_api__WEBPACK_IMPORTED_MODULE_6__.clearAllCaches)();\n                        // Don't retry automatically to avoid infinite loops\n                        }\n                        return [];\n                    }\n                }\n            }[\"AppProvider.useEffect.fetchTasks\"];\n            // Initial task fetch\n            fetchTasks();\n            // Polling fallback variables\n            let pollingInterval = null;\n            let lastTaskCount = 0;\n            let consecutiveNoChanges = 0;\n            let isWindowActive = true;\n            // Smart polling intervals for fallback\n            const getPollingInterval = {\n                \"AppProvider.useEffect.getPollingInterval\": ()=>{\n                    if (!isWindowActive) return 60000; // 1 minute when tab is not active\n                    if (consecutiveNoChanges > 3) return 30000; // 30 seconds after no changes\n                    return 15000; // 15 seconds for fallback polling (faster than before)\n                }\n            }[\"AppProvider.useEffect.getPollingInterval\"];\n            const startPolling = {\n                \"AppProvider.useEffect.startPolling\": ()=>{\n                    if (pollingInterval) clearInterval(pollingInterval);\n                    const poll = {\n                        \"AppProvider.useEffect.startPolling.poll\": async ()=>{\n                            const tasks = await fetchTasks();\n                            // Track changes to adjust polling frequency\n                            if (tasks.length === lastTaskCount) {\n                                consecutiveNoChanges++;\n                            } else {\n                                consecutiveNoChanges = 0;\n                                lastTaskCount = tasks.length;\n                            }\n                            // Restart with potentially new interval\n                            startPolling();\n                        }\n                    }[\"AppProvider.useEffect.startPolling.poll\"];\n                    pollingInterval = setInterval(poll, getPollingInterval());\n                }\n            }[\"AppProvider.useEffect.startPolling\"];\n            // Window focus/blur detection for smart polling\n            const handleFocus = {\n                \"AppProvider.useEffect.handleFocus\": ()=>{\n                    isWindowActive = true;\n                    consecutiveNoChanges = 0; // Reset when user returns\n                }\n            }[\"AppProvider.useEffect.handleFocus\"];\n            const handleBlur = {\n                \"AppProvider.useEffect.handleBlur\": ()=>{\n                    isWindowActive = false;\n                }\n            }[\"AppProvider.useEffect.handleBlur\"];\n            // Try to initialize SSE connection for real-time updates with improved implementation\n            if (!realtimeClient.current) {\n                // Use the same API base as the rest of the app for consistency\n                const getApiBase = {\n                    \"AppProvider.useEffect.getApiBase\": ()=>{\n                        // Use environment variable if set\n                        if (true) {\n                            return \"https://3000--main--orcheplan--andreas.coder.josern.com\";\n                        }\n                        if (true) {\n                            return \"https://3000--main--orcheplan--andreas.coder.josern.com\";\n                        }\n                        if (false) {}\n                        const hostname = window.location.hostname;\n                        const protocol = window.location.protocol;\n                        // Local development\n                        if (hostname === 'localhost' || hostname === '127.0.0.1') {\n                            return 'http://localhost:3000';\n                        }\n                        // External server - construct backend URL\n                        // In Coder environment, use HTTPS for backend as well\n                        const isCoderEnv = hostname.includes('coder.josern.com');\n                        const backendProtocol = isCoderEnv ? 'https:' : protocol;\n                        if (isCoderEnv) {\n                            // Special handling for Coder subdomain pattern\n                            const backendHostname = hostname.replace(/^9002--/, '3000--');\n                            return \"\".concat(backendProtocol, \"//\").concat(backendHostname);\n                        }\n                        return \"\".concat(backendProtocol, \"//\").concat(hostname, \":3000\");\n                    }\n                }[\"AppProvider.useEffect.getApiBase\"];\n                const baseUrl = getApiBase();\n                realtimeClient.current = new _lib_realtime__WEBPACK_IMPORTED_MODULE_4__[\"default\"](baseUrl);\n                // Set up event listeners for real-time updates\n                realtimeClient.current.on('task_update', {\n                    \"AppProvider.useEffect\": (data)=>{\n                        const { action, data: taskData } = data;\n                        const normalizedTask = normalizeTask(taskData);\n                        setTasks({\n                            \"AppProvider.useEffect\": (prev)=>{\n                                switch(action){\n                                    case 'created':\n                                        // Add new task if not already present (check by ID)\n                                        const existingTask = prev.find({\n                                            \"AppProvider.useEffect.existingTask\": (t)=>t.id === normalizedTask.id\n                                        }[\"AppProvider.useEffect.existingTask\"]);\n                                        if (!existingTask) {\n                                            return [\n                                                ...prev,\n                                                normalizedTask\n                                            ];\n                                        } else {\n                                            return prev;\n                                        }\n                                    case 'updated':\n                                        // Update existing task\n                                        return prev.map({\n                                            \"AppProvider.useEffect\": (t)=>t.id === normalizedTask.id ? normalizedTask : t\n                                        }[\"AppProvider.useEffect\"]);\n                                    case 'deleted':\n                                        // Remove deleted task\n                                        return prev.filter({\n                                            \"AppProvider.useEffect\": (t)=>t.id !== normalizedTask.id\n                                        }[\"AppProvider.useEffect\"]);\n                                    default:\n                                        return prev;\n                                }\n                            }\n                        }[\"AppProvider.useEffect\"]);\n                    }\n                }[\"AppProvider.useEffect\"]);\n                realtimeClient.current.on('project_update', {\n                    \"AppProvider.useEffect\": (data)=>{\n                        // Handle project updates - refresh projects to get updated membership/access\n                        refreshProjects();\n                    }\n                }[\"AppProvider.useEffect\"]);\n                realtimeClient.current.on('status_update', {\n                    \"AppProvider.useEffect\": (data)=>{\n                    // Handle status updates - could update project status options\n                    }\n                }[\"AppProvider.useEffect\"]);\n                // Handle SSE connection failure - fall back to polling\n                realtimeClient.current.on('connection_failed', {\n                    \"AppProvider.useEffect\": (data)=>{\n                        setIsRealtimeConnected(false);\n                        // Set up window focus/blur listeners for smart polling\n                        window.addEventListener('focus', handleFocus);\n                        window.addEventListener('blur', handleBlur);\n                        // Start polling as fallback\n                        startPolling();\n                    }\n                }[\"AppProvider.useEffect\"]);\n            }\n            // Try to connect to real-time updates\n            realtimeClient.current.connect();\n            // Set a timeout to fall back to polling if SSE doesn't connect within 10 seconds\n            setTimeout({\n                \"AppProvider.useEffect\": ()=>{\n                    var _realtimeClient_current;\n                    if (!((_realtimeClient_current = realtimeClient.current) === null || _realtimeClient_current === void 0 ? void 0 : _realtimeClient_current.getConnectionStatus())) {\n                        setIsRealtimeConnected(false);\n                        window.addEventListener('focus', handleFocus);\n                        window.addEventListener('blur', handleBlur);\n                        startPolling();\n                    } else {\n                        setIsRealtimeConnected(true);\n                    }\n                }\n            }[\"AppProvider.useEffect\"], 10000);\n            return ({\n                \"AppProvider.useEffect\": ()=>{\n                    // Clean up on unmount or dependency change\n                    if (realtimeClient.current) {\n                        realtimeClient.current.disconnect();\n                    }\n                    if (pollingInterval) {\n                        clearInterval(pollingInterval);\n                    }\n                    window.removeEventListener('focus', handleFocus);\n                    window.removeEventListener('blur', handleBlur);\n                    setIsRealtimeConnected(false);\n                }\n            })[\"AppProvider.useEffect\"];\n        }\n    }[\"AppProvider.useEffect\"], [\n        currentUser,\n        projects\n    ]);\n    const addDefaultTaskStatuses = async (projectId)=>{\n        if (!currentUser) throw new Error('User not authenticated');\n        try {\n            const defaultStatuses = [\n                {\n                    name: 'To Do',\n                    color: '#3B82F6',\n                    order: 0,\n                    showStrikeThrough: false,\n                    hidden: false,\n                    requiresComment: false,\n                    allowsComment: false\n                },\n                {\n                    name: 'In Progress',\n                    color: '#EAB308',\n                    order: 1,\n                    showStrikeThrough: false,\n                    hidden: false,\n                    requiresComment: false,\n                    allowsComment: true\n                },\n                {\n                    name: 'Done',\n                    color: '#22C55E',\n                    order: 3,\n                    showStrikeThrough: true,\n                    hidden: false,\n                    requiresComment: false,\n                    allowsComment: false\n                },\n                {\n                    name: 'Remove',\n                    color: '#EF4444',\n                    order: 2,\n                    showStrikeThrough: false,\n                    hidden: false,\n                    requiresComment: true,\n                    allowsComment: true\n                }\n            ];\n            // Optimistically add statuses to local state with temporary IDs\n            const tempStatuses = defaultStatuses.map((s, index)=>({\n                    ...s,\n                    id: \"temp-\".concat(Date.now(), \"-\").concat(index) // temporary ID\n                }));\n            setProjects((prev)=>{\n                const updateProject = (projects)=>{\n                    return projects.map((p)=>{\n                        if (p.id === projectId) {\n                            return {\n                                ...p,\n                                taskStatusOptions: [\n                                    ...p.taskStatusOptions || [],\n                                    ...tempStatuses\n                                ]\n                            };\n                        }\n                        if (p.subProjects) {\n                            return {\n                                ...p,\n                                subProjects: updateProject(p.subProjects)\n                            };\n                        }\n                        return p;\n                    });\n                };\n                return updateProject(prev);\n            });\n            // Create statuses via API and collect real IDs\n            const createdStatuses = [];\n            for (const s of defaultStatuses){\n                const created = await (0,_lib_api__WEBPACK_IMPORTED_MODULE_2__.createProjectStatus)(projectId, {\n                    label: s.name,\n                    color: s.color,\n                    order: s.order,\n                    showStrikeThrough: s.showStrikeThrough,\n                    hidden: s.hidden\n                });\n                createdStatuses.push(created);\n            }\n            // Replace temporary statuses with real ones\n            setProjects((prev)=>{\n                const updateProject = (projects)=>{\n                    return projects.map((p)=>{\n                        if (p.id === projectId) {\n                            var _p_taskStatusOptions;\n                            return {\n                                ...p,\n                                taskStatusOptions: [\n                                    ...((_p_taskStatusOptions = p.taskStatusOptions) === null || _p_taskStatusOptions === void 0 ? void 0 : _p_taskStatusOptions.filter((s)=>!s.id.startsWith('temp-'))) || [],\n                                    ...createdStatuses\n                                ]\n                            };\n                        }\n                        if (p.subProjects) {\n                            return {\n                                ...p,\n                                subProjects: updateProject(p.subProjects)\n                            };\n                        }\n                        return p;\n                    });\n                };\n                return updateProject(prev);\n            });\n        } catch (error) {\n            logger.error('Error adding default task statuses', {\n                userId: currentUser.id,\n                projectId,\n                action: 'addDefaultTaskStatuses'\n            }, error);\n            // Revert optimistic update on error\n            await fetchData(currentUser.id);\n            throw error;\n        }\n    };\n    const login = async (email, password)=>{\n        try {\n            const resp = await (0,_lib_api__WEBPACK_IMPORTED_MODULE_2__.authLogin)(email, password);\n            // Check if it's an expected error response\n            if (resp && 'success' in resp && resp.success === false && resp.isExpected) {\n                logger.debug('Login failed - invalid credentials', {\n                    email,\n                    action: 'login',\n                    errorType: 'authentication_failed'\n                });\n                return {\n                    success: false,\n                    error: resp.error\n                };\n            }\n            const user = resp === null || resp === void 0 ? void 0 : resp.user;\n            if (user) {\n                setCurrentUser(user);\n                await fetchData(user.id);\n                logger.info('User login successful', {\n                    userId: user.id,\n                    email,\n                    action: 'login'\n                });\n                return {\n                    success: true\n                };\n            }\n            return {\n                success: false,\n                error: 'Login failed'\n            };\n        } catch (error) {\n            var _error_body;\n            // For auth errors, log them differently to avoid scary console messages\n            if ((error === null || error === void 0 ? void 0 : error.status) === 401 || (error === null || error === void 0 ? void 0 : error.status) === 400 || (error === null || error === void 0 ? void 0 : error.isExpected)) {\n                logger.debug('Login failed - invalid credentials', {\n                    email,\n                    action: 'login',\n                    errorType: 'authentication_failed'\n                });\n            } else {\n                var _error_body1;\n                logger.error('Login error', {\n                    email,\n                    action: 'login',\n                    errorType: (error === null || error === void 0 ? void 0 : (_error_body1 = error.body) === null || _error_body1 === void 0 ? void 0 : _error_body1.error) || (error === null || error === void 0 ? void 0 : error.message) || 'unknown',\n                    status: error === null || error === void 0 ? void 0 : error.status\n                }, error);\n            }\n            const errorMessage = (error === null || error === void 0 ? void 0 : (_error_body = error.body) === null || _error_body === void 0 ? void 0 : _error_body.error) || (error === null || error === void 0 ? void 0 : error.message) || 'Login failed';\n            return {\n                success: false,\n                error: errorMessage\n            };\n        }\n    };\n    const logout = async ()=>{\n        try {\n            await (0,_lib_api__WEBPACK_IMPORTED_MODULE_2__.authLogout)();\n            clearState();\n            (0,_lib_cached_api__WEBPACK_IMPORTED_MODULE_6__.clearAllCaches)(); // Clear all cached data on logout\n            router.push('/login');\n        } catch (error) {\n            // For logout errors, only log if they're unexpected (not auth failures)\n            if ((error === null || error === void 0 ? void 0 : error.status) !== 401 && !(error === null || error === void 0 ? void 0 : error.isExpected)) {\n                logger.error('Logout error', {\n                    userId: currentUser === null || currentUser === void 0 ? void 0 : currentUser.id,\n                    action: 'logout'\n                }, error);\n            }\n        }\n    };\n    const addProject = async (project)=>{\n        if (!currentUser) throw new Error(\"User not authenticated\");\n        try {\n            const { parentProjectId, ...restOfProject } = project;\n            // default owner membership handled by backend\n            const payload = {\n                ...restOfProject\n            };\n            if (parentProjectId) payload.parentProjectId = parentProjectId;\n            const newProject = await (0,_lib_api__WEBPACK_IMPORTED_MODULE_2__.createProject)(payload);\n            // Invalidate all project caches\n            (0,_lib_cached_api__WEBPACK_IMPORTED_MODULE_6__.invalidateAllProjectCaches)();\n            // Instead of optimistic updates that may have wrong membership data,\n            // refresh the projects list to get accurate access permissions\n            await refreshProjects();\n            return newProject;\n        } catch (error) {\n            console.error(\"Error adding project: \", error);\n            throw error;\n        }\n    };\n    const updateProject = async (projectId, projectData)=>{\n        if (!currentUser) throw new Error(\"User not authenticated\");\n        try {\n            // Optimistically update project in local state\n            setProjects((prev)=>{\n                const updateProject = (projects)=>{\n                    return projects.map((p)=>{\n                        if (p.id === projectId) {\n                            const updated = {\n                                ...p,\n                                ...projectData\n                            };\n                            // Update cache optimistically\n                            (0,_lib_cached_api__WEBPACK_IMPORTED_MODULE_6__.optimisticUpdateProject)(updated);\n                            return updated;\n                        }\n                        if (p.subProjects) {\n                            return {\n                                ...p,\n                                subProjects: updateProject(p.subProjects)\n                            };\n                        }\n                        return p;\n                    });\n                };\n                return updateProject(prev);\n            });\n            await (0,_lib_api__WEBPACK_IMPORTED_MODULE_2__.updateProjectApi)(projectId, projectData);\n            // Invalidate project caches\n            (0,_lib_cached_api__WEBPACK_IMPORTED_MODULE_6__.invalidateProjectCaches)(projectId);\n        } catch (error) {\n            console.error(\"Error updating project(s): \", error);\n            // Revert optimistic update on error\n            if (currentUser === null || currentUser === void 0 ? void 0 : currentUser.id) await fetchData(currentUser.id);\n            throw error;\n        }\n    };\n    const getProject = async (projectId)=>{\n        try {\n            const resp = await (0,_lib_api__WEBPACK_IMPORTED_MODULE_2__.getProject)(projectId);\n            const proj = resp ? normalizeProject(resp) : null;\n            if (proj) {\n                // upsert into local projects state so UI components using `projects` get the normalized project\n                setProjects((prev)=>{\n                    // try to replace existing project in nested tree\n                    const replace = (arr)=>{\n                        return arr.map((p)=>{\n                            if (p.id === proj.id) return {\n                                ...proj,\n                                subProjects: p.subProjects || []\n                            };\n                            if (p.subProjects) return {\n                                ...p,\n                                subProjects: replace(p.subProjects)\n                            };\n                            return p;\n                        });\n                    };\n                    // if project exists somewhere, replace it\n                    const exists = function find(arr) {\n                        for (const p of arr){\n                            if (p.id === proj.id) return true;\n                            if (p.subProjects && find(p.subProjects)) return true;\n                        }\n                        return false;\n                    }(prev);\n                    if (exists) return replace(prev);\n                    // otherwise append at root\n                    return [\n                        ...prev,\n                        {\n                            ...proj,\n                            subProjects: proj.subProjects || []\n                        }\n                    ];\n                });\n            }\n            return proj;\n        } catch (error) {\n            console.error(\"Error getting project: \", error);\n            return null;\n        }\n    };\n    const duplicateProject = async (projectId)=>{\n        if (!currentUser) throw new Error(\"User not authenticated\");\n        try {\n            const idMap = new Map();\n            const findProjectInState = (projs, pId)=>{\n                for (const p of projs){\n                    if (p.id === pId) return p;\n                    if (p.subProjects) {\n                        const found = findProjectInState(p.subProjects, pId);\n                        if (found) return found;\n                    }\n                }\n                return null;\n            };\n            const getProjectsToDuplicate = (project)=>{\n                let list = [\n                    project\n                ];\n                if (project.subProjects) {\n                    project.subProjects.forEach((sub)=>{\n                        list = list.concat(getProjectsToDuplicate(sub));\n                    });\n                }\n                return list;\n            };\n            const rootProjectToDuplicate = findProjectInState(projects, projectId);\n            if (!rootProjectToDuplicate) throw new Error(\"Project to duplicate not found.\");\n            const allProjectsToDuplicate = getProjectsToDuplicate(rootProjectToDuplicate);\n            const oldProjectIds = allProjectsToDuplicate.map((p)=>p.id);\n            // duplication is complex; fall back to creating copies via backend where possible\n            for (const p of allProjectsToDuplicate){\n                const { id, subProjects, members, ...projectData } = p;\n                const payload = {\n                    ...projectData,\n                    name: \"\".concat(p.name, \" (Copy)\")\n                };\n                // backend should create new project and handle parent linkage\n                await (0,_lib_api__WEBPACK_IMPORTED_MODULE_2__.createProject)(payload);\n            }\n            if (oldProjectIds.length > 0) {\n                // duplicate tasks via backend: fetch and recreate\n                // fetch tasks for each oldProjectId and create new ones\n                for (const oldId of oldProjectIds){\n                    const tasks = await (0,_lib_api__WEBPACK_IMPORTED_MODULE_2__.getTasksByProjectIds)([\n                        oldId\n                    ]);\n                    for (const t of tasks){\n                        const newProjectId = idMap.get(t.projectId);\n                        if (newProjectId) {\n                            const { id: tid, ...taskData } = t;\n                            await (0,_lib_api__WEBPACK_IMPORTED_MODULE_2__.createTaskApi)({\n                                ...taskData,\n                                projectId: newProjectId\n                            });\n                        }\n                    }\n                }\n            }\n            await refreshProjects();\n        } catch (error) {\n            console.error(\"Error duplicating project:\", error);\n            await refreshProjects();\n            throw error;\n        }\n    };\n    const deleteProject = async (projectId, pathname)=>{\n        if (!currentUser) throw new Error(\"User not authenticated\");\n        try {\n            const getProjectIdsFromState = (allProjects, startId)=>{\n                let ids = [];\n                const findAndCollect = (projs, pId)=>{\n                    for (const p of projs){\n                        if (p.id === pId) {\n                            const collect = (proj)=>{\n                                ids.push(proj.id);\n                                if (proj.subProjects) {\n                                    proj.subProjects.forEach(collect);\n                                }\n                            };\n                            collect(p);\n                            return true;\n                        }\n                        if (p.subProjects) {\n                            if (findAndCollect(p.subProjects, pId)) return true;\n                        }\n                    }\n                    return false;\n                };\n                findAndCollect(allProjects, startId);\n                return ids;\n            };\n            const allProjectIdsToDelete = getProjectIdsFromState(projects, projectId);\n            // Optimistically remove projects from local state\n            setProjects((prev)=>{\n                const removeProject = (projects, targetId)=>{\n                    return projects.filter((p)=>{\n                        if (p.id === targetId) return false;\n                        if (p.subProjects) {\n                            p.subProjects = removeProject(p.subProjects, targetId);\n                        }\n                        return true;\n                    });\n                };\n                let updatedProjects = prev;\n                for (const pId of allProjectIdsToDelete){\n                    updatedProjects = removeProject(updatedProjects, pId);\n                }\n                return updatedProjects;\n            });\n            // Also optimistically remove related tasks\n            setTasks((prev)=>prev.filter((task)=>!allProjectIdsToDelete.includes(task.projectId)));\n            // delete projects via backend\n            for (const pId of allProjectIdsToDelete){\n                await (0,_lib_api__WEBPACK_IMPORTED_MODULE_2__.deleteProjectApi)(pId);\n            }\n            const remainingProjectIds = new Set(allProjectIdsToDelete);\n            const isViewingDeletedProject = [\n                ...remainingProjectIds\n            ].some((id)=>pathname.includes(id));\n            if (isViewingDeletedProject) {\n                router.push('/dashboard');\n            }\n        } catch (error) {\n            console.error(\"FINAL DELETION ERROR:\", error);\n            // Revert optimistic update on error\n            if (currentUser.id) {\n                await fetchData(currentUser.id);\n            }\n            throw error;\n        }\n    };\n    // Project Member Management\n    const addProjectMemberFunc = async (projectId, userId, role)=>{\n        if (!currentUser) throw new Error(\"User not authenticated\");\n        try {\n            // Optimistically add member to local state\n            setProjects((prev)=>{\n                const updateProject = (projects)=>{\n                    return projects.map((p)=>{\n                        if (p.id === projectId) {\n                            return {\n                                ...p,\n                                members: {\n                                    ...p.members || {},\n                                    [userId]: role\n                                }\n                            };\n                        }\n                        if (p.subProjects) {\n                            return {\n                                ...p,\n                                subProjects: updateProject(p.subProjects)\n                            };\n                        }\n                        return p;\n                    });\n                };\n                return updateProject(prev);\n            });\n            await (0,_lib_api__WEBPACK_IMPORTED_MODULE_2__.addProjectMember)(projectId, userId, role);\n        } catch (error) {\n            console.error(\"Error adding project member:\", error);\n            // Revert optimistic update on error\n            await fetchData(currentUser.id);\n            throw error;\n        }\n    };\n    const updateProjectMemberRoleFunc = async (projectId, userId, role)=>{\n        if (!currentUser) throw new Error(\"User not authenticated\");\n        try {\n            // Optimistically update member role in local state\n            setProjects((prev)=>{\n                const updateProject = (projects)=>{\n                    return projects.map((p)=>{\n                        if (p.id === projectId && p.members) {\n                            return {\n                                ...p,\n                                members: {\n                                    ...p.members,\n                                    [userId]: role\n                                }\n                            };\n                        }\n                        if (p.subProjects) {\n                            return {\n                                ...p,\n                                subProjects: updateProject(p.subProjects)\n                            };\n                        }\n                        return p;\n                    });\n                };\n                return updateProject(prev);\n            });\n            await (0,_lib_api__WEBPACK_IMPORTED_MODULE_2__.updateProjectMemberRole)(projectId, userId, role);\n        } catch (error) {\n            console.error(\"Error updating project member role:\", error);\n            // Revert optimistic update on error\n            await fetchData(currentUser.id);\n            throw error;\n        }\n    };\n    const removeProjectMemberFunc = async (projectId, userId)=>{\n        if (!currentUser) throw new Error(\"User not authenticated\");\n        try {\n            // Optimistically remove member from local state\n            setProjects((prev)=>{\n                const updateProject = (projects)=>{\n                    return projects.map((p)=>{\n                        if (p.id === projectId && p.members) {\n                            const newMembers = {\n                                ...p.members\n                            };\n                            delete newMembers[userId];\n                            return {\n                                ...p,\n                                members: newMembers\n                            };\n                        }\n                        if (p.subProjects) {\n                            return {\n                                ...p,\n                                subProjects: updateProject(p.subProjects)\n                            };\n                        }\n                        return p;\n                    });\n                };\n                return updateProject(prev);\n            });\n            await (0,_lib_api__WEBPACK_IMPORTED_MODULE_2__.removeProjectMember)(projectId, userId);\n        } catch (error) {\n            console.error(\"Error removing project member:\", error);\n            // Revert optimistic update on error\n            await fetchData(currentUser.id);\n            throw error;\n        }\n    };\n    const addTask = async (task)=>{\n        if (!currentUser) throw new Error(\"User not authenticated\");\n        try {\n            const body = {\n                ...task\n            };\n            // Convert status field to statusId for API compatibility\n            if (body.status) {\n                body.statusId = body.status;\n                delete body.status;\n            }\n            // remove undefined, null, and empty-string values to avoid sending invalid FK references\n            Object.keys(body).forEach((k)=>{\n                if (body[k] === undefined || body[k] === null || typeof body[k] === 'string' && body[k].trim() === '') {\n                    delete body[k];\n                }\n            });\n            // Call API to create task\n            const newTask = await (0,_lib_api__WEBPACK_IMPORTED_MODULE_2__.createTaskApi)(body);\n            // Invalidate task caches for affected projects\n            if (newTask && newTask.projectId) {\n                (0,_lib_cached_api__WEBPACK_IMPORTED_MODULE_6__.invalidateTaskCaches)(newTask);\n            }\n            // Optimistically add the task to local state (SSE will also broadcast, but we have duplicate protection)\n            if (newTask) {\n                var _newTask_status, _ref, _newTask_assigneeId, _newTask_parentId;\n                const normalizedTask = {\n                    ...newTask,\n                    status: (_ref = (_newTask_status = newTask.status) !== null && _newTask_status !== void 0 ? _newTask_status : newTask.statusId) !== null && _ref !== void 0 ? _ref : null,\n                    assigneeId: (_newTask_assigneeId = newTask.assigneeId) !== null && _newTask_assigneeId !== void 0 ? _newTask_assigneeId : undefined,\n                    parentId: (_newTask_parentId = newTask.parentId) !== null && _newTask_parentId !== void 0 ? _newTask_parentId : undefined\n                };\n                setTasks((prev)=>{\n                    // Extra safety check to prevent duplicates\n                    if (prev.find((t)=>t.id === normalizedTask.id)) {\n                        return prev;\n                    }\n                    return [\n                        ...prev,\n                        normalizedTask\n                    ];\n                });\n                return normalizedTask;\n            }\n            throw new Error('Failed to create task');\n        } catch (error) {\n            console.error(\"Error adding task: \", error);\n            throw error;\n        }\n    };\n    const updateTask = async (updatedTask)=>{\n        if (!currentUser) throw new Error(\"User not authenticated\");\n        try {\n            const { id, ...taskData } = updatedTask;\n            const body = {\n                ...taskData\n            };\n            // remove undefined fields\n            Object.keys(body).forEach((k)=>body[k] === undefined && delete body[k]);\n            // strip server-only timestamp fields if present\n            delete body.createdAt;\n            delete body.updatedAt;\n            // Normalize status: ensure we send only `statusId` (backend accepts either but prefers statusId when both present).\n            // If the caller provided `status` (new id), use it; otherwise keep any explicit statusId.\n            if (body.status !== undefined) {\n                body.statusId = body.status;\n            }\n            // remove client-side `status` field to avoid sending both\n            delete body.status;\n            var _body_statusId, _ref;\n            // optimistic update: merge the requested changes into local state so UI updates immediately\n            const optimistic = {\n                ...updatedTask,\n                // ensure we reflect the requested statusId/status shape\n                status: (_ref = (_body_statusId = body.statusId) !== null && _body_statusId !== void 0 ? _body_statusId : updatedTask.status) !== null && _ref !== void 0 ? _ref : null,\n                assigneeId: body.assigneeId !== undefined ? body.assigneeId : updatedTask.assigneeId,\n                parentId: body.parentId !== undefined ? body.parentId : updatedTask.parentId\n            };\n            // Update local state\n            setTasks((prev)=>prev.map((t)=>t.id === id ? optimistic : t));\n            // Update cache optimistically\n            (0,_lib_cached_api__WEBPACK_IMPORTED_MODULE_6__.optimisticUpdateTask)(optimistic);\n            // call API and reconcile response\n            const resp = await (0,_lib_api__WEBPACK_IMPORTED_MODULE_2__.updateTaskApi)(id, body);\n            // Invalidate task caches for affected projects\n            (0,_lib_cached_api__WEBPACK_IMPORTED_MODULE_6__.invalidateTaskCaches)(optimistic);\n            var _resp_status, _ref1, _resp_assigneeId, _resp_parentId;\n            // normalize response to frontend shape (match fetchTasksForChunks normalization)\n            const normalized = {\n                ...resp,\n                status: (_ref1 = (_resp_status = resp.status) !== null && _resp_status !== void 0 ? _resp_status : resp.statusId) !== null && _ref1 !== void 0 ? _ref1 : null,\n                assigneeId: (_resp_assigneeId = resp.assigneeId) !== null && _resp_assigneeId !== void 0 ? _resp_assigneeId : undefined,\n                parentId: (_resp_parentId = resp.parentId) !== null && _resp_parentId !== void 0 ? _resp_parentId : undefined\n            };\n            // reconcile authoritative server response\n            setTasks((prev)=>prev.map((t)=>t.id === normalized.id ? normalized : t));\n        } catch (error) {\n            console.error(\"Error updating task: \", error);\n            // Invalidate cache to force refresh on error\n            if (updatedTask.projectId) {\n                (0,_lib_cached_api__WEBPACK_IMPORTED_MODULE_6__.invalidateTaskCaches)(updatedTask);\n            }\n        }\n    };\n    // Fast update for drag operations - only updates UI, debounces API calls\n    const updateTaskImmediate = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"AppProvider.useCallback[updateTaskImmediate]\": (updatedTask)=>{\n            if (!currentUser) return;\n            // Update UI immediately\n            setTasks({\n                \"AppProvider.useCallback[updateTaskImmediate]\": (prev)=>prev.map({\n                        \"AppProvider.useCallback[updateTaskImmediate]\": (t)=>t.id === updatedTask.id ? updatedTask : t\n                    }[\"AppProvider.useCallback[updateTaskImmediate]\"])\n            }[\"AppProvider.useCallback[updateTaskImmediate]\"]);\n            // Store the pending update\n            pendingTaskUpdates.current.set(updatedTask.id, updatedTask);\n            // Clear existing timeout for this task\n            const existingTimeout = updateTaskTimeouts.current.get(updatedTask.id);\n            if (existingTimeout) {\n                clearTimeout(existingTimeout);\n            }\n            // Set new debounced API call\n            const timeout = setTimeout({\n                \"AppProvider.useCallback[updateTaskImmediate].timeout\": async ()=>{\n                    const taskToUpdate = pendingTaskUpdates.current.get(updatedTask.id);\n                    if (taskToUpdate) {\n                        try {\n                            const { id, ...taskData } = taskToUpdate;\n                            const body = {\n                                ...taskData\n                            };\n                            Object.keys(body).forEach({\n                                \"AppProvider.useCallback[updateTaskImmediate].timeout\": (k)=>body[k] === undefined && delete body[k]\n                            }[\"AppProvider.useCallback[updateTaskImmediate].timeout\"]);\n                            delete body.createdAt;\n                            delete body.updatedAt;\n                            if (body.status !== undefined) {\n                                body.statusId = body.status;\n                            }\n                            delete body.status;\n                            await (0,_lib_api__WEBPACK_IMPORTED_MODULE_2__.updateTaskApi)(id, body);\n                            // Clean up\n                            pendingTaskUpdates.current.delete(updatedTask.id);\n                            updateTaskTimeouts.current.delete(updatedTask.id);\n                        } catch (error) {\n                            console.error(\"Error in debounced task update:\", error);\n                            // Revert to server state on error\n                            if (currentUser === null || currentUser === void 0 ? void 0 : currentUser.id) await fetchData(currentUser.id);\n                        }\n                    }\n                }\n            }[\"AppProvider.useCallback[updateTaskImmediate].timeout\"], 500); // 500ms debounce\n            updateTaskTimeouts.current.set(updatedTask.id, timeout);\n        }\n    }[\"AppProvider.useCallback[updateTaskImmediate]\"], [\n        currentUser\n    ]);\n    const deleteTask = async (taskId)=>{\n        if (!currentUser) throw new Error(\"User not authenticated\");\n        try {\n            // Optimistically remove the task from local state\n            setTasks((prev)=>prev.filter((t)=>t.id !== taskId));\n            // Call API to delete task\n            await (0,_lib_api__WEBPACK_IMPORTED_MODULE_2__.deleteTaskApi)(taskId);\n        } catch (error) {\n            console.error(\"Error deleting task: \", error);\n            // Revert the optimistic update by refetching on error\n            if (currentUser === null || currentUser === void 0 ? void 0 : currentUser.id) await fetchData(currentUser.id);\n            throw error;\n        }\n    };\n    const updateUser = async (userId, userData)=>{\n        if (!currentUser) throw new Error(\"User not authenticated\");\n        try {\n            const resp = await (0,_lib_api__WEBPACK_IMPORTED_MODULE_2__.updateUserApi)(userId, {\n                name: userData.name,\n                email: userData.email\n            });\n            const updated = (resp === null || resp === void 0 ? void 0 : resp.user) || {\n                id: userId,\n                ...userData\n            };\n            setUsers((prevUsers)=>{\n                const newUsers = new Map(prevUsers);\n                if (newUsers.has(userId)) {\n                    const existingUser = newUsers.get(userId);\n                    newUsers.set(userId, {\n                        ...existingUser,\n                        ...updated\n                    });\n                }\n                return newUsers;\n            });\n            if (currentUser.id === userId) {\n                setCurrentUser((prev)=>prev ? {\n                        ...prev,\n                        ...updated\n                    } : null);\n            }\n        } catch (error) {\n            console.error(\"Error updating user:\", error);\n            throw error;\n        }\n    };\n    const createUser = async (user, password)=>{\n        const resp = await (0,_lib_api__WEBPACK_IMPORTED_MODULE_2__.authSignup)(user.name, user.email, password);\n        // Check if it's an expected error response\n        if (resp && 'success' in resp && resp.success === false && resp.isExpected) {\n            logger.debug('Signup failed - user input error', {\n                email: user.email,\n                action: 'signup',\n                errorType: 'user_input_error'\n            });\n            // Create a plain error object without throwing to avoid console logging\n            const error = {\n                message: resp.error,\n                status: resp.status,\n                isExpected: true\n            };\n            throw error;\n        }\n        const created = resp === null || resp === void 0 ? void 0 : resp.user;\n        if (created) {\n            // Optionally update local users list\n            setUsers((prev)=>{\n                const newUsers = new Map(prev);\n                newUsers.set(created.id, created);\n                return newUsers;\n            });\n            setCurrentUser(created);\n            await fetchData(created.id);\n        }\n    };\n    const addProjectTaskStatus = async (projectId, status)=>{\n        if (!currentUser) throw new Error('User not authenticated');\n        try {\n            // Generate a temporary ID for optimistic update\n            const tempId = \"temp-\".concat(Date.now());\n            const existingStatuses = (()=>{\n                const project = projects.find((p)=>p.id === projectId);\n                return (project === null || project === void 0 ? void 0 : project.taskStatusOptions) || [];\n            })();\n            const newOrder = existingStatuses.length;\n            // Create optimistic status object\n            const optimisticStatus = {\n                id: tempId,\n                name: status.name || status.label || 'Status',\n                color: status.color || '#3B82F6',\n                order: newOrder,\n                showStrikeThrough: status.showStrikeThrough || false,\n                hidden: status.hidden || false,\n                requiresComment: status.requiresComment || false,\n                allowsComment: status.allowsComment !== false\n            };\n            // Optimistically add the status to local state\n            setProjects((prev)=>{\n                const updateProject = (projects)=>{\n                    return projects.map((p)=>{\n                        if (p.id === projectId) {\n                            return {\n                                ...p,\n                                taskStatusOptions: [\n                                    ...p.taskStatusOptions || [],\n                                    optimisticStatus\n                                ]\n                            };\n                        }\n                        if (p.subProjects) {\n                            return {\n                                ...p,\n                                subProjects: updateProject(p.subProjects)\n                            };\n                        }\n                        return p;\n                    });\n                };\n                return updateProject(prev);\n            });\n            // Call API to create status\n            const createdStatus = await (0,_lib_api__WEBPACK_IMPORTED_MODULE_2__.createProjectStatus)(projectId, {\n                label: optimisticStatus.name,\n                color: optimisticStatus.color,\n                order: newOrder,\n                showStrikeThrough: optimisticStatus.showStrikeThrough,\n                hidden: optimisticStatus.hidden,\n                requiresComment: optimisticStatus.requiresComment,\n                allowsComment: optimisticStatus.allowsComment\n            });\n            // Replace temp status with real one\n            setProjects((prev)=>{\n                const updateProject = (projects)=>{\n                    return projects.map((p)=>{\n                        if (p.id === projectId && p.taskStatusOptions) {\n                            return {\n                                ...p,\n                                taskStatusOptions: p.taskStatusOptions.map((s)=>s.id === tempId ? {\n                                        ...createdStatus,\n                                        name: createdStatus.label || createdStatus.name\n                                    } : s)\n                            };\n                        }\n                        if (p.subProjects) {\n                            return {\n                                ...p,\n                                subProjects: updateProject(p.subProjects)\n                            };\n                        }\n                        return p;\n                    });\n                };\n                return updateProject(prev);\n            });\n        } catch (error) {\n            console.error('Error adding project task status:', error);\n            // Revert optimistic update on error\n            if (currentUser === null || currentUser === void 0 ? void 0 : currentUser.id) await fetchData(currentUser.id);\n            throw error;\n        }\n    };\n    const updateProjectTaskStatus = async (projectId, statusId, statusData)=>{\n        if (!currentUser) throw new Error('User not authenticated');\n        try {\n            // Optimistically update the project status in local state\n            setProjects((prev)=>{\n                const updateProject = (projects)=>{\n                    return projects.map((p)=>{\n                        if (p.id === projectId && p.taskStatusOptions) {\n                            return {\n                                ...p,\n                                taskStatusOptions: p.taskStatusOptions.map((s)=>s.id === statusId ? {\n                                        ...s,\n                                        ...statusData\n                                    } : s)\n                            };\n                        }\n                        if (p.subProjects) {\n                            return {\n                                ...p,\n                                subProjects: updateProject(p.subProjects)\n                            };\n                        }\n                        return p;\n                    });\n                };\n                return updateProject(prev);\n            });\n            // Call API to update status\n            await (0,_lib_api__WEBPACK_IMPORTED_MODULE_2__.updateProjectStatus)(projectId, statusId, {\n                label: statusData.name || statusData.label,\n                order: statusData.order,\n                color: statusData.color,\n                showStrikeThrough: statusData.showStrikeThrough,\n                hidden: statusData.hidden,\n                requiresComment: statusData.requiresComment,\n                allowsComment: statusData.allowsComment\n            });\n        } catch (error) {\n            console.error('Error updating project task status:', error);\n            // Revert optimistic update on error\n            if (currentUser === null || currentUser === void 0 ? void 0 : currentUser.id) await fetchData(currentUser.id);\n            throw error;\n        }\n    };\n    const deleteProjectTaskStatus = async (projectId, statusId)=>{\n        if (!currentUser) throw new Error('User not authenticated');\n        try {\n            // Optimistically remove the status from local state\n            setProjects((prev)=>{\n                const updateProject = (projects)=>{\n                    return projects.map((p)=>{\n                        if (p.id === projectId && p.taskStatusOptions) {\n                            return {\n                                ...p,\n                                taskStatusOptions: p.taskStatusOptions.filter((s)=>s.id !== statusId)\n                            };\n                        }\n                        if (p.subProjects) {\n                            return {\n                                ...p,\n                                subProjects: updateProject(p.subProjects)\n                            };\n                        }\n                        return p;\n                    });\n                };\n                return updateProject(prev);\n            });\n            // Call API to delete status\n            await (0,_lib_api__WEBPACK_IMPORTED_MODULE_2__.deleteProjectStatus)(projectId, statusId);\n        } catch (error) {\n            console.error('Error deleting project task status:', error);\n            // Revert optimistic update on error\n            if (currentUser === null || currentUser === void 0 ? void 0 : currentUser.id) await fetchData(currentUser.id);\n            throw error;\n        }\n    };\n    const updateProjectTaskStatusOrder = async (projectId, statuses)=>{\n        if (!currentUser) throw new Error('User not authenticated');\n        try {\n            // Optimistically update the order in local state\n            setProjects((prev)=>{\n                const updateProject = (projects)=>{\n                    return projects.map((p)=>{\n                        if (p.id === projectId && p.taskStatusOptions) {\n                            // Create a map for quick lookup of new orders\n                            const orderMap = new Map(statuses.map((s)=>[\n                                    s.id,\n                                    s.order\n                                ]));\n                            return {\n                                ...p,\n                                taskStatusOptions: p.taskStatusOptions.map((s)=>{\n                                    var _orderMap_get;\n                                    return {\n                                        ...s,\n                                        order: (_orderMap_get = orderMap.get(s.id)) !== null && _orderMap_get !== void 0 ? _orderMap_get : s.order\n                                    };\n                                }).sort((a, b)=>a.order - b.order)\n                            };\n                        }\n                        if (p.subProjects) {\n                            return {\n                                ...p,\n                                subProjects: updateProject(p.subProjects)\n                            };\n                        }\n                        return p;\n                    });\n                };\n                return updateProject(prev);\n            });\n            // Call API to update order\n            const payload = statuses.map((s)=>({\n                    id: s.id,\n                    order: s.order\n                }));\n            await (0,_lib_api__WEBPACK_IMPORTED_MODULE_2__.updateProjectStatusesOrder)(projectId, payload);\n        } catch (error) {\n            console.error('Error updating project task status order:', error);\n            // Revert optimistic update on error\n            if (currentUser === null || currentUser === void 0 ? void 0 : currentUser.id) await fetchData(currentUser.id);\n            throw error;\n        }\n    };\n    const changePassword = async (currentPassword, newPassword)=>{\n        try {\n            await (0,_lib_api__WEBPACK_IMPORTED_MODULE_2__.authChangePassword)(currentPassword, newPassword);\n        } catch (error) {\n            console.error('Error changing password:', error);\n            throw error;\n        }\n    };\n    const findUserByEmail = async (email)=>{\n        // Prefer searching cached users; fall back to API fetch\n        const found = Array.from(users.values()).find((u)=>u.email === email);\n        if (found) return found;\n        try {\n            const all = await (0,_lib_api__WEBPACK_IMPORTED_MODULE_2__.getUsers)();\n            const arr = all || [];\n            const match = arr.find((u)=>u.email === email) || null;\n            return match;\n        } catch (err) {\n            console.error('Error finding user by email via backend:', err);\n            return null;\n        }\n    };\n    const findUserByEmailOrName = async (query)=>{\n        // Prefer searching cached users; fall back to API fetch\n        const found = Array.from(users.values()).find((u)=>u.email === query || u.name === query);\n        if (found) return found;\n        try {\n            const all = await (0,_lib_api__WEBPACK_IMPORTED_MODULE_2__.getUsers)();\n            const arr = all || [];\n            const match = arr.find((u)=>u.email === query || u.name === query) || null;\n            return match;\n        } catch (err) {\n            console.error('Error finding user by email or name via backend:', err);\n            return null;\n        }\n    };\n    const contextValue = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"AppProvider.useMemo[contextValue]\": ()=>({\n                users,\n                projects,\n                tasks,\n                loading,\n                currentUser,\n                login,\n                logout,\n                addProject,\n                updateProject,\n                getProject,\n                duplicateProject,\n                addProjectMember: addProjectMemberFunc,\n                updateProjectMemberRole: updateProjectMemberRoleFunc,\n                removeProjectMember: removeProjectMemberFunc,\n                addTask,\n                updateTask,\n                updateTaskImmediate,\n                deleteTask,\n                updateUser,\n                createUser,\n                changePassword,\n                findUserByEmail,\n                findUserByEmailOrName,\n                deleteProject,\n                isKanbanHeaderVisible,\n                toggleKanbanHeader,\n                isSidebarOpenByDefault,\n                toggleSidebarDefault,\n                cardDensity,\n                setCardDensity,\n                defaultView,\n                setDefaultView,\n                groupByStatus,\n                setGroupByStatus,\n                addProjectTaskStatus,\n                updateProjectTaskStatus,\n                deleteProjectTaskStatus,\n                updateProjectTaskStatusOrder,\n                addDefaultTaskStatuses\n            })\n    }[\"AppProvider.useMemo[contextValue]\"], [\n        users,\n        projects,\n        tasks,\n        loading,\n        currentUser,\n        login,\n        logout,\n        addProject,\n        updateProject,\n        getProject,\n        duplicateProject,\n        addProjectMemberFunc,\n        updateProjectMemberRoleFunc,\n        removeProjectMemberFunc,\n        addTask,\n        updateTask,\n        updateTaskImmediate,\n        deleteTask,\n        updateUser,\n        createUser,\n        changePassword,\n        findUserByEmail,\n        findUserByEmailOrName,\n        deleteProject,\n        isKanbanHeaderVisible,\n        toggleKanbanHeader,\n        isSidebarOpenByDefault,\n        toggleSidebarDefault,\n        cardDensity,\n        setCardDensity,\n        defaultView,\n        setDefaultView,\n        groupByStatus,\n        setGroupByStatus,\n        addProjectTaskStatus,\n        updateProjectTaskStatus,\n        deleteProjectTaskStatus,\n        updateProjectTaskStatusOrder,\n        addDefaultTaskStatuses\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(AppContext.Provider, {\n        value: contextValue,\n        children: children\n    }, void 0, false, {\n        fileName: \"/home/coder/OrchePlan/frontend/src/context/app-context.tsx\",\n        lineNumber: 1578,\n        columnNumber: 5\n    }, this);\n}\n_s(AppProvider, \"BOMbRYlxmXYFR7iR0InKEzi9lGc=\", false, function() {\n    return [\n        next_navigation__WEBPACK_IMPORTED_MODULE_3__.useRouter,\n        next_navigation__WEBPACK_IMPORTED_MODULE_3__.usePathname\n    ];\n});\n_c = AppProvider;\nfunction useApp() {\n    _s1();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(AppContext);\n    if (context === undefined) {\n        throw new Error('useApp must be used within an AppProvider');\n    }\n    return context;\n}\n_s1(useApp, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"AppProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb250ZXh0L2FwcC1jb250ZXh0LnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFFdUg7QUFDMlU7QUFFelk7QUFDWjtBQUNRO0FBYTNCO0FBNEMxQixNQUFNNkMsMkJBQWE1QyxvREFBYUEsQ0FBNkI2QztBQUU3RCxNQUFNQyxTQUFTYixrRUFBcUJBLENBQUM7QUFFOUIsU0FBU2MsWUFBWSxLQUFxQztRQUFyQyxFQUFFQyxRQUFRLEVBQTJCLEdBQXJDOztJQUMxQixNQUFNLENBQUNDLE9BQU9DLFNBQVMsR0FBR2hELCtDQUFRQSxDQUFvQixJQUFJaUQ7SUFDMUQsTUFBTSxDQUFDQyxVQUFVQyxZQUFZLEdBQUduRCwrQ0FBUUEsQ0FBWSxFQUFFO0lBQ3RELE1BQU0sQ0FBQ29ELE9BQU9DLFNBQVMsR0FBR3JELCtDQUFRQSxDQUFTLEVBQUU7SUFDN0MsTUFBTSxDQUFDc0QsYUFBYUMsZUFBZSxHQUFHdkQsK0NBQVFBLENBQWM7SUFDNUQsTUFBTSxDQUFDd0QsU0FBU0MsV0FBVyxHQUFHekQsK0NBQVFBLENBQUM7SUFDdkMsTUFBTSxDQUFDMEQsdUJBQXVCQyx5QkFBeUIsR0FBRzNELCtDQUFRQSxDQUFDO0lBQ25FLE1BQU0sQ0FBQzRELHdCQUF3QkMsMEJBQTBCLEdBQUc3RCwrQ0FBUUEsQ0FBQztJQUNuRSxNQUFNLENBQUM4RCxhQUFhQyxvQkFBb0IsR0FBRy9ELCtDQUFRQSxDQUE0QjtJQUMvRSxNQUFNLENBQUNnRSxhQUFhQyxvQkFBb0IsR0FBR2pFLCtDQUFRQSxDQUFtQjtJQUNsRSxNQUFNLENBQUNrRSxlQUFlQyxzQkFBc0IsR0FBR25FLCtDQUFRQSxDQUFVO0lBQ3ZFLE1BQU1vRSxTQUFTeEMsMERBQVNBO0lBQ3hCLE1BQU15QyxXQUFXeEMsNERBQVdBO0lBRTVCLDZDQUE2QztJQUM3QyxNQUFNeUMscUJBQXFCbkUsNkNBQU1BLENBQW9CLElBQUk4QztJQUN6RCxNQUFNc0IscUJBQXFCcEUsNkNBQU1BLENBQThCLElBQUk4QztJQUVuRSxrQ0FBa0M7SUFDbEMsTUFBTXVCLGlCQUFpQnJFLDZDQUFNQSxDQUF3QjtJQUNyRCxNQUFNLENBQUNzRSxxQkFBcUJDLHVCQUF1QixHQUFHMUUsK0NBQVFBLENBQUM7SUFFN0QscUVBQXFFO0lBQ3JFLE1BQU0yRSxtQkFBbUIsQ0FBQ0M7UUFDdEIsSUFBSSxDQUFDQSxHQUFHLE9BQU9BO1FBQ2YsTUFBTUMsb0JBQTJCQyxNQUFNQyxPQUFPLENBQUNILEVBQUVJLFFBQVEsSUFDbkRKLEVBQUVJLFFBQVEsQ0FBQ0MsR0FBRyxDQUFDLENBQUNDO1lBQ2QsTUFBTUMsUUFBUSxDQUFDRCxFQUFFQyxLQUFLLElBQUksRUFBQyxFQUFHQyxRQUFRO1lBQ3RDLGtEQUFrRDtZQUNsRCxNQUFNQyxXQUFXLENBQUM7Z0JBQ2QsTUFBTUMsTUFBTUgsTUFBTUksSUFBSSxHQUFHQyxXQUFXO2dCQUNwQyxJQUFJRixRQUFRLFdBQVdBLFFBQVEsVUFBVUEsUUFBUSxTQUFTLE9BQU87Z0JBQ2pFLElBQUlBLFFBQVEsaUJBQWlCQSxRQUFRLGVBQWUsT0FBTztnQkFDM0QsSUFBSUEsUUFBUSxRQUFRLE9BQU87Z0JBQzNCLElBQUlBLFFBQVEsWUFBWUEsUUFBUSxhQUFhQSxRQUFRLFdBQVcsT0FBTztnQkFDdkUsT0FBTztZQUNYO1lBQ0EsT0FBTztnQkFDSEcsSUFBSVAsRUFBRU8sRUFBRTtnQkFDUkMsTUFBTVIsRUFBRUMsS0FBSztnQkFDYlEsT0FBT1QsRUFBRVMsS0FBSyxJQUFJTjtnQkFDbEJPLE9BQU9WLEVBQUVVLEtBQUs7Z0JBQ2RDLG1CQUFtQlgsRUFBRVcsaUJBQWlCLElBQUk7Z0JBQzFDQyxRQUFRWixFQUFFWSxNQUFNLElBQUk7Z0JBQ3BCQyxpQkFBaUJiLEVBQUVhLGVBQWUsSUFBSTtnQkFDdENDLGVBQWVkLEVBQUVjLGFBQWEsSUFBSTtZQUN0QztRQUNKLEtBQ0UsRUFBRTtRQUVSLDJDQUEyQztRQUMzQyxJQUFJbEIsTUFBTUMsT0FBTyxDQUFDSCxFQUFFcUIsT0FBTyxHQUFHO1lBQzFCLE1BQU1oQixNQUEyQixDQUFDO1lBQ2xDTCxFQUFFcUIsT0FBTyxDQUFDQyxPQUFPLENBQUMsQ0FBQ0M7Z0JBQ2YsSUFBSUEsS0FBS0EsRUFBRUMsTUFBTSxJQUFJRCxFQUFFRSxJQUFJLEVBQUVwQixHQUFHLENBQUNrQixFQUFFQyxNQUFNLENBQUMsR0FBR0QsRUFBRUUsSUFBSTtZQUN2RDtZQUNBLE9BQU87Z0JBQUUsR0FBR3pCLENBQUM7Z0JBQUVxQixTQUFTaEI7Z0JBQUtKO1lBQWtCO1FBQ25EO1FBRUEsT0FBTztZQUFFLEdBQUdELENBQUM7WUFBRXFCLFNBQVNyQixFQUFFcUIsT0FBTyxJQUFJLENBQUM7WUFBR3BCO1FBQWtCO0lBQy9EO0lBRUY1RSxnREFBU0E7aUNBQUM7Z0JBQ1lxRztZQUFwQixNQUFNQyxlQUFjRCw4QkFBQUEsU0FBU0UsTUFBTSxDQUNoQ0MsS0FBSyxDQUFDLE1BQ05DLElBQUk7eUNBQUNDLENBQUFBLE1BQU9BLElBQUlDLFVBQVUsQ0FBQztxREFGVk4sa0RBQUFBLDRCQUdoQkcsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFO1lBQ2pCLElBQUlGLGFBQWE7Z0JBQ2YxQywwQkFBMEIwQyxnQkFBZ0I7WUFDNUM7UUFDRjtnQ0FBRyxFQUFFO0lBRUh0RyxnREFBU0E7aUNBQUM7WUFDTixJQUFJO2dCQUNBLE1BQU00RyxTQUFTQyxPQUFPQyxZQUFZLENBQUNDLE9BQU8sQ0FBQztnQkFDM0MsSUFBSUgsV0FBVyxhQUFhQSxXQUFXLGVBQWU5QyxvQkFBb0I4QztnQkFDdEUsTUFBTUksS0FBS0gsT0FBT0MsWUFBWSxDQUFDQyxPQUFPLENBQUM7Z0JBQ3ZDLElBQUlDLE9BQU8sV0FBV0EsT0FBTyxRQUFRaEQsb0JBQW9CZ0Q7Z0JBQ3JELE1BQU1DLEtBQUtKLE9BQU9DLFlBQVksQ0FBQ0MsT0FBTyxDQUFDO2dCQUN2QyxJQUFJRSxPQUFPLFVBQVVBLE9BQU8sU0FBUy9DLHNCQUFzQitDLE9BQU87WUFDOUUsRUFBRSxPQUFPQyxHQUFHO1lBQ1IsU0FBUztZQUNiO1FBQ0o7Z0NBQUcsRUFBRTtJQUVQLE1BQU1DLHVCQUF1QjtRQUMzQnZELDBCQUEwQndELENBQUFBO1lBQ3hCLE1BQU1DLFdBQVcsQ0FBQ0Q7WUFDbEJmLFNBQVNFLE1BQU0sR0FBRyx3QkFBaUMsT0FBVGMsVUFBUyw2QkFBMkIsb0JBQW9CO1lBQ2xHLE9BQU9BO1FBQ1Q7SUFDRjtJQUVFLE1BQU1DLGlCQUFpQixDQUFDQztRQUNwQnpELG9CQUFvQnlEO1FBQ3BCLElBQUk7WUFDQVYsT0FBT0MsWUFBWSxDQUFDVSxPQUFPLENBQUMsZ0JBQWdCRDtRQUNoRCxFQUFFLE9BQU9MLEdBQUc7UUFDUixTQUFTO1FBQ2I7SUFDSjtJQUVJLE1BQU1PLGlCQUFpQixDQUFDQztRQUNwQjFELG9CQUFvQjBEO1FBQ3BCLElBQUk7WUFDQWIsT0FBT0MsWUFBWSxDQUFDVSxPQUFPLENBQUMsZ0JBQWdCRTtRQUNoRCxFQUFFLE9BQU9SLEdBQUc7UUFDUixTQUFTO1FBQ2I7SUFDSjtJQUVBLE1BQU1TLG1CQUFtQixDQUFDRDtRQUN0QnhELHNCQUFzQndEO1FBQ3RCLElBQUk7WUFDQWIsT0FBT0MsWUFBWSxDQUFDVSxPQUFPLENBQUMsbUJBQW1CRSxJQUFJLFNBQVM7UUFDaEUsRUFBRSxPQUFPUixHQUFHO1FBQ1IsU0FBUztRQUNiO0lBQ0o7SUFFQSxxRUFBcUU7SUFDckVsSCxnREFBU0E7aUNBQUM7WUFDTixJQUFJO2dCQUNBLElBQUk2RCxnQkFBZ0IsV0FBVztvQkFDM0J3QyxTQUFTdUIsSUFBSSxDQUFDQyxTQUFTLENBQUNDLEdBQUcsQ0FBQztnQkFDaEMsT0FBTztvQkFDSHpCLFNBQVN1QixJQUFJLENBQUNDLFNBQVMsQ0FBQ0UsTUFBTSxDQUFDO2dCQUNuQztZQUNKLEVBQUUsT0FBT2IsR0FBRztZQUNSLFNBQVM7WUFDYjtRQUNKO2dDQUFHO1FBQUNyRDtLQUFZO0lBRXRCLE1BQU1tRSxxQkFBcUI7UUFDekJ0RSx5QkFBeUIwRCxDQUFBQSxZQUFhLENBQUNBO0lBQ3pDO0lBRUEsTUFBTWEsYUFBYTtRQUNqQmxGLFNBQVMsSUFBSUM7UUFDYkUsWUFBWSxFQUFFO1FBQ2RFLFNBQVMsRUFBRTtRQUNYRSxlQUFlO0lBQ2pCO0lBRUEsa0RBQWtEO0lBQ2xELE1BQU00RSxtQkFBbUI7UUFDdkJEO1FBQ0EsOEJBQThCO1FBQzlCNUIsU0FBU0UsTUFBTSxHQUFHO1FBQ2xCLHdCQUF3QjtRQUN4QmhFLCtEQUFjQTtJQUNoQjtJQUVFLE1BQU00RixZQUFZbEksa0RBQVdBOzhDQUFDLE9BQU9tSTtZQUNqQzVFLFdBQVc7WUFDWCxJQUFJO2dCQUNBLDREQUE0RDtnQkFDNUQsTUFBTTZFLGVBQWUsTUFBTXRHLGtFQUFpQkEsQ0FBQztvQkFBRXVHLHNCQUFzQjtnQkFBSztnQkFDMUUsTUFBTUMsa0JBQW1CRixnQkFBZ0IsRUFBRTtnQkFFM0MseUJBQXlCO2dCQUN6QixNQUFNRyxhQUFhLElBQUl4RjtnQkFDdkJ1RixnQkFBZ0J0QyxPQUFPOzBEQUFDdEIsQ0FBQUEsSUFBSzZELFdBQVdDLEdBQUcsQ0FBQzlELEVBQUVhLEVBQUUsRUFBRTs0QkFBRSxHQUFJZCxpQkFBaUJDLEVBQUU7NEJBQVUrRCxhQUFhLEVBQUU7d0JBQUM7O2dCQUVyRyxNQUFNQyxpQkFBNEIsRUFBRTtnQkFDcENILFdBQVd2QyxPQUFPOzBEQUFDMkMsQ0FBQUE7d0JBQ2YsSUFBSUEsUUFBUUMsZUFBZSxFQUFFOzRCQUN6QixNQUFNQyxTQUFTTixXQUFXTyxHQUFHLENBQUNILFFBQVFDLGVBQWU7NEJBQ3JELElBQUlDLFFBQVFBLE9BQU9KLFdBQVcsQ0FBQ00sSUFBSSxDQUFDSjtpQ0FDL0JELGVBQWVLLElBQUksQ0FBQ0o7d0JBQzdCLE9BQU87NEJBQ0hELGVBQWVLLElBQUksQ0FBQ0o7d0JBQ3hCO29CQUNKOztnQkFFQTFGLFlBQVl5RjtnQkFFWiwyQkFBMkI7Z0JBQzNCLE1BQU1NLFlBQVksTUFBTWpILCtEQUFjQSxDQUFDO29CQUFFc0csc0JBQXNCO2dCQUFLO2dCQUNwRSxNQUFNWSxXQUFZRCxhQUFhLEVBQUU7Z0JBQ2pDLE1BQU1FLFVBQVUsSUFBSW5HO2dCQUNwQmtHLFNBQVNqRCxPQUFPOzBEQUFDbUQsQ0FBQUEsSUFBS0QsUUFBUVYsR0FBRyxDQUFDVyxFQUFFNUQsRUFBRSxFQUFFNEQ7O2dCQUN4Q3JHLFNBQVNvRztnQkFFVCx3QkFBd0I7Z0JBQ3hCLE1BQU1FLFFBQVE3Ryw4REFBYUE7Z0JBQzNCRyxPQUFPMkcsS0FBSyxDQUFDLHFCQUFxQjtvQkFDOUJDLFdBQVc7b0JBQ1hGLE9BQU87d0JBQ0hHLFNBQVMsR0FBb0MsT0FBakMsQ0FBQ0gsTUFBTUcsT0FBTyxHQUFHLEdBQUUsRUFBR0MsT0FBTyxDQUFDLElBQUc7d0JBQzdDQyxNQUFNTCxNQUFNSyxJQUFJO3dCQUNoQkMsUUFBUU4sTUFBTU0sTUFBTTt3QkFDcEJDLE1BQU1QLE1BQU1PLElBQUk7b0JBQ3BCO2dCQUNKO1lBRUosRUFBRSxPQUFPQyxPQUFZO2dCQUNqQkMsUUFBUUQsS0FBSyxDQUFDLHdCQUF3QkE7Z0JBRXRDLGtFQUFrRTtnQkFDbEUsSUFBSUEsQ0FBQUEsa0JBQUFBLDRCQUFBQSxNQUFPRSxNQUFNLE1BQUssT0FBT0YsQ0FBQUEsa0JBQUFBLDRCQUFBQSxNQUFPRSxNQUFNLE1BQUssS0FBSztvQkFDaERELFFBQVFFLElBQUksQ0FBQztvQkFDYjlCO29CQUNBL0QsbUJBQUFBLDZCQUFBQSxPQUFRNkUsSUFBSSxDQUFDO2dCQUNqQixPQUVLLElBQUlhLENBQUFBLGtCQUFBQSw0QkFBQUEsTUFBT0UsTUFBTSxNQUFLLEtBQUs7b0JBQzVCRCxRQUFRRSxJQUFJLENBQUM7b0JBQ2J6SCwrREFBY0E7Z0JBQ2QsdURBQXVEO2dCQUMzRDtZQUNKLFNBQVU7Z0JBQ05pQixXQUFXO1lBQ2Y7UUFDSjs2Q0FBRyxFQUFFO0lBRUwsa0RBQWtEO0lBQ2xELE1BQU15RyxrQkFBa0JoSyxrREFBV0E7b0RBQUM7WUFDaEMsSUFBSTtnQkFDQSxnQ0FBZ0M7Z0JBQ2hDLE1BQU1vSSxlQUFlLE1BQU10RyxrRUFBaUJBLENBQUM7b0JBQUVtSSxjQUFjO2dCQUFLO2dCQUNsRSxNQUFNM0Isa0JBQW1CRixnQkFBZ0IsRUFBRTtnQkFFM0MsTUFBTUcsYUFBYSxJQUFJeEY7Z0JBQ3ZCdUYsZ0JBQWdCdEMsT0FBTztnRUFBQ3RCLENBQUFBLElBQUs2RCxXQUFXQyxHQUFHLENBQUM5RCxFQUFFYSxFQUFFLEVBQUU7NEJBQUUsR0FBSWQsaUJBQWlCQyxFQUFFOzRCQUFVK0QsYUFBYSxFQUFFO3dCQUFDOztnQkFFckcsTUFBTUMsaUJBQTRCLEVBQUU7Z0JBQ3BDSCxXQUFXdkMsT0FBTztnRUFBQzJDLENBQUFBO3dCQUNmLElBQUlBLFFBQVFDLGVBQWUsRUFBRTs0QkFDekIsTUFBTUMsU0FBU04sV0FBV08sR0FBRyxDQUFDSCxRQUFRQyxlQUFlOzRCQUNyRCxJQUFJQyxRQUFRQSxPQUFPSixXQUFXLENBQUNNLElBQUksQ0FBQ0o7aUNBQy9CRCxlQUFlSyxJQUFJLENBQUNKO3dCQUM3QixPQUFPOzRCQUNIRCxlQUFlSyxJQUFJLENBQUNKO3dCQUN4QjtvQkFDSjs7Z0JBRUExRixZQUFZeUY7WUFDaEIsRUFBRSxPQUFPa0IsT0FBTztnQkFDWkMsUUFBUUQsS0FBSyxDQUFDLDhCQUE4QkE7WUFDaEQ7UUFDSjttREFBRyxFQUFFO0lBRUwsd0RBQXdEO0lBQ3hEN0osZ0RBQVNBO2lDQUFDO1lBQ0w2RyxPQUFlc0QsbUJBQW1CO3lDQUFHO29CQUNsQzVILCtEQUFjQTtvQkFDZCxJQUFJYyx3QkFBQUEsa0NBQUFBLFlBQWFtQyxFQUFFLEVBQUU7d0JBQ2pCMkMsVUFBVTlFLFlBQVltQyxFQUFFO29CQUM1QjtnQkFDSjs7WUFDQTt5Q0FBTztvQkFDSCxPQUFPLE9BQWdCMkUsbUJBQW1CO2dCQUM5Qzs7UUFDSjtnQ0FBRztRQUFDOUc7UUFBYThFO0tBQVU7SUFFM0JuSSxnREFBU0E7aUNBQUM7WUFDTixJQUFJb0ssVUFBVTtZQUNkO3lDQUFDO29CQUNHLElBQUk7d0JBQ0E1RyxXQUFXO3dCQUNYLE1BQU02RyxPQUFPLE1BQU1wSixnREFBTUE7d0JBQ3pCLE1BQU1xSixPQUFPRCxpQkFBQUEsMkJBQUFBLEtBQU1DLElBQUk7d0JBQ3ZCLElBQUlGLFdBQVdFLE1BQU07NEJBQ2pCaEgsZUFBZWdIOzRCQUNmLE1BQU1uQyxVQUFVbUMsS0FBSzlFLEVBQUU7d0JBQzNCLE9BQU8sSUFBSTRFLFNBQVM7NEJBQ2hCLGtFQUFrRTs0QkFDbEVuQzt3QkFDSjtvQkFDSixFQUFFLE9BQU9zQyxLQUFLO3dCQUNWVCxRQUFRRSxJQUFJLENBQUMsaUNBQWlDTzt3QkFDOUN0QztvQkFDSixTQUFVO3dCQUNOLElBQUltQyxTQUFTNUcsV0FBVztvQkFDNUI7Z0JBQ0o7O1lBRUE7eUNBQU87b0JBQVE0RyxVQUFVO2dCQUFNOztRQUNuQztnQ0FBRztRQUFDakM7S0FBVTtJQUVoQm5JLGdEQUFTQTtpQ0FBQztZQUNSLElBQUl1RCxTQUFTO1lBRWIsSUFBSSxDQUFDRixlQUFlZSxhQUFhLFlBQVlBLGFBQWEsV0FBVztnQkFDbkVELE9BQU82RSxJQUFJLENBQUM7WUFDZDtRQUNGO2dDQUFHO1FBQUMzRjtRQUFhRTtRQUFTYTtRQUFVRDtLQUFPO0lBRTNDbkUsZ0RBQVNBO2lDQUFDO1lBQ1IsSUFBSSxDQUFDcUQsZUFBZUosU0FBU3VILE1BQU0sS0FBSyxHQUFHO2dCQUN2Q3BILFNBQVMsRUFBRTtnQkFDWDtZQUNKO1lBRUEseUJBQXlCO1lBQ3pCLE1BQU1xSDswREFBbUIsQ0FBQ0M7b0JBQ3RCLElBQUlDLE1BQWdCLEVBQUU7b0JBQ3RCRCxNQUFNekUsT0FBTztrRUFBQ3RCLENBQUFBOzRCQUNWZ0csSUFBSTNCLElBQUksQ0FBQ3JFLEVBQUVhLEVBQUU7NEJBQ2IsSUFBSWIsRUFBRStELFdBQVcsRUFBRTtnQ0FDZmlDLE1BQU1BLElBQUlDLE1BQU0sQ0FBQ0gsaUJBQWlCOUYsRUFBRStELFdBQVc7NEJBQ25EO3dCQUNKOztvQkFDQSxPQUFPaUM7Z0JBQ1g7O1lBRUEsTUFBTUUsZ0JBQWdCSixpQkFBaUJ4SDtZQUV2QyxJQUFJNEgsY0FBY0wsTUFBTSxLQUFLLEdBQUc7Z0JBQzVCcEgsU0FBUyxFQUFFO2dCQUNYO1lBQ0o7WUFFQSxNQUFNMEgsYUFBYSxLQUFLLHdDQUF3QztZQUNoRSxNQUFNQyxnQkFBNEIsRUFBRTtZQUNwQyxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUgsY0FBY0wsTUFBTSxFQUFFUSxLQUFLRixXQUFZO2dCQUN2REMsY0FBYy9CLElBQUksQ0FBQzZCLGNBQWNJLEtBQUssQ0FBQ0QsR0FBR0EsSUFBSUY7WUFDbEQ7WUFFQSxzQkFBc0I7WUFDdEIsTUFBTUk7dURBQWdCLENBQUNDO3dCQUVYQSxhQUNJQSxlQUNGQTsyQkFKcUI7d0JBQy9CLEdBQUdBLENBQUM7d0JBQ0pwQixRQUFRb0IsQ0FBQUEsY0FBQUEsRUFBRUMsUUFBUSxjQUFWRCx5QkFBQUEsY0FBZSxPQUFPQSxFQUFFcEIsTUFBTSxLQUFLLFlBQVkscUJBQXFCc0IsSUFBSSxDQUFDRixFQUFFcEIsTUFBTSxJQUFJb0IsRUFBRXBCLE1BQU0sR0FBRzt3QkFDeEd1QixZQUFZSCxDQUFBQSxnQkFBQUEsRUFBRUcsVUFBVSxjQUFaSCwyQkFBQUEsZ0JBQWdCekk7d0JBQzVCNkksVUFBVUosQ0FBQUEsY0FBQUEsRUFBRUksUUFBUSxjQUFWSix5QkFBQUEsY0FBY3pJO29CQUM1Qjs7O1lBRUEsb0VBQW9FO1lBQ3BFLE1BQU04STtvREFBYTt3QkFBT3RCLGdGQUFlO29CQUNyQyxJQUFJO3dCQUNBLE1BQU11QixVQUFVLE1BQU1DLFFBQVFDLEdBQUcsQ0FDN0JaLGNBQWMvRixHQUFHO2dFQUFDNEcsQ0FBQUEsUUFDZDNKLDJFQUEwQkEsQ0FBQzJKLE9BQU87b0NBQzlCMUI7b0NBQ0E1QixzQkFBc0IsQ0FBQzRCO2dDQUMzQjs7d0JBR1IsTUFBTTJCLFdBQWtCSixRQUFRSyxJQUFJO3dCQUNwQyxNQUFNQyxrQkFBa0JGLFNBQVM3RyxHQUFHLENBQUNrRzt3QkFDckM5SCxTQUFTMkk7d0JBQ1QsT0FBT0E7b0JBQ1gsRUFBRSxPQUFPeEIsS0FBVTt3QkFDZlQsUUFBUUQsS0FBSyxDQUFDLHlCQUF5QlU7d0JBQ3ZDVCxRQUFRRCxLQUFLLENBQUMsa0RBQWtEZ0I7d0JBRWhFLDBFQUEwRTt3QkFDMUUsZ0ZBQWdGO3dCQUNoRixJQUFJTixDQUFBQSxnQkFBQUEsMEJBQUFBLElBQUtSLE1BQU0sTUFBSyxLQUFLOzRCQUNyQkQsUUFBUUUsSUFBSSxDQUFDOzRCQUNiekgsK0RBQWNBO3dCQUNkLG9EQUFvRDt3QkFDeEQ7d0JBQ0EsT0FBTyxFQUFFO29CQUNiO2dCQUNKOztZQUVBLHFCQUFxQjtZQUNyQmlKO1lBRUEsNkJBQTZCO1lBQzdCLElBQUlRLGtCQUF5QztZQUM3QyxJQUFJQyxnQkFBZ0I7WUFDcEIsSUFBSUMsdUJBQXVCO1lBQzNCLElBQUlDLGlCQUFpQjtZQUVyQix1Q0FBdUM7WUFDdkMsTUFBTUM7NERBQXFCO29CQUN2QixJQUFJLENBQUNELGdCQUFnQixPQUFPLE9BQU8sa0NBQWtDO29CQUNyRSxJQUFJRCx1QkFBdUIsR0FBRyxPQUFPLE9BQU8sOEJBQThCO29CQUMxRSxPQUFPLE9BQU8sdURBQXVEO2dCQUN6RTs7WUFFQSxNQUFNRztzREFBZTtvQkFDakIsSUFBSUwsaUJBQWlCTSxjQUFjTjtvQkFFbkMsTUFBTU87bUVBQU87NEJBQ1QsTUFBTXBKLFFBQVEsTUFBTXFJOzRCQUVwQiw0Q0FBNEM7NEJBQzVDLElBQUlySSxNQUFNcUgsTUFBTSxLQUFLeUIsZUFBZTtnQ0FDaENDOzRCQUNKLE9BQU87Z0NBQ0hBLHVCQUF1QjtnQ0FDdkJELGdCQUFnQjlJLE1BQU1xSCxNQUFNOzRCQUNoQzs0QkFFQSx3Q0FBd0M7NEJBQ3hDNkI7d0JBQ0o7O29CQUVBTCxrQkFBa0JRLFlBQVlELE1BQU1IO2dCQUN4Qzs7WUFFQSxnREFBZ0Q7WUFDaEQsTUFBTUs7cURBQWM7b0JBQ2hCTixpQkFBaUI7b0JBQ2pCRCx1QkFBdUIsR0FBRywwQkFBMEI7Z0JBQ3hEOztZQUVBLE1BQU1RO29EQUFhO29CQUNmUCxpQkFBaUI7Z0JBQ3JCOztZQUVBLHNGQUFzRjtZQUN0RixJQUFJLENBQUM1SCxlQUFlb0ksT0FBTyxFQUFFO2dCQUN6QiwrREFBK0Q7Z0JBQy9ELE1BQU1DO3dEQUFhO3dCQUNmLGtDQUFrQzt3QkFDbEMsSUFBSUMsSUFBbUMsRUFBRTs0QkFDckMsT0FBT0EseURBQW1DO3dCQUM5Qzt3QkFDQSxJQUFJQSxJQUFnQyxFQUFFOzRCQUNsQyxPQUFPQSx5REFBZ0M7d0JBQzNDO3dCQUVBLElBQUksS0FBNkIsRUFBRSxFQUErQjt3QkFFbEUsTUFBTUksV0FBV3BHLE9BQU9xRyxRQUFRLENBQUNELFFBQVE7d0JBQ3pDLE1BQU1FLFdBQVd0RyxPQUFPcUcsUUFBUSxDQUFDQyxRQUFRO3dCQUV6QyxvQkFBb0I7d0JBQ3BCLElBQUlGLGFBQWEsZUFBZUEsYUFBYSxhQUFhOzRCQUN0RCxPQUFPO3dCQUNYO3dCQUVBLDBDQUEwQzt3QkFDMUMsc0RBQXNEO3dCQUN0RCxNQUFNRyxhQUFhSCxTQUFTSSxRQUFRLENBQUM7d0JBQ3JDLE1BQU1DLGtCQUFrQkYsYUFBYSxXQUFXRDt3QkFFaEQsSUFBSUMsWUFBWTs0QkFDWiwrQ0FBK0M7NEJBQy9DLE1BQU1HLGtCQUFrQk4sU0FBU08sT0FBTyxDQUFDLFdBQVc7NEJBQ3BELE9BQU8sR0FBdUJELE9BQXBCRCxpQkFBZ0IsTUFBb0IsT0FBaEJDO3dCQUNsQzt3QkFFQSxPQUFPLEdBQXVCTixPQUFwQkssaUJBQWdCLE1BQWEsT0FBVEwsVUFBUztvQkFDM0M7O2dCQUVBLE1BQU1RLFVBQVViO2dCQUVoQnJJLGVBQWVvSSxPQUFPLEdBQUcsSUFBSTlLLHFEQUFjQSxDQUFDNEw7Z0JBRTVDLCtDQUErQztnQkFDL0NsSixlQUFlb0ksT0FBTyxDQUFDZSxFQUFFLENBQUM7NkNBQWUsQ0FBQ0M7d0JBQ3RDLE1BQU0sRUFBRUMsTUFBTSxFQUFFRCxNQUFNRSxRQUFRLEVBQUUsR0FBR0Y7d0JBQ25DLE1BQU1HLGlCQUFpQjVDLGNBQWMyQzt3QkFFckN6SztxREFBUzJLLENBQUFBO2dDQUNMLE9BQVFIO29DQUNKLEtBQUs7d0NBQ0Qsb0RBQW9EO3dDQUNwRCxNQUFNSSxlQUFlRCxLQUFLdEgsSUFBSTtrRkFBQzBFLENBQUFBLElBQUtBLEVBQUUzRixFQUFFLEtBQUtzSSxlQUFldEksRUFBRTs7d0NBQzlELElBQUksQ0FBQ3dJLGNBQWM7NENBQ2YsT0FBTzttREFBSUQ7Z0RBQU1EOzZDQUFlO3dDQUNwQyxPQUFPOzRDQUNILE9BQU9DO3dDQUNYO29DQUNKLEtBQUs7d0NBQ0QsdUJBQXVCO3dDQUN2QixPQUFPQSxLQUFLL0ksR0FBRztxRUFBQ21HLENBQUFBLElBQUtBLEVBQUUzRixFQUFFLEtBQUtzSSxlQUFldEksRUFBRSxHQUFHc0ksaUJBQWlCM0M7O29DQUN2RSxLQUFLO3dDQUNELHNCQUFzQjt3Q0FDdEIsT0FBTzRDLEtBQUtFLE1BQU07cUVBQUM5QyxDQUFBQSxJQUFLQSxFQUFFM0YsRUFBRSxLQUFLc0ksZUFBZXRJLEVBQUU7O29DQUN0RDt3Q0FDSSxPQUFPdUk7Z0NBQ2Y7NEJBQ0o7O29CQUNKOztnQkFFQXhKLGVBQWVvSSxPQUFPLENBQUNlLEVBQUUsQ0FBQzs2Q0FBa0IsQ0FBQ0M7d0JBQ3pDLDZFQUE2RTt3QkFDN0UxRDtvQkFDSjs7Z0JBRUExRixlQUFlb0ksT0FBTyxDQUFDZSxFQUFFLENBQUM7NkNBQWlCLENBQUNDO29CQUN4Qyw4REFBOEQ7b0JBQ2xFOztnQkFFQSx1REFBdUQ7Z0JBQ3ZEcEosZUFBZW9JLE9BQU8sQ0FBQ2UsRUFBRSxDQUFDOzZDQUFxQixDQUFDQzt3QkFDNUNsSix1QkFBdUI7d0JBRXZCLHVEQUF1RDt3QkFDdkRvQyxPQUFPcUgsZ0JBQWdCLENBQUMsU0FBU3pCO3dCQUNqQzVGLE9BQU9xSCxnQkFBZ0IsQ0FBQyxRQUFReEI7d0JBRWhDLDRCQUE0Qjt3QkFDNUJMO29CQUNKOztZQUNKO1lBRUEsc0NBQXNDO1lBQ3RDOUgsZUFBZW9JLE9BQU8sQ0FBQ3dCLE9BQU87WUFFOUIsaUZBQWlGO1lBQ2pGQzt5Q0FBVzt3QkFDRjdKO29CQUFMLElBQUksR0FBQ0EsMEJBQUFBLGVBQWVvSSxPQUFPLGNBQXRCcEksOENBQUFBLHdCQUF3QjhKLG1CQUFtQixLQUFJO3dCQUNoRDVKLHVCQUF1Qjt3QkFDdkJvQyxPQUFPcUgsZ0JBQWdCLENBQUMsU0FBU3pCO3dCQUNqQzVGLE9BQU9xSCxnQkFBZ0IsQ0FBQyxRQUFReEI7d0JBQ2hDTDtvQkFDSixPQUFPO3dCQUNINUgsdUJBQXVCO29CQUMzQjtnQkFDSjt3Q0FBRztZQUVIO3lDQUFPO29CQUNILDJDQUEyQztvQkFDM0MsSUFBSUYsZUFBZW9JLE9BQU8sRUFBRTt3QkFDeEJwSSxlQUFlb0ksT0FBTyxDQUFDMkIsVUFBVTtvQkFDckM7b0JBRUEsSUFBSXRDLGlCQUFpQjt3QkFDakJNLGNBQWNOO29CQUNsQjtvQkFFQW5GLE9BQU8wSCxtQkFBbUIsQ0FBQyxTQUFTOUI7b0JBQ3BDNUYsT0FBTzBILG1CQUFtQixDQUFDLFFBQVE3QjtvQkFDbkNqSSx1QkFBdUI7Z0JBQzNCOztRQUNKO2dDQUFHO1FBQUNwQjtRQUFhSjtLQUFTO0lBRXRCLE1BQU11TCx5QkFBeUIsT0FBT0M7UUFDbEMsSUFBSSxDQUFDcEwsYUFBYSxNQUFNLElBQUlxTCxNQUFNO1FBQ2xDLElBQUk7WUFDQSxNQUFNQyxrQkFBa0I7Z0JBQ3BCO29CQUFFbEosTUFBTTtvQkFBU0MsT0FBTztvQkFBV0MsT0FBTztvQkFBR0MsbUJBQW1CO29CQUFPQyxRQUFRO29CQUFPQyxpQkFBaUI7b0JBQU9DLGVBQWU7Z0JBQU07Z0JBQ25JO29CQUFFTixNQUFNO29CQUFlQyxPQUFPO29CQUFXQyxPQUFPO29CQUFHQyxtQkFBbUI7b0JBQU9DLFFBQVE7b0JBQU9DLGlCQUFpQjtvQkFBT0MsZUFBZTtnQkFBSztnQkFDeEk7b0JBQUVOLE1BQU07b0JBQVFDLE9BQU87b0JBQVdDLE9BQU87b0JBQUdDLG1CQUFtQjtvQkFBTUMsUUFBUTtvQkFBT0MsaUJBQWlCO29CQUFPQyxlQUFlO2dCQUFNO2dCQUNqSTtvQkFBRU4sTUFBTTtvQkFBVUMsT0FBTztvQkFBV0MsT0FBTztvQkFBR0MsbUJBQW1CO29CQUFPQyxRQUFRO29CQUFPQyxpQkFBaUI7b0JBQU1DLGVBQWU7Z0JBQUs7YUFDckk7WUFFRCxnRUFBZ0U7WUFDaEUsTUFBTTZJLGVBQW1DRCxnQkFBZ0IzSixHQUFHLENBQUMsQ0FBQ0MsR0FBRzRKLFFBQVc7b0JBQ3hFLEdBQUc1SixDQUFDO29CQUNKTyxJQUFJLFFBQXNCcUosT0FBZEMsS0FBS0MsR0FBRyxJQUFHLEtBQVMsT0FBTkYsT0FBUSxlQUFlO2dCQUNyRDtZQUVBM0wsWUFBWTZLLENBQUFBO2dCQUNSLE1BQU1pQixnQkFBZ0IsQ0FBQy9MO29CQUNuQixPQUFPQSxTQUFTK0IsR0FBRyxDQUFDTCxDQUFBQTt3QkFDaEIsSUFBSUEsRUFBRWEsRUFBRSxLQUFLaUosV0FBVzs0QkFDcEIsT0FBTztnQ0FDSCxHQUFHOUosQ0FBQztnQ0FDSkMsbUJBQW1CO3VDQUFLRCxFQUFFQyxpQkFBaUIsSUFBSSxFQUFFO3VDQUFNZ0s7aUNBQWE7NEJBQ3hFO3dCQUNKO3dCQUNBLElBQUlqSyxFQUFFK0QsV0FBVyxFQUFFOzRCQUNmLE9BQU87Z0NBQUUsR0FBRy9ELENBQUM7Z0NBQUUrRCxhQUFhc0csY0FBY3JLLEVBQUUrRCxXQUFXOzRCQUFFO3dCQUM3RDt3QkFDQSxPQUFPL0Q7b0JBQ1g7Z0JBQ0o7Z0JBQ0EsT0FBT3FLLGNBQWNqQjtZQUN6QjtZQUVBLCtDQUErQztZQUMvQyxNQUFNa0Isa0JBQXNDLEVBQUU7WUFDOUMsS0FBSyxNQUFNaEssS0FBSzBKLGdCQUFpQjtnQkFDN0IsTUFBTU8sVUFBVSxNQUFNL04sNkRBQW1CQSxDQUFDc04sV0FBVztvQkFDakR2SixPQUFPRCxFQUFFUSxJQUFJO29CQUNiQyxPQUFPVCxFQUFFUyxLQUFLO29CQUNkQyxPQUFPVixFQUFFVSxLQUFLO29CQUNkQyxtQkFBbUJYLEVBQUVXLGlCQUFpQjtvQkFDdENDLFFBQVFaLEVBQUVZLE1BQU07Z0JBQ3BCO2dCQUNBb0osZ0JBQWdCakcsSUFBSSxDQUFDa0c7WUFDekI7WUFFQSw0Q0FBNEM7WUFDNUNoTSxZQUFZNkssQ0FBQUE7Z0JBQ1IsTUFBTWlCLGdCQUFnQixDQUFDL0w7b0JBQ25CLE9BQU9BLFNBQVMrQixHQUFHLENBQUNMLENBQUFBO3dCQUNoQixJQUFJQSxFQUFFYSxFQUFFLEtBQUtpSixXQUFXO2dDQUlSOUo7NEJBSFosT0FBTztnQ0FDSCxHQUFHQSxDQUFDO2dDQUNKQyxtQkFBbUI7dUNBQ1hELEVBQUFBLHVCQUFBQSxFQUFFQyxpQkFBaUIsY0FBbkJELDJDQUFBQSxxQkFBcUJzSixNQUFNLENBQUNoSixDQUFBQSxJQUFLLENBQUNBLEVBQUVPLEVBQUUsQ0FBQ21CLFVBQVUsQ0FBQyxjQUFhLEVBQUU7dUNBQ2xFc0k7aUNBQ047NEJBQ0w7d0JBQ0o7d0JBQ0EsSUFBSXRLLEVBQUUrRCxXQUFXLEVBQUU7NEJBQ2YsT0FBTztnQ0FBRSxHQUFHL0QsQ0FBQztnQ0FBRStELGFBQWFzRyxjQUFjckssRUFBRStELFdBQVc7NEJBQUU7d0JBQzdEO3dCQUNBLE9BQU8vRDtvQkFDWDtnQkFDSjtnQkFDQSxPQUFPcUssY0FBY2pCO1lBQ3pCO1FBQ0osRUFBRSxPQUFPbEUsT0FBTztZQUNabEgsT0FBT2tILEtBQUssQ0FBQyxzQ0FBc0M7Z0JBQy9DMUQsUUFBUTlDLFlBQVltQyxFQUFFO2dCQUN0QmlKO2dCQUNBYixRQUFRO1lBQ1osR0FBRy9EO1lBQ0gsb0NBQW9DO1lBQ3BDLE1BQU0xQixVQUFVOUUsWUFBWW1DLEVBQUU7WUFDOUIsTUFBTXFFO1FBQ1Y7SUFDSjtJQUdGLE1BQU1zRixRQUFRLE9BQU9DLE9BQWVDO1FBQ2xDLElBQUk7WUFDQSxNQUFNaEYsT0FBTyxNQUFNdkosbURBQVNBLENBQUNzTyxPQUFPQztZQUVwQywyQ0FBMkM7WUFDM0MsSUFBSWhGLFFBQVEsYUFBYUEsUUFBUUEsS0FBS2lGLE9BQU8sS0FBSyxTQUFTakYsS0FBS2tGLFVBQVUsRUFBRTtnQkFDeEU1TSxPQUFPMkcsS0FBSyxDQUFDLHNDQUFzQztvQkFDL0M4RjtvQkFDQXhCLFFBQVE7b0JBQ1I0QixXQUFXO2dCQUNmO2dCQUNBLE9BQU87b0JBQUVGLFNBQVM7b0JBQU96RixPQUFPUSxLQUFLUixLQUFLO2dCQUFDO1lBQy9DO1lBRUEsTUFBTVMsT0FBT0QsaUJBQUFBLDJCQUFBQSxLQUFNQyxJQUFJO1lBQ3ZCLElBQUlBLE1BQU07Z0JBQ1JoSCxlQUFlZ0g7Z0JBQ2YsTUFBTW5DLFVBQVVtQyxLQUFLOUUsRUFBRTtnQkFDdkI3QyxPQUFPOE0sSUFBSSxDQUFDLHlCQUF5QjtvQkFDbkN0SixRQUFRbUUsS0FBSzlFLEVBQUU7b0JBQ2Y0SjtvQkFDQXhCLFFBQVE7Z0JBQ1Y7Z0JBQ0EsT0FBTztvQkFBRTBCLFNBQVM7Z0JBQUs7WUFDekI7WUFDQSxPQUFPO2dCQUFFQSxTQUFTO2dCQUFPekYsT0FBTztZQUFlO1FBQ25ELEVBQUUsT0FBT0EsT0FBWTtnQkFnQklBO1lBZnJCLHdFQUF3RTtZQUN4RSxJQUFJQSxDQUFBQSxrQkFBQUEsNEJBQUFBLE1BQU9FLE1BQU0sTUFBSyxPQUFPRixDQUFBQSxrQkFBQUEsNEJBQUFBLE1BQU9FLE1BQU0sTUFBSyxRQUFPRixrQkFBQUEsNEJBQUFBLE1BQU8wRixVQUFVLEdBQUU7Z0JBQ3JFNU0sT0FBTzJHLEtBQUssQ0FBQyxzQ0FBc0M7b0JBQy9DOEY7b0JBQ0F4QixRQUFRO29CQUNSNEIsV0FBVztnQkFDZjtZQUNKLE9BQU87b0JBSVkzRjtnQkFIZmxILE9BQU9rSCxLQUFLLENBQUMsZUFBZTtvQkFDeEJ1RjtvQkFDQXhCLFFBQVE7b0JBQ1I0QixXQUFXM0YsQ0FBQUEsa0JBQUFBLDZCQUFBQSxlQUFBQSxNQUFPakMsSUFBSSxjQUFYaUMsbUNBQUFBLGFBQWFBLEtBQUssTUFBSUEsa0JBQUFBLDRCQUFBQSxNQUFPNkYsT0FBTyxLQUFJO29CQUNuRDNGLE1BQU0sRUFBRUYsa0JBQUFBLDRCQUFBQSxNQUFPRSxNQUFNO2dCQUN6QixHQUFHRjtZQUNQO1lBQ0EsTUFBTThGLGVBQWU5RixDQUFBQSxrQkFBQUEsNkJBQUFBLGNBQUFBLE1BQU9qQyxJQUFJLGNBQVhpQyxrQ0FBQUEsWUFBYUEsS0FBSyxNQUFJQSxrQkFBQUEsNEJBQUFBLE1BQU82RixPQUFPLEtBQUk7WUFDN0QsT0FBTztnQkFBRUosU0FBUztnQkFBT3pGLE9BQU84RjtZQUFhO1FBQ2pEO0lBQ0Y7SUFFQSxNQUFNQyxTQUFTO1FBQ2IsSUFBSTtZQUNBLE1BQU01TyxvREFBVUE7WUFDaEJpSDtZQUNBMUYsK0RBQWNBLElBQUksa0NBQWtDO1lBQ3BENEIsT0FBTzZFLElBQUksQ0FBQztRQUNoQixFQUFFLE9BQU9hLE9BQVk7WUFDakIsd0VBQXdFO1lBQ3hFLElBQUlBLENBQUFBLGtCQUFBQSw0QkFBQUEsTUFBT0UsTUFBTSxNQUFLLE9BQU8sRUFBQ0Ysa0JBQUFBLDRCQUFBQSxNQUFPMEYsVUFBVSxHQUFFO2dCQUM3QzVNLE9BQU9rSCxLQUFLLENBQUMsZ0JBQWdCO29CQUN6QjFELE1BQU0sRUFBRTlDLHdCQUFBQSxrQ0FBQUEsWUFBYW1DLEVBQUU7b0JBQ3ZCb0ksUUFBUTtnQkFDWixHQUFHL0Q7WUFDUDtRQUNKO0lBQ0Y7SUFFQSxNQUFNZ0csYUFBYSxPQUFPakg7UUFDeEIsSUFBSSxDQUFDdkYsYUFBYSxNQUFNLElBQUlxTCxNQUFNO1FBQ2xDLElBQUk7WUFDQSxNQUFNLEVBQUU3RixlQUFlLEVBQUUsR0FBR2lILGVBQWUsR0FBR2xIO1lBQzlDLDhDQUE4QztZQUM5QyxNQUFNbUgsVUFBZTtnQkFBRSxHQUFHRCxhQUFhO1lBQUM7WUFDeEMsSUFBSWpILGlCQUFpQmtILFFBQVFsSCxlQUFlLEdBQUdBO1lBRS9DLE1BQU1tSCxhQUFhLE1BQU01UCx1REFBYUEsQ0FBQzJQO1lBRXZDLGdDQUFnQztZQUNoQzNOLDJFQUEwQkE7WUFFMUIscUVBQXFFO1lBQ3JFLCtEQUErRDtZQUMvRCxNQUFNNkg7WUFFTixPQUFPK0Y7UUFDWCxFQUFFLE9BQU9uRyxPQUFPO1lBQ1pDLFFBQVFELEtBQUssQ0FBQywwQkFBMEJBO1lBQ3hDLE1BQU1BO1FBQ1Y7SUFDRjtJQUVBLE1BQU1tRixnQkFBZ0IsT0FBT1AsV0FBbUJ3QjtRQUM5QyxJQUFJLENBQUM1TSxhQUFhLE1BQU0sSUFBSXFMLE1BQU07UUFFbEMsSUFBSTtZQUNBLCtDQUErQztZQUMvQ3hMLFlBQVk2SyxDQUFBQTtnQkFDUixNQUFNaUIsZ0JBQWdCLENBQUMvTDtvQkFDbkIsT0FBT0EsU0FBUytCLEdBQUcsQ0FBQ0wsQ0FBQUE7d0JBQ2hCLElBQUlBLEVBQUVhLEVBQUUsS0FBS2lKLFdBQVc7NEJBQ3BCLE1BQU15QixVQUFVO2dDQUFFLEdBQUd2TCxDQUFDO2dDQUFFLEdBQUdzTCxXQUFXOzRCQUFDOzRCQUN2Qyw4QkFBOEI7NEJBQzlCM04sd0VBQXVCQSxDQUFDNE47NEJBQ3hCLE9BQU9BO3dCQUNYO3dCQUNBLElBQUl2TCxFQUFFK0QsV0FBVyxFQUFFOzRCQUNmLE9BQU87Z0NBQUUsR0FBRy9ELENBQUM7Z0NBQUUrRCxhQUFhc0csY0FBY3JLLEVBQUUrRCxXQUFXOzRCQUFFO3dCQUM3RDt3QkFDQSxPQUFPL0Q7b0JBQ1g7Z0JBQ0o7Z0JBQ0EsT0FBT3FLLGNBQWNqQjtZQUN6QjtZQUVBLE1BQU0xTiwwREFBZ0JBLENBQUNvTyxXQUFXd0I7WUFFbEMsNEJBQTRCO1lBQzVCL04sd0VBQXVCQSxDQUFDdU07UUFDNUIsRUFBRSxPQUFPNUUsT0FBTztZQUNaQyxRQUFRRCxLQUFLLENBQUMsK0JBQStCQTtZQUM3QyxvQ0FBb0M7WUFDcEMsSUFBR3hHLHdCQUFBQSxrQ0FBQUEsWUFBYW1DLEVBQUUsRUFBRSxNQUFNMkMsVUFBVTlFLFlBQVltQyxFQUFFO1lBQ2xELE1BQU1xRTtRQUNWO0lBQ0Y7SUFFQSxNQUFNbkosYUFBYSxPQUFPK047UUFDeEIsSUFBSTtZQUNBLE1BQU1wRSxPQUFPLE1BQU0xSixvREFBYUEsQ0FBQzhOO1lBQ2pDLE1BQU0wQixPQUFPOUYsT0FBUTNGLGlCQUFpQjJGLFFBQW9CO1lBQzFELElBQUk4RixNQUFNO2dCQUNOLGdHQUFnRztnQkFDaEdqTixZQUFZNkssQ0FBQUE7b0JBQ1IsaURBQWlEO29CQUNqRCxNQUFNUCxVQUFVLENBQUM0Qzt3QkFDYixPQUFPQSxJQUFJcEwsR0FBRyxDQUFDTCxDQUFBQTs0QkFDWCxJQUFJQSxFQUFFYSxFQUFFLEtBQUsySyxLQUFLM0ssRUFBRSxFQUFFLE9BQU87Z0NBQUUsR0FBRzJLLElBQUk7Z0NBQUV6SCxhQUFhL0QsRUFBRStELFdBQVcsSUFBSSxFQUFFOzRCQUFDOzRCQUN6RSxJQUFJL0QsRUFBRStELFdBQVcsRUFBRSxPQUFPO2dDQUFFLEdBQUcvRCxDQUFDO2dDQUFFK0QsYUFBYThFLFFBQVE3SSxFQUFFK0QsV0FBVzs0QkFBRTs0QkFDdEUsT0FBTy9EO3dCQUNYO29CQUNKO29CQUVBLDBDQUEwQztvQkFDMUMsTUFBTTBMLFNBQVMsU0FBVTVKLEtBQUsySixHQUFjO3dCQUN4QyxLQUFLLE1BQU16TCxLQUFLeUwsSUFBSzs0QkFDakIsSUFBSXpMLEVBQUVhLEVBQUUsS0FBSzJLLEtBQUszSyxFQUFFLEVBQUUsT0FBTzs0QkFDN0IsSUFBSWIsRUFBRStELFdBQVcsSUFBSWpDLEtBQUs5QixFQUFFK0QsV0FBVyxHQUFHLE9BQU87d0JBQ3JEO3dCQUNBLE9BQU87b0JBQ1gsRUFBR3FGO29CQUVILElBQUlzQyxRQUFRLE9BQU83QyxRQUFRTztvQkFFM0IsMkJBQTJCO29CQUMzQixPQUFPOzJCQUFJQTt3QkFBTTs0QkFBRSxHQUFJb0MsSUFBSTs0QkFBVXpILGFBQWF5SCxLQUFLekgsV0FBVyxJQUFJLEVBQUU7d0JBQUM7cUJBQUU7Z0JBQy9FO1lBQ0o7WUFDQSxPQUFPeUg7UUFDWCxFQUFFLE9BQU90RyxPQUFPO1lBQ1pDLFFBQVFELEtBQUssQ0FBQywyQkFBMkJBO1lBQ3pDLE9BQU87UUFDWDtJQUNGO0lBRUUsTUFBTXlHLG1CQUFtQixPQUFPN0I7UUFDNUIsSUFBSSxDQUFDcEwsYUFBYSxNQUFNLElBQUlxTCxNQUFNO1FBRWxDLElBQUk7WUFDQSxNQUFNNkIsUUFBUSxJQUFJdk47WUFFbEIsTUFBTXdOLHFCQUFxQixDQUFDOUYsT0FBa0IrRjtnQkFDMUMsS0FBSyxNQUFNOUwsS0FBSytGLE1BQU87b0JBQ25CLElBQUkvRixFQUFFYSxFQUFFLEtBQUtpTCxLQUFLLE9BQU85TDtvQkFDekIsSUFBSUEsRUFBRStELFdBQVcsRUFBRTt3QkFDZixNQUFNZ0ksUUFBUUYsbUJBQW1CN0wsRUFBRStELFdBQVcsRUFBRStIO3dCQUNoRCxJQUFJQyxPQUFPLE9BQU9BO29CQUN0QjtnQkFDSjtnQkFDQSxPQUFPO1lBQ1g7WUFFQSxNQUFNQyx5QkFBeUIsQ0FBQy9IO2dCQUM1QixJQUFJZ0ksT0FBa0I7b0JBQUNoSTtpQkFBUTtnQkFDL0IsSUFBSUEsUUFBUUYsV0FBVyxFQUFFO29CQUNyQkUsUUFBUUYsV0FBVyxDQUFDekMsT0FBTyxDQUFDNEssQ0FBQUE7d0JBQ3hCRCxPQUFPQSxLQUFLaEcsTUFBTSxDQUFDK0YsdUJBQXVCRTtvQkFDOUM7Z0JBQ0o7Z0JBQ0EsT0FBT0Q7WUFDWDtZQUVBLE1BQU1FLHlCQUF5Qk4sbUJBQW1Cdk4sVUFBVXdMO1lBQzVELElBQUksQ0FBQ3FDLHdCQUF3QixNQUFNLElBQUlwQyxNQUFNO1lBRTdDLE1BQU1xQyx5QkFBeUJKLHVCQUF1Qkc7WUFDdEQsTUFBTUUsZ0JBQWdCRCx1QkFBdUIvTCxHQUFHLENBQUNMLENBQUFBLElBQUtBLEVBQUVhLEVBQUU7WUFFMUQsa0ZBQWtGO1lBQ2xGLEtBQUssTUFBTWIsS0FBS29NLHVCQUF3QjtnQkFDcEMsTUFBTSxFQUFFdkwsRUFBRSxFQUFFa0QsV0FBVyxFQUFFMUMsT0FBTyxFQUFFLEdBQUdpSyxhQUFhLEdBQUd0TDtnQkFDckQsTUFBTW9MLFVBQWU7b0JBQUUsR0FBR0UsV0FBVztvQkFBRXhLLE1BQU0sR0FBVSxPQUFQZCxFQUFFYyxJQUFJLEVBQUM7Z0JBQVM7Z0JBQ2hFLDhEQUE4RDtnQkFDOUQsTUFBTXJGLHVEQUFhQSxDQUFDMlA7WUFDeEI7WUFFQSxJQUFJaUIsY0FBY3hHLE1BQU0sR0FBRyxHQUFHO2dCQUMxQixrREFBa0Q7Z0JBQ2xELHdEQUF3RDtnQkFDeEQsS0FBSyxNQUFNeUcsU0FBU0QsY0FBZTtvQkFDL0IsTUFBTTdOLFFBQVEsTUFBTXRDLDhEQUFvQkEsQ0FBQzt3QkFBQ29RO3FCQUFNO29CQUNoRCxLQUFLLE1BQU05RixLQUFLaEksTUFBTzt3QkFDbkIsTUFBTStOLGVBQWVYLE1BQU14SCxHQUFHLENBQUNvQyxFQUFFc0QsU0FBUzt3QkFDMUMsSUFBSXlDLGNBQWM7NEJBQ2QsTUFBTSxFQUFFMUwsSUFBSTJMLEdBQUcsRUFBRSxHQUFHdEQsVUFBVSxHQUFHMUM7NEJBQ2pDLE1BQU01Syx1REFBYUEsQ0FBQztnQ0FBRSxHQUFHc04sUUFBUTtnQ0FBRVksV0FBV3lDOzRCQUFhO3dCQUMvRDtvQkFDSjtnQkFDSjtZQUNKO1lBRUEsTUFBTWpIO1FBRVYsRUFBRSxPQUFPSixPQUFPO1lBQ1pDLFFBQVFELEtBQUssQ0FBQyw4QkFBOEJBO1lBQzVDLE1BQU1JO1lBQ04sTUFBTUo7UUFDVjtJQUNKO0lBRUEsTUFBTXVILGdCQUFnQixPQUFPM0MsV0FBbUJySztRQUM1QyxJQUFJLENBQUNmLGFBQWEsTUFBTSxJQUFJcUwsTUFBTTtRQUVsQyxJQUFJO1lBQ0EsTUFBTTJDLHlCQUF5QixDQUFDQyxhQUF3QkM7Z0JBQ3BELElBQUk1RyxNQUFnQixFQUFFO2dCQUN0QixNQUFNNkcsaUJBQWlCLENBQUM5RyxPQUFrQitGO29CQUN0QyxLQUFLLE1BQU05TCxLQUFLK0YsTUFBTzt3QkFDbkIsSUFBSS9GLEVBQUVhLEVBQUUsS0FBS2lMLEtBQUs7NEJBQ2QsTUFBTWdCLFVBQVUsQ0FBQ3RCO2dDQUNieEYsSUFBSTNCLElBQUksQ0FBQ21ILEtBQUszSyxFQUFFO2dDQUNoQixJQUFJMkssS0FBS3pILFdBQVcsRUFBRTtvQ0FDbEJ5SCxLQUFLekgsV0FBVyxDQUFDekMsT0FBTyxDQUFDd0w7Z0NBQzdCOzRCQUNKOzRCQUNBQSxRQUFROU07NEJBQ1IsT0FBTzt3QkFDWDt3QkFDQSxJQUFJQSxFQUFFK0QsV0FBVyxFQUFFOzRCQUNmLElBQUk4SSxlQUFlN00sRUFBRStELFdBQVcsRUFBRStILE1BQU0sT0FBTzt3QkFDbkQ7b0JBQ0o7b0JBQ0EsT0FBTztnQkFDWDtnQkFFQWUsZUFBZUYsYUFBYUM7Z0JBQzVCLE9BQU81RztZQUNYO1lBRUEsTUFBTStHLHdCQUF3QkwsdUJBQXVCcE8sVUFBVXdMO1lBRS9ELGtEQUFrRDtZQUNsRHZMLFlBQVk2SyxDQUFBQTtnQkFDUixNQUFNNEQsZ0JBQWdCLENBQUMxTyxVQUFxQjJPO29CQUN4QyxPQUFPM08sU0FBU2dMLE1BQU0sQ0FBQ3RKLENBQUFBO3dCQUNuQixJQUFJQSxFQUFFYSxFQUFFLEtBQUtvTSxVQUFVLE9BQU87d0JBQzlCLElBQUlqTixFQUFFK0QsV0FBVyxFQUFFOzRCQUNmL0QsRUFBRStELFdBQVcsR0FBR2lKLGNBQWNoTixFQUFFK0QsV0FBVyxFQUFFa0o7d0JBQ2pEO3dCQUNBLE9BQU87b0JBQ1g7Z0JBQ0o7Z0JBRUEsSUFBSUMsa0JBQWtCOUQ7Z0JBQ3RCLEtBQUssTUFBTTBDLE9BQU9pQixzQkFBdUI7b0JBQ3JDRyxrQkFBa0JGLGNBQWNFLGlCQUFpQnBCO2dCQUNyRDtnQkFDQSxPQUFPb0I7WUFDWDtZQUVBLDJDQUEyQztZQUMzQ3pPLFNBQVMySyxDQUFBQSxPQUFRQSxLQUFLRSxNQUFNLENBQUM2RCxDQUFBQSxPQUFRLENBQUNKLHNCQUFzQnJFLFFBQVEsQ0FBQ3lFLEtBQUtyRCxTQUFTO1lBRW5GLDhCQUE4QjtZQUM5QixLQUFLLE1BQU1nQyxPQUFPaUIsc0JBQXVCO2dCQUNyQyxNQUFNcFIsMERBQWdCQSxDQUFDbVE7WUFDM0I7WUFFQSxNQUFNc0Isc0JBQXNCLElBQUlDLElBQUlOO1lBQ3BDLE1BQU1PLDBCQUEwQjttQkFBSUY7YUFBb0IsQ0FBQ0csSUFBSSxDQUFDMU0sQ0FBQUEsS0FBTXBCLFNBQVNpSixRQUFRLENBQUM3SDtZQUV0RixJQUFJeU0seUJBQXlCO2dCQUN6QjlOLE9BQU82RSxJQUFJLENBQUM7WUFDaEI7UUFFSixFQUFFLE9BQU9hLE9BQU87WUFDWkMsUUFBUUQsS0FBSyxDQUFDLHlCQUF5QkE7WUFDdkMsb0NBQW9DO1lBQ3BDLElBQUd4RyxZQUFZbUMsRUFBRSxFQUFFO2dCQUNmLE1BQU0yQyxVQUFVOUUsWUFBWW1DLEVBQUU7WUFDbEM7WUFDQSxNQUFNcUU7UUFDVjtJQUNKO0lBRUYsNEJBQTRCO0lBQzVCLE1BQU1zSSx1QkFBdUIsT0FBTzFELFdBQW1CdEksUUFBZ0JDO1FBQ3JFLElBQUksQ0FBQy9DLGFBQWEsTUFBTSxJQUFJcUwsTUFBTTtRQUNsQyxJQUFJO1lBQ0YsMkNBQTJDO1lBQzNDeEwsWUFBWTZLLENBQUFBO2dCQUNWLE1BQU1pQixnQkFBZ0IsQ0FBQy9MO29CQUNyQixPQUFPQSxTQUFTK0IsR0FBRyxDQUFDTCxDQUFBQTt3QkFDbEIsSUFBSUEsRUFBRWEsRUFBRSxLQUFLaUosV0FBVzs0QkFDdEIsT0FBTztnQ0FDTCxHQUFHOUosQ0FBQztnQ0FDSnFCLFNBQVM7b0NBQ1AsR0FBSXJCLEVBQUVxQixPQUFPLElBQUksQ0FBQyxDQUFDO29DQUNuQixDQUFDRyxPQUFPLEVBQUVDO2dDQUNaOzRCQUNGO3dCQUNGO3dCQUNBLElBQUl6QixFQUFFK0QsV0FBVyxFQUFFOzRCQUNqQixPQUFPO2dDQUFFLEdBQUcvRCxDQUFDO2dDQUFFK0QsYUFBYXNHLGNBQWNySyxFQUFFK0QsV0FBVzs0QkFBRTt3QkFDM0Q7d0JBQ0EsT0FBTy9EO29CQUNUO2dCQUNGO2dCQUNBLE9BQU9xSyxjQUFjakI7WUFDdkI7WUFFQSxNQUFNdk0sMERBQWdCQSxDQUFDaU4sV0FBV3RJLFFBQVFDO1FBQzVDLEVBQUUsT0FBT3lELE9BQU87WUFDZEMsUUFBUUQsS0FBSyxDQUFDLGdDQUFnQ0E7WUFDOUMsb0NBQW9DO1lBQ3BDLE1BQU0xQixVQUFVOUUsWUFBWW1DLEVBQUU7WUFDOUIsTUFBTXFFO1FBQ1I7SUFDRjtJQUVBLE1BQU11SSw4QkFBOEIsT0FBTzNELFdBQW1CdEksUUFBZ0JDO1FBQzVFLElBQUksQ0FBQy9DLGFBQWEsTUFBTSxJQUFJcUwsTUFBTTtRQUNsQyxJQUFJO1lBQ0YsbURBQW1EO1lBQ25EeEwsWUFBWTZLLENBQUFBO2dCQUNWLE1BQU1pQixnQkFBZ0IsQ0FBQy9MO29CQUNyQixPQUFPQSxTQUFTK0IsR0FBRyxDQUFDTCxDQUFBQTt3QkFDbEIsSUFBSUEsRUFBRWEsRUFBRSxLQUFLaUosYUFBYTlKLEVBQUVxQixPQUFPLEVBQUU7NEJBQ25DLE9BQU87Z0NBQ0wsR0FBR3JCLENBQUM7Z0NBQ0pxQixTQUFTO29DQUNQLEdBQUdyQixFQUFFcUIsT0FBTztvQ0FDWixDQUFDRyxPQUFPLEVBQUVDO2dDQUNaOzRCQUNGO3dCQUNGO3dCQUNBLElBQUl6QixFQUFFK0QsV0FBVyxFQUFFOzRCQUNqQixPQUFPO2dDQUFFLEdBQUcvRCxDQUFDO2dDQUFFK0QsYUFBYXNHLGNBQWNySyxFQUFFK0QsV0FBVzs0QkFBRTt3QkFDM0Q7d0JBQ0EsT0FBTy9EO29CQUNUO2dCQUNGO2dCQUNBLE9BQU9xSyxjQUFjakI7WUFDdkI7WUFFQSxNQUFNdE0saUVBQXVCQSxDQUFDZ04sV0FBV3RJLFFBQVFDO1FBQ25ELEVBQUUsT0FBT3lELE9BQU87WUFDZEMsUUFBUUQsS0FBSyxDQUFDLHVDQUF1Q0E7WUFDckQsb0NBQW9DO1lBQ3BDLE1BQU0xQixVQUFVOUUsWUFBWW1DLEVBQUU7WUFDOUIsTUFBTXFFO1FBQ1I7SUFDRjtJQUVBLE1BQU13SSwwQkFBMEIsT0FBTzVELFdBQW1CdEk7UUFDeEQsSUFBSSxDQUFDOUMsYUFBYSxNQUFNLElBQUlxTCxNQUFNO1FBQ2xDLElBQUk7WUFDRixnREFBZ0Q7WUFDaER4TCxZQUFZNkssQ0FBQUE7Z0JBQ1YsTUFBTWlCLGdCQUFnQixDQUFDL0w7b0JBQ3JCLE9BQU9BLFNBQVMrQixHQUFHLENBQUNMLENBQUFBO3dCQUNsQixJQUFJQSxFQUFFYSxFQUFFLEtBQUtpSixhQUFhOUosRUFBRXFCLE9BQU8sRUFBRTs0QkFDbkMsTUFBTXNNLGFBQWE7Z0NBQUUsR0FBRzNOLEVBQUVxQixPQUFPOzRCQUFDOzRCQUNsQyxPQUFPc00sVUFBVSxDQUFDbk0sT0FBTzs0QkFDekIsT0FBTztnQ0FDTCxHQUFHeEIsQ0FBQztnQ0FDSnFCLFNBQVNzTTs0QkFDWDt3QkFDRjt3QkFDQSxJQUFJM04sRUFBRStELFdBQVcsRUFBRTs0QkFDakIsT0FBTztnQ0FBRSxHQUFHL0QsQ0FBQztnQ0FBRStELGFBQWFzRyxjQUFjckssRUFBRStELFdBQVc7NEJBQUU7d0JBQzNEO3dCQUNBLE9BQU8vRDtvQkFDVDtnQkFDRjtnQkFDQSxPQUFPcUssY0FBY2pCO1lBQ3ZCO1lBRUEsTUFBTXJNLDZEQUFtQkEsQ0FBQytNLFdBQVd0STtRQUN2QyxFQUFFLE9BQU8wRCxPQUFPO1lBQ2RDLFFBQVFELEtBQUssQ0FBQyxrQ0FBa0NBO1lBQ2hELG9DQUFvQztZQUNwQyxNQUFNMUIsVUFBVTlFLFlBQVltQyxFQUFFO1lBQzlCLE1BQU1xRTtRQUNSO0lBQ0Y7SUFHQSxNQUFNMEksVUFBVSxPQUFPVDtRQUNyQixJQUFJLENBQUN6TyxhQUFhLE1BQU0sSUFBSXFMLE1BQU07UUFDbEMsSUFBSTtZQUNBLE1BQU05RyxPQUFZO2dCQUFFLEdBQUdrSyxJQUFJO1lBQUM7WUFFNUIseURBQXlEO1lBQ3pELElBQUlsSyxLQUFLbUMsTUFBTSxFQUFFO2dCQUNibkMsS0FBS3dELFFBQVEsR0FBR3hELEtBQUttQyxNQUFNO2dCQUMzQixPQUFPbkMsS0FBS21DLE1BQU07WUFDdEI7WUFFQSx5RkFBeUY7WUFDekZ5SSxPQUFPQyxJQUFJLENBQUM3SyxNQUFNM0IsT0FBTyxDQUFDeU0sQ0FBQUE7Z0JBQ3RCLElBQUk5SyxJQUFJLENBQUM4SyxFQUFFLEtBQUtoUSxhQUFha0YsSUFBSSxDQUFDOEssRUFBRSxLQUFLLFFBQVMsT0FBTzlLLElBQUksQ0FBQzhLLEVBQUUsS0FBSyxZQUFZOUssSUFBSSxDQUFDOEssRUFBRSxDQUFDcE4sSUFBSSxPQUFPLElBQUs7b0JBQ3JHLE9BQU9zQyxJQUFJLENBQUM4SyxFQUFFO2dCQUNsQjtZQUNKO1lBRUEsMEJBQTBCO1lBQzFCLE1BQU1DLFVBQVUsTUFBTXBTLHVEQUFhQSxDQUFDcUg7WUFFcEMsK0NBQStDO1lBQy9DLElBQUkrSyxXQUFXQSxRQUFRbEUsU0FBUyxFQUFFO2dCQUM5QnRNLHFFQUFvQkEsQ0FBQ3dRO1lBQ3pCO1lBRUEseUdBQXlHO1lBQ3pHLElBQUlBLFNBQVM7b0JBR0dBLGlCQUFBQSxNQUNJQSxxQkFDRkE7Z0JBSmQsTUFBTTdFLGlCQUFpQjtvQkFDbkIsR0FBRzZFLE9BQU87b0JBQ1Y1SSxRQUFRNEksQ0FBQUEsT0FBQUEsQ0FBQUEsa0JBQUFBLFFBQVE1SSxNQUFNLGNBQWQ0SSw2QkFBQUEsa0JBQWtCQSxRQUFRdkgsUUFBUSxjQUFsQ3VILGtCQUFBQSxPQUFzQztvQkFDOUNySCxZQUFZcUgsQ0FBQUEsc0JBQUFBLFFBQVFySCxVQUFVLGNBQWxCcUgsaUNBQUFBLHNCQUFzQmpRO29CQUNsQzZJLFVBQVVvSCxDQUFBQSxvQkFBQUEsUUFBUXBILFFBQVEsY0FBaEJvSCwrQkFBQUEsb0JBQW9CalE7Z0JBQ2xDO2dCQUVBVSxTQUFTMkssQ0FBQUE7b0JBQ0wsMkNBQTJDO29CQUMzQyxJQUFJQSxLQUFLdEgsSUFBSSxDQUFDMEUsQ0FBQUEsSUFBS0EsRUFBRTNGLEVBQUUsS0FBS3NJLGVBQWV0SSxFQUFFLEdBQUc7d0JBQzVDLE9BQU91STtvQkFDWDtvQkFDQSxPQUFPOzJCQUFJQTt3QkFBTUQ7cUJBQWU7Z0JBQ3BDO2dCQUVBLE9BQU9BO1lBQ1g7WUFFQSxNQUFNLElBQUlZLE1BQU07UUFFcEIsRUFBRSxPQUFPN0UsT0FBTztZQUNaQyxRQUFRRCxLQUFLLENBQUMsdUJBQXVCQTtZQUNyQyxNQUFNQTtRQUNWO0lBQ0Y7SUFFQSxNQUFNK0ksYUFBYSxPQUFPQztRQUN4QixJQUFJLENBQUN4UCxhQUFhLE1BQU0sSUFBSXFMLE1BQU07UUFFbEMsSUFBSTtZQUNBLE1BQU0sRUFBRWxKLEVBQUUsRUFBRSxHQUFHcUksVUFBVSxHQUFHZ0Y7WUFDNUIsTUFBTWpMLE9BQVk7Z0JBQUUsR0FBR2lHLFFBQVE7WUFBQztZQUNoQywwQkFBMEI7WUFDMUIyRSxPQUFPQyxJQUFJLENBQUM3SyxNQUFNM0IsT0FBTyxDQUFDeU0sQ0FBQUEsSUFBSzlLLElBQUksQ0FBQzhLLEVBQUUsS0FBS2hRLGFBQWEsT0FBT2tGLElBQUksQ0FBQzhLLEVBQUU7WUFFdEUsZ0RBQWdEO1lBQ2hELE9BQU85SyxLQUFLa0wsU0FBUztZQUNyQixPQUFPbEwsS0FBS21MLFNBQVM7WUFFckIsb0hBQW9IO1lBQ3BILDBGQUEwRjtZQUMxRixJQUFJbkwsS0FBS21DLE1BQU0sS0FBS3JILFdBQVc7Z0JBQzNCa0YsS0FBS3dELFFBQVEsR0FBR3hELEtBQUttQyxNQUFNO1lBQy9CO1lBQ0EsMERBQTBEO1lBQzFELE9BQU9uQyxLQUFLbUMsTUFBTTtnQkFNTm5DLGdCQUFBQTtZQUpaLDRGQUE0RjtZQUM1RixNQUFNb0wsYUFBYTtnQkFDZixHQUFHSCxXQUFXO2dCQUNkLHdEQUF3RDtnQkFDeEQ5SSxRQUFRbkMsQ0FBQUEsT0FBQUEsQ0FBQUEsaUJBQUFBLEtBQUt3RCxRQUFRLGNBQWJ4RCw0QkFBQUEsaUJBQWlCaUwsWUFBWTlJLE1BQU0sY0FBbkNuQyxrQkFBQUEsT0FBdUM7Z0JBQy9DMEQsWUFBWTFELEtBQUswRCxVQUFVLEtBQUs1SSxZQUFZa0YsS0FBSzBELFVBQVUsR0FBR3VILFlBQVl2SCxVQUFVO2dCQUNwRkMsVUFBVTNELEtBQUsyRCxRQUFRLEtBQUs3SSxZQUFZa0YsS0FBSzJELFFBQVEsR0FBR3NILFlBQVl0SCxRQUFRO1lBQ2hGO1lBRUEscUJBQXFCO1lBQ3JCbkksU0FBUzJLLENBQUFBLE9BQVFBLEtBQUsvSSxHQUFHLENBQUNtRyxDQUFBQSxJQUFLQSxFQUFFM0YsRUFBRSxLQUFLQSxLQUFLd04sYUFBYTdIO1lBRTFELDhCQUE4QjtZQUM5QjlJLHFFQUFvQkEsQ0FBQzJRO1lBRXJCLGtDQUFrQztZQUNsQyxNQUFNM0ksT0FBWSxNQUFNN0osdURBQWFBLENBQUNnRixJQUFJb0M7WUFFMUMsK0NBQStDO1lBQy9DekYscUVBQW9CQSxDQUFDNlE7Z0JBS1QzSSxjQUFBQSxPQUNJQSxrQkFDRkE7WUFMZCxpRkFBaUY7WUFDakYsTUFBTTRJLGFBQWE7Z0JBQ2YsR0FBRzVJLElBQUk7Z0JBQ1BOLFFBQVFNLENBQUFBLFFBQUFBLENBQUFBLGVBQUFBLEtBQUtOLE1BQU0sY0FBWE0sMEJBQUFBLGVBQWVBLEtBQUtlLFFBQVEsY0FBNUJmLG1CQUFBQSxRQUFnQztnQkFDeENpQixZQUFZakIsQ0FBQUEsbUJBQUFBLEtBQUtpQixVQUFVLGNBQWZqQiw4QkFBQUEsbUJBQW1CM0g7Z0JBQy9CNkksVUFBVWxCLENBQUFBLGlCQUFBQSxLQUFLa0IsUUFBUSxjQUFibEIsNEJBQUFBLGlCQUFpQjNIO1lBQy9CO1lBRUEsMENBQTBDO1lBQzFDVSxTQUFTMkssQ0FBQUEsT0FBUUEsS0FBSy9JLEdBQUcsQ0FBQ21HLENBQUFBLElBQUtBLEVBQUUzRixFQUFFLEtBQUt5TixXQUFXek4sRUFBRSxHQUFHeU4sYUFBYTlIO1FBRXpFLEVBQUUsT0FBT3RCLE9BQU87WUFDWkMsUUFBUUQsS0FBSyxDQUFDLHlCQUF5QkE7WUFDdkMsNkNBQTZDO1lBQzdDLElBQUlnSixZQUFZcEUsU0FBUyxFQUFFO2dCQUN2QnRNLHFFQUFvQkEsQ0FBQzBRO1lBQ3pCO1FBQ0o7SUFDRjtJQUVBLHlFQUF5RTtJQUN6RSxNQUFNSyxzQkFBc0JqVCxrREFBV0E7d0RBQUMsQ0FBQzRTO1lBQ3ZDLElBQUksQ0FBQ3hQLGFBQWE7WUFFbEIsd0JBQXdCO1lBQ3hCRDtnRUFBUzJLLENBQUFBLE9BQVFBLEtBQUsvSSxHQUFHO3dFQUFDbUcsQ0FBQUEsSUFBS0EsRUFBRTNGLEVBQUUsS0FBS3FOLFlBQVlyTixFQUFFLEdBQUdxTixjQUFjMUg7OztZQUV2RSwyQkFBMkI7WUFDM0I5RyxtQkFBbUJzSSxPQUFPLENBQUNsRSxHQUFHLENBQUNvSyxZQUFZck4sRUFBRSxFQUFFcU47WUFFL0MsdUNBQXVDO1lBQ3ZDLE1BQU1NLGtCQUFrQjdPLG1CQUFtQnFJLE9BQU8sQ0FBQzVELEdBQUcsQ0FBQzhKLFlBQVlyTixFQUFFO1lBQ3JFLElBQUkyTixpQkFBaUI7Z0JBQ25CQyxhQUFhRDtZQUNmO1lBRUEsNkJBQTZCO1lBQzdCLE1BQU1FLFVBQVVqRjt3RUFBVztvQkFDekIsTUFBTWtGLGVBQWVqUCxtQkFBbUJzSSxPQUFPLENBQUM1RCxHQUFHLENBQUM4SixZQUFZck4sRUFBRTtvQkFDbEUsSUFBSThOLGNBQWM7d0JBQ2hCLElBQUk7NEJBQ0YsTUFBTSxFQUFFOU4sRUFBRSxFQUFFLEdBQUdxSSxVQUFVLEdBQUd5Rjs0QkFDNUIsTUFBTTFMLE9BQVk7Z0NBQUUsR0FBR2lHLFFBQVE7NEJBQUM7NEJBQ2hDMkUsT0FBT0MsSUFBSSxDQUFDN0ssTUFBTTNCLE9BQU87d0ZBQUN5TSxDQUFBQSxJQUFLOUssSUFBSSxDQUFDOEssRUFBRSxLQUFLaFEsYUFBYSxPQUFPa0YsSUFBSSxDQUFDOEssRUFBRTs7NEJBRXRFLE9BQU85SyxLQUFLa0wsU0FBUzs0QkFDckIsT0FBT2xMLEtBQUttTCxTQUFTOzRCQUVyQixJQUFJbkwsS0FBS21DLE1BQU0sS0FBS3JILFdBQVc7Z0NBQzdCa0YsS0FBS3dELFFBQVEsR0FBR3hELEtBQUttQyxNQUFNOzRCQUM3Qjs0QkFDQSxPQUFPbkMsS0FBS21DLE1BQU07NEJBRWxCLE1BQU12Six1REFBYUEsQ0FBQ2dGLElBQUlvQzs0QkFFeEIsV0FBVzs0QkFDWHZELG1CQUFtQnNJLE9BQU8sQ0FBQzRHLE1BQU0sQ0FBQ1YsWUFBWXJOLEVBQUU7NEJBQ2hEbEIsbUJBQW1CcUksT0FBTyxDQUFDNEcsTUFBTSxDQUFDVixZQUFZck4sRUFBRTt3QkFDbEQsRUFBRSxPQUFPcUUsT0FBTzs0QkFDZEMsUUFBUUQsS0FBSyxDQUFDLG1DQUFtQ0E7NEJBQ2pELGtDQUFrQzs0QkFDbEMsSUFBSXhHLHdCQUFBQSxrQ0FBQUEsWUFBYW1DLEVBQUUsRUFBRSxNQUFNMkMsVUFBVTlFLFlBQVltQyxFQUFFO3dCQUNyRDtvQkFDRjtnQkFDRjt1RUFBRyxNQUFNLGlCQUFpQjtZQUUxQmxCLG1CQUFtQnFJLE9BQU8sQ0FBQ2xFLEdBQUcsQ0FBQ29LLFlBQVlyTixFQUFFLEVBQUU2TjtRQUNqRDt1REFBRztRQUFDaFE7S0FBWTtJQUVoQixNQUFNbVEsYUFBYSxPQUFPQztRQUN4QixJQUFJLENBQUNwUSxhQUFhLE1BQU0sSUFBSXFMLE1BQU07UUFFbEMsSUFBSTtZQUNBLGtEQUFrRDtZQUNsRHRMLFNBQVMySyxDQUFBQSxPQUFRQSxLQUFLRSxNQUFNLENBQUM5QyxDQUFBQSxJQUFLQSxFQUFFM0YsRUFBRSxLQUFLaU87WUFFM0MsMEJBQTBCO1lBQzFCLE1BQU1oVCx1REFBYUEsQ0FBQ2dUO1FBQ3hCLEVBQUUsT0FBTzVKLE9BQU87WUFDWkMsUUFBUUQsS0FBSyxDQUFDLHlCQUF5QkE7WUFDdkMsc0RBQXNEO1lBQ3RELElBQUl4Ryx3QkFBQUEsa0NBQUFBLFlBQWFtQyxFQUFFLEVBQUUsTUFBTTJDLFVBQVU5RSxZQUFZbUMsRUFBRTtZQUNuRCxNQUFNcUU7UUFDVjtJQUNGO0lBRUEsTUFBTTZKLGFBQWEsT0FBT3ZOLFFBQWdCd047UUFDeEMsSUFBSSxDQUFDdFEsYUFBYSxNQUFNLElBQUlxTCxNQUFNO1FBQzlCLElBQUk7WUFDQSxNQUFNckUsT0FBWSxNQUFNOUksdURBQWFBLENBQUM0RSxRQUFRO2dCQUFFVixNQUFNa08sU0FBU2xPLElBQUk7Z0JBQUUySixPQUFPdUUsU0FBU3ZFLEtBQUs7WUFBQztZQUMzRixNQUFNYyxVQUFVN0YsQ0FBQUEsaUJBQUFBLDJCQUFBQSxLQUFNQyxJQUFJLEtBQUk7Z0JBQUU5RSxJQUFJVztnQkFBUSxHQUFHd04sUUFBUTtZQUFDO1lBRXhENVEsU0FBUzZRLENBQUFBO2dCQUNMLE1BQU1DLFdBQVcsSUFBSTdRLElBQUk0UTtnQkFDekIsSUFBSUMsU0FBU0MsR0FBRyxDQUFDM04sU0FBUztvQkFDdEIsTUFBTTROLGVBQWVGLFNBQVM5SyxHQUFHLENBQUM1QztvQkFDbEMwTixTQUFTcEwsR0FBRyxDQUFDdEMsUUFBUTt3QkFBRSxHQUFHNE4sWUFBWTt3QkFBRSxHQUFHN0QsT0FBTztvQkFBQztnQkFDdkQ7Z0JBQ0EsT0FBTzJEO1lBQ1g7WUFFQSxJQUFJeFEsWUFBWW1DLEVBQUUsS0FBS1csUUFBUTtnQkFDM0I3QyxlQUFleUssQ0FBQUEsT0FBUUEsT0FBTzt3QkFBRSxHQUFHQSxJQUFJO3dCQUFFLEdBQUdtQyxPQUFPO29CQUFDLElBQUk7WUFDNUQ7UUFDSixFQUFFLE9BQU9yRyxPQUFPO1lBQ1pDLFFBQVFELEtBQUssQ0FBQyx3QkFBd0JBO1lBQ3RDLE1BQU1BO1FBQ1Y7SUFDTjtJQUVFLE1BQU1tSyxhQUFhLE9BQU8xSixNQUF3QitFO1FBQzlDLE1BQU1oRixPQUFPLE1BQU10SixvREFBVUEsQ0FBQ3VKLEtBQUs3RSxJQUFJLEVBQUU2RSxLQUFLOEUsS0FBSyxFQUFFQztRQUVyRCwyQ0FBMkM7UUFDM0MsSUFBSWhGLFFBQVEsYUFBYUEsUUFBUUEsS0FBS2lGLE9BQU8sS0FBSyxTQUFTakYsS0FBS2tGLFVBQVUsRUFBRTtZQUN4RTVNLE9BQU8yRyxLQUFLLENBQUMsb0NBQW9DO2dCQUM3QzhGLE9BQU85RSxLQUFLOEUsS0FBSztnQkFDakJ4QixRQUFRO2dCQUNSNEIsV0FBVztZQUNmO1lBQ0Esd0VBQXdFO1lBQ3hFLE1BQU0zRixRQUFRO2dCQUNWNkYsU0FBU3JGLEtBQUtSLEtBQUs7Z0JBQ25CRSxRQUFRTSxLQUFLTixNQUFNO2dCQUNuQndGLFlBQVk7WUFDaEI7WUFDQSxNQUFNMUY7UUFDVjtRQUVBLE1BQU1xRixVQUFVN0UsaUJBQUFBLDJCQUFBQSxLQUFNQyxJQUFJO1FBQzFCLElBQUk0RSxTQUFTO1lBQ1QscUNBQXFDO1lBQ3JDbk0sU0FBU2dMLENBQUFBO2dCQUNMLE1BQU04RixXQUFXLElBQUk3USxJQUFJK0s7Z0JBQ3pCOEYsU0FBU3BMLEdBQUcsQ0FBQ3lHLFFBQVExSixFQUFFLEVBQUUwSjtnQkFDekIsT0FBTzJFO1lBQ1g7WUFDQXZRLGVBQWU0TDtZQUNmLE1BQU0vRyxVQUFVK0csUUFBUTFKLEVBQUU7UUFDOUI7SUFDSjtJQUVBLE1BQU15Tyx1QkFBdUIsT0FBT3hGLFdBQW1CMUU7UUFDbkQsSUFBSSxDQUFDMUcsYUFBYSxNQUFNLElBQUlxTCxNQUFNO1FBRWxDLElBQUk7WUFDQSxnREFBZ0Q7WUFDaEQsTUFBTXdGLFNBQVMsUUFBbUIsT0FBWHBGLEtBQUtDLEdBQUc7WUFDL0IsTUFBTW9GLG1CQUFtQixDQUFDO2dCQUN0QixNQUFNdkwsVUFBVTNGLFNBQVN3RCxJQUFJLENBQUM5QixDQUFBQSxJQUFLQSxFQUFFYSxFQUFFLEtBQUtpSjtnQkFDNUMsT0FBTzdGLENBQUFBLG9CQUFBQSw4QkFBQUEsUUFBU2hFLGlCQUFpQixLQUFJLEVBQUU7WUFDM0M7WUFDQSxNQUFNd1AsV0FBV0QsaUJBQWlCM0osTUFBTTtZQUV4QyxrQ0FBa0M7WUFDbEMsTUFBTTZKLG1CQUFxQztnQkFDdkM3TyxJQUFJME87Z0JBQ0p6TyxNQUFNLE9BQWdCQSxJQUFJLElBQUksT0FBZ0JQLEtBQUssSUFBSTtnQkFDdkRRLE9BQU8sT0FBZ0JBLEtBQUssSUFBSTtnQkFDaENDLE9BQU95TztnQkFDUHhPLG1CQUFtQixPQUFnQkEsaUJBQWlCLElBQUk7Z0JBQ3hEQyxRQUFRLE9BQWdCQSxNQUFNLElBQUk7Z0JBQ2xDQyxpQkFBaUIsT0FBZ0JBLGVBQWUsSUFBSTtnQkFDcERDLGVBQWUsT0FBZ0JBLGFBQWEsS0FBSztZQUNyRDtZQUVBLCtDQUErQztZQUMvQzdDLFlBQVk2SyxDQUFBQTtnQkFDUixNQUFNaUIsZ0JBQWdCLENBQUMvTDtvQkFDbkIsT0FBT0EsU0FBUytCLEdBQUcsQ0FBQ0wsQ0FBQUE7d0JBQ2hCLElBQUlBLEVBQUVhLEVBQUUsS0FBS2lKLFdBQVc7NEJBQ3BCLE9BQU87Z0NBQ0gsR0FBRzlKLENBQUM7Z0NBQ0pDLG1CQUFtQjt1Q0FBS0QsRUFBRUMsaUJBQWlCLElBQUksRUFBRTtvQ0FBR3lQO2lDQUFpQjs0QkFDekU7d0JBQ0o7d0JBQ0EsSUFBSTFQLEVBQUUrRCxXQUFXLEVBQUU7NEJBQ2YsT0FBTztnQ0FBRSxHQUFHL0QsQ0FBQztnQ0FBRStELGFBQWFzRyxjQUFjckssRUFBRStELFdBQVc7NEJBQUU7d0JBQzdEO3dCQUNBLE9BQU8vRDtvQkFDWDtnQkFDSjtnQkFDQSxPQUFPcUssY0FBY2pCO1lBQ3pCO1lBRUEsNEJBQTRCO1lBQzVCLE1BQU11RyxnQkFBZ0IsTUFBTW5ULDZEQUFtQkEsQ0FBQ3NOLFdBQVc7Z0JBQ3ZEdkosT0FBT21QLGlCQUFpQjVPLElBQUk7Z0JBQzVCQyxPQUFPMk8saUJBQWlCM08sS0FBSztnQkFDN0JDLE9BQU95TztnQkFDUHhPLG1CQUFtQnlPLGlCQUFpQnpPLGlCQUFpQjtnQkFDckRDLFFBQVF3TyxpQkFBaUJ4TyxNQUFNO2dCQUMvQkMsaUJBQWlCdU8saUJBQWlCdk8sZUFBZTtnQkFDakRDLGVBQWVzTyxpQkFBaUJ0TyxhQUFhO1lBQ2pEO1lBRUEsb0NBQW9DO1lBQ3BDN0MsWUFBWTZLLENBQUFBO2dCQUNSLE1BQU1pQixnQkFBZ0IsQ0FBQy9MO29CQUNuQixPQUFPQSxTQUFTK0IsR0FBRyxDQUFDTCxDQUFBQTt3QkFDaEIsSUFBSUEsRUFBRWEsRUFBRSxLQUFLaUosYUFBYTlKLEVBQUVDLGlCQUFpQixFQUFFOzRCQUMzQyxPQUFPO2dDQUNILEdBQUdELENBQUM7Z0NBQ0pDLG1CQUFtQkQsRUFBRUMsaUJBQWlCLENBQUNJLEdBQUcsQ0FBQ0MsQ0FBQUEsSUFDdkNBLEVBQUVPLEVBQUUsS0FBSzBPLFNBQVM7d0NBQUUsR0FBR0ksYUFBYTt3Q0FBRTdPLE1BQU02TyxjQUFjcFAsS0FBSyxJQUFJb1AsY0FBYzdPLElBQUk7b0NBQUMsSUFBSVI7NEJBRWxHO3dCQUNKO3dCQUNBLElBQUlOLEVBQUUrRCxXQUFXLEVBQUU7NEJBQ2YsT0FBTztnQ0FBRSxHQUFHL0QsQ0FBQztnQ0FBRStELGFBQWFzRyxjQUFjckssRUFBRStELFdBQVc7NEJBQUU7d0JBQzdEO3dCQUNBLE9BQU8vRDtvQkFDWDtnQkFDSjtnQkFDQSxPQUFPcUssY0FBY2pCO1lBQ3pCO1FBQ0osRUFBRSxPQUFPbEUsT0FBTztZQUNaQyxRQUFRRCxLQUFLLENBQUMscUNBQXFDQTtZQUNuRCxvQ0FBb0M7WUFDcEMsSUFBSXhHLHdCQUFBQSxrQ0FBQUEsWUFBYW1DLEVBQUUsRUFBRSxNQUFNMkMsVUFBVTlFLFlBQVltQyxFQUFFO1lBQ25ELE1BQU1xRTtRQUNWO0lBQ0o7SUFFQSxNQUFNMEssMEJBQTBCLE9BQU85RixXQUFtQnJELFVBQWtCb0o7UUFDeEUsSUFBSSxDQUFDblIsYUFBYSxNQUFNLElBQUlxTCxNQUFNO1FBRWxDLElBQUk7WUFDQSwwREFBMEQ7WUFDMUR4TCxZQUFZNkssQ0FBQUE7Z0JBQ1IsTUFBTWlCLGdCQUFnQixDQUFDL0w7b0JBQ25CLE9BQU9BLFNBQVMrQixHQUFHLENBQUNMLENBQUFBO3dCQUNoQixJQUFJQSxFQUFFYSxFQUFFLEtBQUtpSixhQUFhOUosRUFBRUMsaUJBQWlCLEVBQUU7NEJBQzNDLE9BQU87Z0NBQ0gsR0FBR0QsQ0FBQztnQ0FDSkMsbUJBQW1CRCxFQUFFQyxpQkFBaUIsQ0FBQ0ksR0FBRyxDQUFDQyxDQUFBQSxJQUN2Q0EsRUFBRU8sRUFBRSxLQUFLNEYsV0FBVzt3Q0FBRSxHQUFHbkcsQ0FBQzt3Q0FBRSxHQUFHdVAsVUFBVTtvQ0FBQyxJQUFJdlA7NEJBRXREO3dCQUNKO3dCQUNBLElBQUlOLEVBQUUrRCxXQUFXLEVBQUU7NEJBQ2YsT0FBTztnQ0FBRSxHQUFHL0QsQ0FBQztnQ0FBRStELGFBQWFzRyxjQUFjckssRUFBRStELFdBQVc7NEJBQUU7d0JBQzdEO3dCQUNBLE9BQU8vRDtvQkFDWDtnQkFDSjtnQkFDQSxPQUFPcUssY0FBY2pCO1lBQ3pCO1lBRUEsNEJBQTRCO1lBQzVCLE1BQU0zTSw2REFBbUJBLENBQUNxTixXQUFXckQsVUFBVTtnQkFDM0NsRyxPQUFPLFdBQW9CTyxJQUFJLElBQUksV0FBb0JQLEtBQUs7Z0JBQzVEUyxPQUFPLFdBQW9CQSxLQUFLO2dCQUNoQ0QsT0FBTyxXQUFvQkEsS0FBSztnQkFDaENFLG1CQUFtQixXQUFvQkEsaUJBQWlCO2dCQUN4REMsUUFBUSxXQUFvQkEsTUFBTTtnQkFDbENDLGlCQUFpQixXQUFvQkEsZUFBZTtnQkFDcERDLGVBQWUsV0FBb0JBLGFBQWE7WUFDcEQ7UUFDSixFQUFFLE9BQU84RCxPQUFPO1lBQ1pDLFFBQVFELEtBQUssQ0FBQyx1Q0FBdUNBO1lBQ3JELG9DQUFvQztZQUNwQyxJQUFJeEcsd0JBQUFBLGtDQUFBQSxZQUFhbUMsRUFBRSxFQUFFLE1BQU0yQyxVQUFVOUUsWUFBWW1DLEVBQUU7WUFDbkQsTUFBTXFFO1FBQ1Y7SUFDSjtJQUVBLE1BQU00SywwQkFBMEIsT0FBT2hHLFdBQW1CckQ7UUFDdEQsSUFBSSxDQUFDL0gsYUFBYSxNQUFNLElBQUlxTCxNQUFNO1FBRWxDLElBQUk7WUFDQSxvREFBb0Q7WUFDcER4TCxZQUFZNkssQ0FBQUE7Z0JBQ1IsTUFBTWlCLGdCQUFnQixDQUFDL0w7b0JBQ25CLE9BQU9BLFNBQVMrQixHQUFHLENBQUNMLENBQUFBO3dCQUNoQixJQUFJQSxFQUFFYSxFQUFFLEtBQUtpSixhQUFhOUosRUFBRUMsaUJBQWlCLEVBQUU7NEJBQzNDLE9BQU87Z0NBQ0gsR0FBR0QsQ0FBQztnQ0FDSkMsbUJBQW1CRCxFQUFFQyxpQkFBaUIsQ0FBQ3FKLE1BQU0sQ0FBQ2hKLENBQUFBLElBQUtBLEVBQUVPLEVBQUUsS0FBSzRGOzRCQUNoRTt3QkFDSjt3QkFDQSxJQUFJekcsRUFBRStELFdBQVcsRUFBRTs0QkFDZixPQUFPO2dDQUFFLEdBQUcvRCxDQUFDO2dDQUFFK0QsYUFBYXNHLGNBQWNySyxFQUFFK0QsV0FBVzs0QkFBRTt3QkFDN0Q7d0JBQ0EsT0FBTy9EO29CQUNYO2dCQUNKO2dCQUNBLE9BQU9xSyxjQUFjakI7WUFDekI7WUFFQSw0QkFBNEI7WUFDNUIsTUFBTTFNLDZEQUFtQkEsQ0FBQ29OLFdBQVdyRDtRQUN6QyxFQUFFLE9BQU92QixPQUFPO1lBQ1pDLFFBQVFELEtBQUssQ0FBQyx1Q0FBdUNBO1lBQ3JELG9DQUFvQztZQUNwQyxJQUFJeEcsd0JBQUFBLGtDQUFBQSxZQUFhbUMsRUFBRSxFQUFFLE1BQU0yQyxVQUFVOUUsWUFBWW1DLEVBQUU7WUFDbkQsTUFBTXFFO1FBQ1Y7SUFDSjtJQUVBLE1BQU02SywrQkFBK0IsT0FBT2pHLFdBQW1CMUo7UUFDM0QsSUFBSSxDQUFDMUIsYUFBYSxNQUFNLElBQUlxTCxNQUFNO1FBRWxDLElBQUk7WUFDQSxpREFBaUQ7WUFDakR4TCxZQUFZNkssQ0FBQUE7Z0JBQ1IsTUFBTWlCLGdCQUFnQixDQUFDL0w7b0JBQ25CLE9BQU9BLFNBQVMrQixHQUFHLENBQUNMLENBQUFBO3dCQUNoQixJQUFJQSxFQUFFYSxFQUFFLEtBQUtpSixhQUFhOUosRUFBRUMsaUJBQWlCLEVBQUU7NEJBQzNDLDhDQUE4Qzs0QkFDOUMsTUFBTStQLFdBQVcsSUFBSTNSLElBQUkrQixTQUFTQyxHQUFHLENBQUNDLENBQUFBLElBQUs7b0NBQUNBLEVBQUVPLEVBQUU7b0NBQUVQLEVBQUVVLEtBQUs7aUNBQUM7NEJBQzFELE9BQU87Z0NBQ0gsR0FBR2hCLENBQUM7Z0NBQ0pDLG1CQUFtQkQsRUFBRUMsaUJBQWlCLENBQ2pDSSxHQUFHLENBQUNDLENBQUFBO3dDQUFxQjBQOzJDQUFmO3dDQUFFLEdBQUcxUCxDQUFDO3dDQUFFVSxPQUFPZ1AsQ0FBQUEsZ0JBQUFBLFNBQVM1TCxHQUFHLENBQUM5RCxFQUFFTyxFQUFFLGVBQWpCbVAsMkJBQUFBLGdCQUFzQjFQLEVBQUVVLEtBQUs7b0NBQUM7bUNBQ3ZEaVAsSUFBSSxDQUFDLENBQUNDLEdBQUdDLElBQU1ELEVBQUVsUCxLQUFLLEdBQUdtUCxFQUFFblAsS0FBSzs0QkFDekM7d0JBQ0o7d0JBQ0EsSUFBSWhCLEVBQUUrRCxXQUFXLEVBQUU7NEJBQ2YsT0FBTztnQ0FBRSxHQUFHL0QsQ0FBQztnQ0FBRStELGFBQWFzRyxjQUFjckssRUFBRStELFdBQVc7NEJBQUU7d0JBQzdEO3dCQUNBLE9BQU8vRDtvQkFDWDtnQkFDSjtnQkFDQSxPQUFPcUssY0FBY2pCO1lBQ3pCO1lBRUEsMkJBQTJCO1lBQzNCLE1BQU1nQyxVQUFVaEwsU0FBU0MsR0FBRyxDQUFDQyxDQUFBQSxJQUFNO29CQUFFTyxJQUFJUCxFQUFFTyxFQUFFO29CQUFFRyxPQUFPVixFQUFFVSxLQUFLO2dCQUFDO1lBQzlELE1BQU1yRSxvRUFBMEJBLENBQUNtTixXQUFXc0I7UUFDaEQsRUFBRSxPQUFPbEcsT0FBTztZQUNaQyxRQUFRRCxLQUFLLENBQUMsNkNBQTZDQTtZQUMzRCxvQ0FBb0M7WUFDcEMsSUFBSXhHLHdCQUFBQSxrQ0FBQUEsWUFBYW1DLEVBQUUsRUFBRSxNQUFNMkMsVUFBVTlFLFlBQVltQyxFQUFFO1lBQ25ELE1BQU1xRTtRQUNWO0lBQ0o7SUFHQSxNQUFNa0wsaUJBQWlCLE9BQU9DLGlCQUF5QkM7UUFDbkQsSUFBSTtZQUNBLE1BQU0vVCw0REFBa0JBLENBQUM4VCxpQkFBaUJDO1FBQzlDLEVBQUUsT0FBT3BMLE9BQU87WUFDWkMsUUFBUUQsS0FBSyxDQUFDLDRCQUE0QkE7WUFDMUMsTUFBTUE7UUFDVjtJQUNKO0lBRUYsTUFBTXFMLGtCQUFrQixPQUFPOUY7UUFDN0Isd0RBQXdEO1FBQ3hELE1BQU1zQixRQUFRN0wsTUFBTXNRLElBQUksQ0FBQ3JTLE1BQU1zUyxNQUFNLElBQUkzTyxJQUFJLENBQUMyQyxDQUFBQSxJQUFLQSxFQUFFZ0csS0FBSyxLQUFLQTtRQUMvRCxJQUFJc0IsT0FBTyxPQUFPQTtRQUNsQixJQUFJO1lBQ0EsTUFBTS9FLE1BQU0sTUFBTS9LLGtEQUFRQTtZQUMxQixNQUFNd1AsTUFBT3pFLE9BQU8sRUFBRTtZQUN0QixNQUFNMEosUUFBUWpGLElBQUkzSixJQUFJLENBQUMyQyxDQUFBQSxJQUFLQSxFQUFFZ0csS0FBSyxLQUFLQSxVQUFVO1lBQ2xELE9BQU9pRztRQUNYLEVBQUUsT0FBTzlLLEtBQUs7WUFDVlQsUUFBUUQsS0FBSyxDQUFDLDRDQUE0Q1U7WUFDMUQsT0FBTztRQUNYO0lBQ0Y7SUFFQSxNQUFNK0ssd0JBQXdCLE9BQU9DO1FBQ25DLHdEQUF3RDtRQUN4RCxNQUFNN0UsUUFBUTdMLE1BQU1zUSxJQUFJLENBQUNyUyxNQUFNc1MsTUFBTSxJQUFJM08sSUFBSSxDQUFDMkMsQ0FBQUEsSUFBS0EsRUFBRWdHLEtBQUssS0FBS21HLFNBQVNuTSxFQUFFM0QsSUFBSSxLQUFLOFA7UUFDbkYsSUFBSTdFLE9BQU8sT0FBT0E7UUFDbEIsSUFBSTtZQUNBLE1BQU0vRSxNQUFNLE1BQU0vSyxrREFBUUE7WUFDMUIsTUFBTXdQLE1BQU96RSxPQUFPLEVBQUU7WUFDdEIsTUFBTTBKLFFBQVFqRixJQUFJM0osSUFBSSxDQUFDMkMsQ0FBQUEsSUFBS0EsRUFBRWdHLEtBQUssS0FBS21HLFNBQVNuTSxFQUFFM0QsSUFBSSxLQUFLOFAsVUFBVTtZQUN0RSxPQUFPRjtRQUNYLEVBQUUsT0FBTzlLLEtBQUs7WUFDVlQsUUFBUUQsS0FBSyxDQUFDLG9EQUFvRFU7WUFDbEUsT0FBTztRQUNYO0lBQ0Y7SUFFQSxNQUFNaUwsZUFBZXJWLDhDQUFPQTs2Q0FBQyxJQUFPO2dCQUNsQzJDO2dCQUFPRztnQkFBVUU7Z0JBQU9JO2dCQUFTRjtnQkFDakM4TDtnQkFBT1M7Z0JBQVFDO2dCQUFZYjtnQkFBZXRPO2dCQUFZNFA7Z0JBQ3REOU8sa0JBQWtCMlE7Z0JBQXNCMVEseUJBQXlCMlE7Z0JBQTZCMVEscUJBQXFCMlE7Z0JBQ25IRTtnQkFBU0s7Z0JBQVlNO2dCQUFxQk07Z0JBQVlFO2dCQUFZTTtnQkFBWWU7Z0JBQWdCRztnQkFBaUJJO2dCQUMvR2xFO2dCQUFlM047Z0JBQ2Z1RTtnQkFBb0JyRTtnQkFBd0J3RDtnQkFDNUN0RDtnQkFBYXlEO2dCQUNidkQ7Z0JBQWEwRDtnQkFDYnhEO2dCQUFlMEQ7Z0JBQ2ZzTTtnQkFBc0JNO2dCQUF5QkU7Z0JBQXlCQztnQkFBOEJsRztZQUN4Rzs0Q0FBSTtRQUNGMUw7UUFBT0c7UUFBVUU7UUFBT0k7UUFBU0Y7UUFDakM4TDtRQUFPUztRQUFRQztRQUFZYjtRQUFldE87UUFBWTRQO1FBQ3RENkI7UUFBc0JDO1FBQTZCQztRQUNuREU7UUFBU0s7UUFBWU07UUFBcUJNO1FBQVlFO1FBQVlNO1FBQVllO1FBQWdCRztRQUFpQkk7UUFDL0dsRTtRQUFlM047UUFDZnVFO1FBQW9CckU7UUFBd0J3RDtRQUM1Q3REO1FBQWF5RDtRQUNidkQ7UUFBYTBEO1FBQ2J4RDtRQUFlMEQ7UUFDZnNNO1FBQXNCTTtRQUF5QkU7UUFBeUJDO1FBQThCbEc7S0FDdkc7SUFFRCxxQkFDRSw4REFBQy9MLFdBQVdnVCxRQUFRO1FBQUNDLE9BQU9GO2tCQUN6QjNTOzs7Ozs7QUFHUDtHQXorQ2dCRDs7UUFXQ2pCLHNEQUFTQTtRQUNQQyx3REFBV0E7OztLQVpkZ0I7QUEyK0NULFNBQVMrUzs7SUFDZCxNQUFNQyxVQUFVOVYsaURBQVVBLENBQUMyQztJQUMzQixJQUFJbVQsWUFBWWxULFdBQVc7UUFDekIsTUFBTSxJQUFJZ00sTUFBTTtJQUNsQjtJQUNBLE9BQU9rSDtBQUNUO0lBTmdCRCIsInNvdXJjZXMiOlsiL2hvbWUvY29kZXIvT3JjaGVQbGFuL2Zyb250ZW5kL3NyYy9jb250ZXh0L2FwcC1jb250ZXh0LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIgJ3VzZSBjbGllbnQnO1xuXG5pbXBvcnQgUmVhY3QsIHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgdXNlU3RhdGUsIHVzZUVmZmVjdCwgUmVhY3ROb2RlLCB1c2VDYWxsYmFjaywgdXNlUmVmLCB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgY3JlYXRlUHJvamVjdCwgdXBkYXRlUHJvamVjdEFwaSwgZGVsZXRlUHJvamVjdEFwaSwgY3JlYXRlVGFza0FwaSwgdXBkYXRlVGFza0FwaSwgZGVsZXRlVGFza0FwaSwgZ2V0UHJvamVjdCBhcyBhcGlHZXRQcm9qZWN0LCBnZXRQcm9qZWN0cywgZ2V0VXNlcnMsIGdldFRhc2tzQnlQcm9qZWN0SWRzLCBhdXRoTG9naW4sIGF1dGhTaWdudXAsIGF1dGhMb2dvdXQsIGF1dGhNZSwgYXV0aENoYW5nZVBhc3N3b3JkLCBnZXRQcm9qZWN0U3RhdHVzZXMsIGNyZWF0ZVByb2plY3RTdGF0dXMsIHVwZGF0ZVByb2plY3RTdGF0dXMsIGRlbGV0ZVByb2plY3RTdGF0dXMsIHVwZGF0ZVByb2plY3RTdGF0dXNlc09yZGVyLCB1cGRhdGVVc2VyQXBpLCBhZGRQcm9qZWN0TWVtYmVyLCB1cGRhdGVQcm9qZWN0TWVtYmVyUm9sZSwgcmVtb3ZlUHJvamVjdE1lbWJlciB9IGZyb20gJ0AvbGliL2FwaSc7XG5pbXBvcnQgeyBVc2VyLCBQcm9qZWN0LCBUYXNrLCBUYXNrU3RhdHVzT3B0aW9uLCBQcm9qZWN0Um9sZSB9IGZyb20gJ0AvbGliL3R5cGVzJztcbmltcG9ydCB7IHVzZVJvdXRlciwgdXNlUGF0aG5hbWUgfSBmcm9tICduZXh0L25hdmlnYXRpb24nO1xuaW1wb3J0IFJlYWx0aW1lQ2xpZW50IGZyb20gJy4uL2xpYi9yZWFsdGltZSc7XG5pbXBvcnQgeyBjcmVhdGVDb21wb25lbnRMb2dnZXIgfSBmcm9tICdAL2xpYi9sb2dnZXInO1xuaW1wb3J0IHsgXG4gIGdldENhY2hlZFByb2plY3RzLCBcbiAgZ2V0Q2FjaGVkVXNlcnMsIFxuICBnZXRDYWNoZWRUYXNrc0J5UHJvamVjdElkcyxcbiAgaW52YWxpZGF0ZVByb2plY3RDYWNoZXMsXG4gIGludmFsaWRhdGVUYXNrQ2FjaGVzLFxuICBpbnZhbGlkYXRlQWxsUHJvamVjdENhY2hlcyxcbiAgb3B0aW1pc3RpY1VwZGF0ZVRhc2ssXG4gIG9wdGltaXN0aWNVcGRhdGVQcm9qZWN0LFxuICBjbGVhckFsbENhY2hlcyxcbiAgcHJlZmV0Y2hQcm9qZWN0RGF0YSxcbiAgZ2V0Q2FjaGVTdGF0cyxcbn0gZnJvbSAnQC9saWIvY2FjaGVkLWFwaSc7XG5cbmludGVyZmFjZSBBcHBDb250ZXh0VHlwZSB7XG4gIHVzZXJzOiBNYXA8c3RyaW5nLCBVc2VyPjtcbiAgcHJvamVjdHM6IFByb2plY3RbXTtcbiAgdGFza3M6IFRhc2tbXTtcbiAgY3VycmVudFVzZXI6IFVzZXIgfCBudWxsO1xuICBsb2FkaW5nOiBib29sZWFuO1xuICBpc0thbmJhbkhlYWRlclZpc2libGU6IGJvb2xlYW47XG4gIGlzU2lkZWJhck9wZW5CeURlZmF1bHQ6IGJvb2xlYW47XG4gICAgY2FyZERlbnNpdHk6ICdjb21mb3J0YWJsZScgfCAnY29tcGFjdCc7XG4gICAgc2V0Q2FyZERlbnNpdHk6IChkOiAnY29tZm9ydGFibGUnIHwgJ2NvbXBhY3QnKSA9PiB2b2lkO1xuICB0b2dnbGVTaWRlYmFyRGVmYXVsdDogKCkgPT4gdm9pZDtcbiAgdG9nZ2xlS2FuYmFuSGVhZGVyOiAoKSA9PiB2b2lkO1xuICAgIGRlZmF1bHRWaWV3OiAnYm9hcmQnIHwgJ2xpc3QnO1xuICAgIHNldERlZmF1bHRWaWV3OiAodjogJ2JvYXJkJyB8ICdsaXN0JykgPT4gdm9pZDtcbiAgICBncm91cEJ5U3RhdHVzOiBib29sZWFuO1xuICAgIHNldEdyb3VwQnlTdGF0dXM6ICh2OiBib29sZWFuKSA9PiB2b2lkO1xuICBsb2dpbjogKGVtYWlsOiBzdHJpbmcsIHBhc3N3b3JkOiBzdHJpbmcpID0+IFByb21pc2U8eyBzdWNjZXNzOiBib29sZWFuOyBlcnJvcj86IHN0cmluZyB9PjtcbiAgbG9nb3V0OiAoKSA9PiBQcm9taXNlPHZvaWQ+O1xuICBhZGRQcm9qZWN0OiAocHJvamVjdDogT21pdDxQcm9qZWN0LCAnaWQnIHwgJ3N1YlByb2plY3RzJz4pID0+IFByb21pc2U8dm9pZD47XG4gIHVwZGF0ZVByb2plY3Q6IChwcm9qZWN0SWQ6IHN0cmluZywgcHJvamVjdERhdGE6IFBhcnRpYWw8T21pdDxQcm9qZWN0LCAnaWQnIHwgJ3N1YlByb2plY3RzJz4+KSA9PiBQcm9taXNlPHZvaWQ+O1xuICBkZWxldGVQcm9qZWN0OiAocHJvamVjdElkOiBzdHJpbmcsIHBhdGhuYW1lOiBzdHJpbmcpID0+IFByb21pc2U8dm9pZD47XG4gIGdldFByb2plY3Q6IChwcm9qZWN0SWQ6IHN0cmluZykgPT4gUHJvbWlzZTxQcm9qZWN0IHwgbnVsbD47XG4gIGR1cGxpY2F0ZVByb2plY3Q6IChwcm9qZWN0SWQ6IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPjtcbiAgYWRkUHJvamVjdE1lbWJlcjogKHByb2plY3RJZDogc3RyaW5nLCB1c2VySWQ6IHN0cmluZywgcm9sZTogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+O1xuICB1cGRhdGVQcm9qZWN0TWVtYmVyUm9sZTogKHByb2plY3RJZDogc3RyaW5nLCB1c2VySWQ6IHN0cmluZywgcm9sZTogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+O1xuICByZW1vdmVQcm9qZWN0TWVtYmVyOiAocHJvamVjdElkOiBzdHJpbmcsIHVzZXJJZDogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+O1xuICBhZGRUYXNrOiAodGFzazogT21pdDxUYXNrLCAnaWQnPikgPT4gUHJvbWlzZTxUYXNrPjtcbiAgdXBkYXRlVGFzazogKHVwZGF0ZWRUYXNrOiBUYXNrKSA9PiBQcm9taXNlPHZvaWQ+O1xuICB1cGRhdGVUYXNrSW1tZWRpYXRlOiAodXBkYXRlZFRhc2s6IFRhc2spID0+IHZvaWQ7XG4gIGRlbGV0ZVRhc2s6ICh0YXNrSWQ6IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPjtcbiAgdXBkYXRlVXNlcjogKHVzZXJJZDogc3RyaW5nLCB1c2VyRGF0YTogUGFydGlhbDxQaWNrPFVzZXIsICduYW1lJyB8ICdlbWFpbCcgfCAnYXZhdGFyVXJsJz4+KSA9PiBQcm9taXNlPHZvaWQ+O1xuICBjcmVhdGVVc2VyOiAodXNlcjogT21pdDxVc2VyLCAnaWQnPiwgcGFzc3dvcmQ6IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPjtcbiAgY2hhbmdlUGFzc3dvcmQ6IChjdXJyZW50UGFzc3dvcmQ6IHN0cmluZywgbmV3UGFzc3dvcmQ6IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPjtcbiAgZmluZFVzZXJCeUVtYWlsOiAoZW1haWw6IHN0cmluZykgPT4gUHJvbWlzZTxVc2VyIHwgbnVsbD47XG4gIGZpbmRVc2VyQnlFbWFpbE9yTmFtZTogKHF1ZXJ5OiBzdHJpbmcpID0+IFByb21pc2U8VXNlciB8IG51bGw+O1xuICBhZGRQcm9qZWN0VGFza1N0YXR1czogKHByb2plY3RJZDogc3RyaW5nLCBzdGF0dXM6IE9taXQ8VGFza1N0YXR1c09wdGlvbiwgJ2lkJz4pID0+IFByb21pc2U8dm9pZD47XG4gIHVwZGF0ZVByb2plY3RUYXNrU3RhdHVzOiAocHJvamVjdElkOiBzdHJpbmcsIHN0YXR1c0lkOiBzdHJpbmcsIHN0YXR1c0RhdGE6IFBhcnRpYWw8T21pdDxUYXNrU3RhdHVzT3B0aW9uLCAnaWQnPj4pID0+IFByb21pc2U8dm9pZD47XG4gIGRlbGV0ZVByb2plY3RUYXNrU3RhdHVzOiAocHJvamVjdElkOiBzdHJpbmcsIHN0YXR1c0lkOiBzdHJpbmcpID0+IFByb21pc2U8dm9pZD47XG4gIHVwZGF0ZVByb2plY3RUYXNrU3RhdHVzT3JkZXI6IChwcm9qZWN0SWQ6IHN0cmluZywgc3RhdHVzZXM6IFRhc2tTdGF0dXNPcHRpb25bXSkgPT4gUHJvbWlzZTx2b2lkPjtcbiAgYWRkRGVmYXVsdFRhc2tTdGF0dXNlczogKHByb2plY3RJZDogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+O1xufVxuXG5jb25zdCBBcHBDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxBcHBDb250ZXh0VHlwZSB8IHVuZGVmaW5lZD4odW5kZWZpbmVkKTtcblxuY29uc3QgbG9nZ2VyID0gY3JlYXRlQ29tcG9uZW50TG9nZ2VyKCdBcHBDb250ZXh0Jyk7XG5cbmV4cG9ydCBmdW5jdGlvbiBBcHBQcm92aWRlcih7IGNoaWxkcmVuIH06IHsgY2hpbGRyZW46IFJlYWN0Tm9kZSB9KSB7XG4gIGNvbnN0IFt1c2Vycywgc2V0VXNlcnNdID0gdXNlU3RhdGU8TWFwPHN0cmluZywgVXNlcj4+KG5ldyBNYXAoKSk7XG4gIGNvbnN0IFtwcm9qZWN0cywgc2V0UHJvamVjdHNdID0gdXNlU3RhdGU8UHJvamVjdFtdPihbXSk7XG4gIGNvbnN0IFt0YXNrcywgc2V0VGFza3NdID0gdXNlU3RhdGU8VGFza1tdPihbXSk7XG4gIGNvbnN0IFtjdXJyZW50VXNlciwgc2V0Q3VycmVudFVzZXJdID0gdXNlU3RhdGU8VXNlciB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbbG9hZGluZywgc2V0TG9hZGluZ10gPSB1c2VTdGF0ZSh0cnVlKTtcbiAgY29uc3QgW2lzS2FuYmFuSGVhZGVyVmlzaWJsZSwgc2V0SXNLYW5iYW5IZWFkZXJWaXNpYmxlXSA9IHVzZVN0YXRlKHRydWUpO1xuICBjb25zdCBbaXNTaWRlYmFyT3BlbkJ5RGVmYXVsdCwgc2V0SXNTaWRlYmFyT3BlbkJ5RGVmYXVsdF0gPSB1c2VTdGF0ZSh0cnVlKTtcbiAgICBjb25zdCBbY2FyZERlbnNpdHksIHNldENhcmREZW5zaXR5U3RhdGVdID0gdXNlU3RhdGU8J2NvbWZvcnRhYmxlJyB8ICdjb21wYWN0Jz4oJ2NvbWZvcnRhYmxlJyk7XG4gICAgY29uc3QgW2RlZmF1bHRWaWV3LCBzZXREZWZhdWx0Vmlld1N0YXRlXSA9IHVzZVN0YXRlPCdib2FyZCcgfCAnbGlzdCc+KCdib2FyZCcpO1xuICAgICAgICBjb25zdCBbZ3JvdXBCeVN0YXR1cywgc2V0R3JvdXBCeVN0YXR1c1N0YXRlXSA9IHVzZVN0YXRlPGJvb2xlYW4+KHRydWUpO1xuICBjb25zdCByb3V0ZXIgPSB1c2VSb3V0ZXIoKTtcbiAgY29uc3QgcGF0aG5hbWUgPSB1c2VQYXRobmFtZSgpO1xuXG4gIC8vIERlYm91bmNlZCB0YXNrIHVwZGF0ZXMgZm9yIGRyYWcgb3BlcmF0aW9uc1xuICBjb25zdCBwZW5kaW5nVGFza1VwZGF0ZXMgPSB1c2VSZWY8TWFwPHN0cmluZywgVGFzaz4+KG5ldyBNYXAoKSk7XG4gIGNvbnN0IHVwZGF0ZVRhc2tUaW1lb3V0cyA9IHVzZVJlZjxNYXA8c3RyaW5nLCBOb2RlSlMuVGltZW91dD4+KG5ldyBNYXAoKSk7XG5cbiAgLy8gUmVhbHRpbWUgY2xpZW50IGZvciBTU0UgdXBkYXRlc1xuICBjb25zdCByZWFsdGltZUNsaWVudCA9IHVzZVJlZjxSZWFsdGltZUNsaWVudCB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbaXNSZWFsdGltZUNvbm5lY3RlZCwgc2V0SXNSZWFsdGltZUNvbm5lY3RlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG5cbiAgICAvLyBub3JtYWxpemUgYSBzaW5nbGUgcHJvamVjdCBvYmplY3QgZnJvbSBiYWNrZW5kIGludG8gZnJvbnRlbmQgc2hhcGVcbiAgICBjb25zdCBub3JtYWxpemVQcm9qZWN0ID0gKHA6IGFueSkgPT4ge1xuICAgICAgICBpZiAoIXApIHJldHVybiBwO1xuICAgICAgICBjb25zdCB0YXNrU3RhdHVzT3B0aW9uczogYW55W10gPSBBcnJheS5pc0FycmF5KHAuc3RhdHVzZXMpXG4gICAgICAgICAgICA/IHAuc3RhdHVzZXMubWFwKChzOiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBsYWJlbCA9IChzLmxhYmVsIHx8ICcnKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIC8vIGZhbGxiYWNrIGNvbG9yIG1hcCB3aGVuIERCIGRvZXNuJ3QgaGF2ZSBhIGNvbG9yXG4gICAgICAgICAgICAgICAgY29uc3QgZmFsbGJhY2sgPSAoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBsYWJlbC50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gJ3RvLWRvJyB8fCBrZXkgPT09ICd0b2RvJyB8fCBrZXkgPT09ICd0byBkbycpIHJldHVybiAnIzNCODJGNic7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT09ICdpbiBwcm9ncmVzcycgfHwga2V5ID09PSAnaW4tcHJvZ3Jlc3MnKSByZXR1cm4gJyNFQUIzMDgnO1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSAnZG9uZScpIHJldHVybiAnIzIyQzU1RSc7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT09ICdyZW1vdmUnIHx8IGtleSA9PT0gJ3JlbW92ZWQnIHx8IGtleSA9PT0gJ2FyY2hpdmUnKSByZXR1cm4gJyNFRjQ0NDQnO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyNFNUU3RUInO1xuICAgICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgXG4gICAgICAgICAgICAgICAgICAgIGlkOiBzLmlkLCBcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogcy5sYWJlbCwgXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiBzLmNvbG9yIHx8IGZhbGxiYWNrLCBcbiAgICAgICAgICAgICAgICAgICAgb3JkZXI6IHMub3JkZXIsIFxuICAgICAgICAgICAgICAgICAgICBzaG93U3RyaWtlVGhyb3VnaDogcy5zaG93U3RyaWtlVGhyb3VnaCB8fCBmYWxzZSwgXG4gICAgICAgICAgICAgICAgICAgIGhpZGRlbjogcy5oaWRkZW4gfHwgZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHJlcXVpcmVzQ29tbWVudDogcy5yZXF1aXJlc0NvbW1lbnQgfHwgZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGFsbG93c0NvbW1lbnQ6IHMuYWxsb3dzQ29tbWVudCB8fCBmYWxzZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgOiBbXTtcblxuICAgICAgICAvLyBub3JtYWxpemUgbWVtYmVycyBhcnJheSAtPiBtYXAgaWYgbmVlZGVkXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHAubWVtYmVycykpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hcDogUmVjb3JkPHN0cmluZywgYW55PiA9IHt9O1xuICAgICAgICAgICAgcC5tZW1iZXJzLmZvckVhY2goKG06IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChtICYmIG0udXNlcklkICYmIG0ucm9sZSkgbWFwW20udXNlcklkXSA9IG0ucm9sZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHsgLi4ucCwgbWVtYmVyczogbWFwLCB0YXNrU3RhdHVzT3B0aW9ucyB9IGFzIGFueTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IC4uLnAsIG1lbWJlcnM6IHAubWVtYmVycyB8fCB7fSwgdGFza1N0YXR1c09wdGlvbnMgfSBhcyBhbnk7XG4gICAgfTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGNvb2tpZVZhbHVlID0gZG9jdW1lbnQuY29va2llXG4gICAgICAuc3BsaXQoJzsgJylcbiAgICAgIC5maW5kKHJvdyA9PiByb3cuc3RhcnRzV2l0aCgnc2lkZWJhcl9kZWZhdWx0X29wZW49JykpXG4gICAgICA/LnNwbGl0KCc9JylbMV07XG4gICAgaWYgKGNvb2tpZVZhbHVlKSB7XG4gICAgICBzZXRJc1NpZGViYXJPcGVuQnlEZWZhdWx0KGNvb2tpZVZhbHVlID09PSAndHJ1ZScpO1xuICAgIH1cbiAgfSwgW10pO1xuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHN0b3JlZCA9IHdpbmRvdy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnY2FyZF9kZW5zaXR5Jyk7XG4gICAgICAgICAgICBpZiAoc3RvcmVkID09PSAnY29tcGFjdCcgfHwgc3RvcmVkID09PSAnY29tZm9ydGFibGUnKSBzZXRDYXJkRGVuc2l0eVN0YXRlKHN0b3JlZCBhcyAnY29tZm9ydGFibGUnIHwgJ2NvbXBhY3QnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkdiA9IHdpbmRvdy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnZGVmYXVsdF92aWV3Jyk7XG4gICAgICAgICAgICAgICAgaWYgKGR2ID09PSAnYm9hcmQnIHx8IGR2ID09PSAnbGlzdCcpIHNldERlZmF1bHRWaWV3U3RhdGUoZHYgYXMgJ2JvYXJkJyB8ICdsaXN0Jyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGdiID0gd2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKCdncm91cF9ieV9zdGF0dXMnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdiID09PSAndHJ1ZScgfHwgZ2IgPT09ICdmYWxzZScpIHNldEdyb3VwQnlTdGF0dXNTdGF0ZShnYiA9PT0gJ3RydWUnKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gaWdub3JlXG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG5cbiAgY29uc3QgdG9nZ2xlU2lkZWJhckRlZmF1bHQgPSAoKSA9PiB7XG4gICAgc2V0SXNTaWRlYmFyT3BlbkJ5RGVmYXVsdChwcmV2U3RhdGUgPT4ge1xuICAgICAgY29uc3QgbmV3U3RhdGUgPSAhcHJldlN0YXRlO1xuICAgICAgZG9jdW1lbnQuY29va2llID0gYHNpZGViYXJfZGVmYXVsdF9vcGVuPSR7bmV3U3RhdGV9O3BhdGg9LzttYXgtYWdlPTMxNTM2MDAwYDsgLy8gRXhwaXJlcyBpbiAxIHllYXJcbiAgICAgIHJldHVybiBuZXdTdGF0ZTtcbiAgICB9KTtcbiAgfTtcblxuICAgIGNvbnN0IHNldENhcmREZW5zaXR5ID0gKGQ6ICdjb21mb3J0YWJsZScgfCAnY29tcGFjdCcpID0+IHtcbiAgICAgICAgc2V0Q2FyZERlbnNpdHlTdGF0ZShkKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnY2FyZF9kZW5zaXR5JywgZCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIGlnbm9yZVxuICAgICAgICB9XG4gICAgfTtcblxuICAgICAgICBjb25zdCBzZXREZWZhdWx0VmlldyA9ICh2OiAnYm9hcmQnIHwgJ2xpc3QnKSA9PiB7XG4gICAgICAgICAgICBzZXREZWZhdWx0Vmlld1N0YXRlKHYpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2RlZmF1bHRfdmlldycsIHYpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIGlnbm9yZVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IHNldEdyb3VwQnlTdGF0dXMgPSAodjogYm9vbGVhbikgPT4ge1xuICAgICAgICAgICAgc2V0R3JvdXBCeVN0YXR1c1N0YXRlKHYpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2dyb3VwX2J5X3N0YXR1cycsIHYgPyAndHJ1ZScgOiAnZmFsc2UnKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBpZ25vcmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBhcHBseSBnbG9iYWwgYm9keSBjbGFzcyBmb3IgY29uc3VtcHRpb24gYnkgb3RoZXIgY29tcG9uZW50cy9zdHlsZXNcbiAgICAgICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhcmREZW5zaXR5ID09PSAnY29tcGFjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKCdjb21wYWN0Jyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKCdjb21wYWN0Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIGlnbm9yZVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBbY2FyZERlbnNpdHldKTtcblxuICBjb25zdCB0b2dnbGVLYW5iYW5IZWFkZXIgPSAoKSA9PiB7XG4gICAgc2V0SXNLYW5iYW5IZWFkZXJWaXNpYmxlKHByZXZTdGF0ZSA9PiAhcHJldlN0YXRlKTtcbiAgfTtcblxuICBjb25zdCBjbGVhclN0YXRlID0gKCkgPT4ge1xuICAgIHNldFVzZXJzKG5ldyBNYXAoKSk7XG4gICAgc2V0UHJvamVjdHMoW10pO1xuICAgIHNldFRhc2tzKFtdKTtcbiAgICBzZXRDdXJyZW50VXNlcihudWxsKTtcbiAgfVxuXG4gIC8vIENsZWFyIGFsbCBhdXRoZW50aWNhdGlvbiBkYXRhIGluY2x1ZGluZyBjb29raWVzXG4gIGNvbnN0IGNsZWFyQWxsQXV0aERhdGEgPSAoKSA9PiB7XG4gICAgY2xlYXJTdGF0ZSgpO1xuICAgIC8vIENsZWFyIGF1dGhlbnRpY2F0aW9uIGNvb2tpZVxuICAgIGRvY3VtZW50LmNvb2tpZSA9ICdvcmNoZXBsYW5fdG9rZW49OyBQYXRoPS87IEV4cGlyZXM9VGh1LCAwMSBKYW4gMTk3MCAwMDowMDowMSBHTVQ7JztcbiAgICAvLyBDbGVhciBhbnkgY2FjaGVkIGRhdGFcbiAgICBjbGVhckFsbENhY2hlcygpO1xuICB9XG5cbiAgICBjb25zdCBmZXRjaERhdGEgPSB1c2VDYWxsYmFjayhhc3luYyAoY3VycmVudFVzZXJJZDogc3RyaW5nKSA9PiB7XG4gICAgICAgIHNldExvYWRpbmcodHJ1ZSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBVc2UgY2FjaGVkIEFQSSBjYWxscyB3aXRoIHN0YWxlLXdoaWxlLXJldmFsaWRhdGUgc3RyYXRlZ3lcbiAgICAgICAgICAgIGNvbnN0IHByb2plY3RzUmVzcCA9IGF3YWl0IGdldENhY2hlZFByb2plY3RzKHsgc3RhbGVXaGlsZVJldmFsaWRhdGU6IHRydWUgfSk7XG4gICAgICAgICAgICBjb25zdCBhbGxQcm9qZWN0c0ZsYXQgPSAocHJvamVjdHNSZXNwIHx8IFtdKSBhcyBQcm9qZWN0W107XG5cbiAgICAgICAgICAgIC8vIEJ1aWxkIG5lc3RlZCBzdHJ1Y3R1cmVcbiAgICAgICAgICAgIGNvbnN0IHByb2plY3RNYXAgPSBuZXcgTWFwPHN0cmluZywgUHJvamVjdCAmIHsgc3ViUHJvamVjdHM6IFByb2plY3RbXSB9PigpO1xuICAgICAgICAgICAgYWxsUHJvamVjdHNGbGF0LmZvckVhY2gocCA9PiBwcm9qZWN0TWFwLnNldChwLmlkLCB7IC4uLihub3JtYWxpemVQcm9qZWN0KHApIGFzIGFueSksIHN1YlByb2plY3RzOiBbXSB9KSk7XG5cbiAgICAgICAgICAgIGNvbnN0IG5lc3RlZFByb2plY3RzOiBQcm9qZWN0W10gPSBbXTtcbiAgICAgICAgICAgIHByb2plY3RNYXAuZm9yRWFjaChwcm9qZWN0ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocHJvamVjdC5wYXJlbnRQcm9qZWN0SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gcHJvamVjdE1hcC5nZXQocHJvamVjdC5wYXJlbnRQcm9qZWN0SWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50KSBwYXJlbnQuc3ViUHJvamVjdHMucHVzaChwcm9qZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBuZXN0ZWRQcm9qZWN0cy5wdXNoKHByb2plY3QpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5lc3RlZFByb2plY3RzLnB1c2gocHJvamVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHNldFByb2plY3RzKG5lc3RlZFByb2plY3RzKTtcblxuICAgICAgICAgICAgLy8gRmV0Y2ggdXNlcnMgd2l0aCBjYWNoaW5nXG4gICAgICAgICAgICBjb25zdCB1c2Vyc1Jlc3AgPSBhd2FpdCBnZXRDYWNoZWRVc2Vycyh7IHN0YWxlV2hpbGVSZXZhbGlkYXRlOiB0cnVlIH0pO1xuICAgICAgICAgICAgY29uc3QgdXNlckxpc3QgPSAodXNlcnNSZXNwIHx8IFtdKSBhcyBVc2VyW107XG4gICAgICAgICAgICBjb25zdCB1c2VyTWFwID0gbmV3IE1hcDxzdHJpbmcsIFVzZXI+KCk7XG4gICAgICAgICAgICB1c2VyTGlzdC5mb3JFYWNoKHUgPT4gdXNlck1hcC5zZXQodS5pZCwgdSkpO1xuICAgICAgICAgICAgc2V0VXNlcnModXNlck1hcCk7XG5cbiAgICAgICAgICAgIC8vIExvZyBjYWNoZSBwZXJmb3JtYW5jZVxuICAgICAgICAgICAgY29uc3Qgc3RhdHMgPSBnZXRDYWNoZVN0YXRzKCk7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ0NhY2hlIHBlcmZvcm1hbmNlJywgeyBcbiAgICAgICAgICAgICAgICBjb21wb25lbnQ6ICdmZXRjaERhdGEnLFxuICAgICAgICAgICAgICAgIHN0YXRzOiB7XG4gICAgICAgICAgICAgICAgICAgIGhpdFJhdGU6IGAkeyhzdGF0cy5oaXRSYXRlICogMTAwKS50b0ZpeGVkKDEpfSVgLFxuICAgICAgICAgICAgICAgICAgICBoaXRzOiBzdGF0cy5oaXRzLFxuICAgICAgICAgICAgICAgICAgICBtaXNzZXM6IHN0YXRzLm1pc3NlcyxcbiAgICAgICAgICAgICAgICAgICAgc2l6ZTogc3RhdHMuc2l6ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGRhdGE6JywgZXJyb3IpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBJZiB3ZSBnZXQgYXV0aGVudGljYXRpb24gZXJyb3JzLCB0aGUgc3RvcmVkIGF1dGggbWlnaHQgYmUgc3RhbGVcbiAgICAgICAgICAgIGlmIChlcnJvcj8uc3RhdHVzID09PSA0MDEgfHwgZXJyb3I/LnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdBdXRoZW50aWNhdGlvbiBhcHBlYXJzIHN0YWxlLCBjbGVhcmluZyBhbGwgYXV0aGVudGljYXRpb24gZGF0YScpO1xuICAgICAgICAgICAgICAgIGNsZWFyQWxsQXV0aERhdGEoKTtcbiAgICAgICAgICAgICAgICByb3V0ZXI/LnB1c2goJy9sb2dpbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgd2UgZ2V0IGZvcmJpZGRlbiBlcnJvcnMsIGl0IG1pZ2h0IGJlIGR1ZSB0byBzdGFsZSBjYWNoZWQgcHJvamVjdCBkYXRhXG4gICAgICAgICAgICBlbHNlIGlmIChlcnJvcj8uc3RhdHVzID09PSA0MDMpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0FjY2VzcyBmb3JiaWRkZW4sIGNsZWFyaW5nIGNhY2hlZCBkYXRhJyk7XG4gICAgICAgICAgICAgICAgY2xlYXJBbGxDYWNoZXMoKTtcbiAgICAgICAgICAgICAgICAvLyBEb24ndCByZS1mZXRjaCBhdXRvbWF0aWNhbGx5IHRvIGF2b2lkIGluZmluaXRlIGxvb3BzXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcblxuICAgIC8vIFJlZnJlc2ggcHJvamVjdHMgd2l0aG91dCBjaGFuZ2luZyBsb2FkaW5nIHN0YXRlXG4gICAgY29uc3QgcmVmcmVzaFByb2plY3RzID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gRm9yY2UgcmVmcmVzaCB0byBieXBhc3MgY2FjaGVcbiAgICAgICAgICAgIGNvbnN0IHByb2plY3RzUmVzcCA9IGF3YWl0IGdldENhY2hlZFByb2plY3RzKHsgZm9yY2VSZWZyZXNoOiB0cnVlIH0pO1xuICAgICAgICAgICAgY29uc3QgYWxsUHJvamVjdHNGbGF0ID0gKHByb2plY3RzUmVzcCB8fCBbXSkgYXMgUHJvamVjdFtdO1xuXG4gICAgICAgICAgICBjb25zdCBwcm9qZWN0TWFwID0gbmV3IE1hcDxzdHJpbmcsIFByb2plY3QgJiB7IHN1YlByb2plY3RzOiBQcm9qZWN0W10gfT4oKTtcbiAgICAgICAgICAgIGFsbFByb2plY3RzRmxhdC5mb3JFYWNoKHAgPT4gcHJvamVjdE1hcC5zZXQocC5pZCwgeyAuLi4obm9ybWFsaXplUHJvamVjdChwKSBhcyBhbnkpLCBzdWJQcm9qZWN0czogW10gfSkpO1xuXG4gICAgICAgICAgICBjb25zdCBuZXN0ZWRQcm9qZWN0czogUHJvamVjdFtdID0gW107XG4gICAgICAgICAgICBwcm9qZWN0TWFwLmZvckVhY2gocHJvamVjdCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHByb2plY3QucGFyZW50UHJvamVjdElkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IHByb2plY3RNYXAuZ2V0KHByb2plY3QucGFyZW50UHJvamVjdElkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudCkgcGFyZW50LnN1YlByb2plY3RzLnB1c2gocHJvamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgbmVzdGVkUHJvamVjdHMucHVzaChwcm9qZWN0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuZXN0ZWRQcm9qZWN0cy5wdXNoKHByb2plY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBzZXRQcm9qZWN0cyhuZXN0ZWRQcm9qZWN0cyk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZWZyZXNoaW5nIHByb2plY3RzOicsIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcblxuICAgIC8vIEV4cG9zZSBjYWNoZSBjbGVhcmluZyBmdW5jdGlvbiBnbG9iYWxseSBmb3IgZGVidWdnaW5nXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgKHdpbmRvdyBhcyBhbnkpLmNsZWFyT3JjaGVQbGFuQ2FjaGUgPSAoKSA9PiB7XG4gICAgICAgICAgICBjbGVhckFsbENhY2hlcygpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRVc2VyPy5pZCkge1xuICAgICAgICAgICAgICAgIGZldGNoRGF0YShjdXJyZW50VXNlci5pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBkZWxldGUgKHdpbmRvdyBhcyBhbnkpLmNsZWFyT3JjaGVQbGFuQ2FjaGU7XG4gICAgICAgIH07XG4gICAgfSwgW2N1cnJlbnRVc2VyLCBmZXRjaERhdGFdKTtcblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGxldCBtb3VudGVkID0gdHJ1ZTtcbiAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgc2V0TG9hZGluZyh0cnVlKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gYXdhaXQgYXV0aE1lKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdXNlciA9IHJlc3A/LnVzZXIgYXMgVXNlciB8IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBpZiAobW91bnRlZCAmJiB1c2VyKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldEN1cnJlbnRVc2VyKHVzZXIpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBmZXRjaERhdGEodXNlci5pZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtb3VudGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vIHVzZXIgbG9nZ2VkIGluIChyZXNwIGlzIG51bGwpIC0gdGhpcyBpcyBub3JtYWwsIG5vdCBhbiBlcnJvclxuICAgICAgICAgICAgICAgICAgICBjbGVhclN0YXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdFcnJvciBjaGVja2luZyBhdXRoZW50aWNhdGlvbicsIGVycik7XG4gICAgICAgICAgICAgICAgY2xlYXJTdGF0ZSgpO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBpZiAobW91bnRlZCkgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKCk7XG5cbiAgICAgICAgcmV0dXJuICgpID0+IHsgbW91bnRlZCA9IGZhbHNlIH07XG4gICAgfSwgW2ZldGNoRGF0YV0pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGxvYWRpbmcpIHJldHVybjtcblxuICAgIGlmICghY3VycmVudFVzZXIgJiYgcGF0aG5hbWUgIT09ICcvbG9naW4nICYmIHBhdGhuYW1lICE9PSAnL3NpZ251cCcpIHtcbiAgICAgIHJvdXRlci5wdXNoKCcvbG9naW4nKTtcbiAgICB9XG4gIH0sIFtjdXJyZW50VXNlciwgbG9hZGluZywgcGF0aG5hbWUsIHJvdXRlcl0pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFjdXJyZW50VXNlciB8fCBwcm9qZWN0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgc2V0VGFza3MoW10pO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSW5pdGlhbCBmZXRjaCBvZiB0YXNrc1xuICAgIGNvbnN0IGdldEFsbFByb2plY3RJZHMgPSAocHJvanM6IFByb2plY3RbXSk6IHN0cmluZ1tdID0+IHtcbiAgICAgICAgbGV0IGlkczogc3RyaW5nW10gPSBbXTtcbiAgICAgICAgcHJvanMuZm9yRWFjaChwID0+IHtcbiAgICAgICAgICAgIGlkcy5wdXNoKHAuaWQpO1xuICAgICAgICAgICAgaWYgKHAuc3ViUHJvamVjdHMpIHtcbiAgICAgICAgICAgICAgICBpZHMgPSBpZHMuY29uY2F0KGdldEFsbFByb2plY3RJZHMocC5zdWJQcm9qZWN0cykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGlkcztcbiAgICB9O1xuXG4gICAgY29uc3QgYWxsUHJvamVjdElkcyA9IGdldEFsbFByb2plY3RJZHMocHJvamVjdHMpO1xuXG4gICAgaWYgKGFsbFByb2plY3RJZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHNldFRhc2tzKFtdKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IENIVU5LX1NJWkUgPSAxMDA7IC8vIEluY3JlYXNlZCBmcm9tIDMwIHRvIHJlZHVjZSBBUEkgY2FsbHNcbiAgICBjb25zdCBwcm9qZWN0Q2h1bmtzOiBzdHJpbmdbXVtdID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbGxQcm9qZWN0SWRzLmxlbmd0aDsgaSArPSBDSFVOS19TSVpFKSB7XG4gICAgICAgIHByb2plY3RDaHVua3MucHVzaChhbGxQcm9qZWN0SWRzLnNsaWNlKGksIGkgKyBDSFVOS19TSVpFKSk7XG4gICAgfVxuXG4gICAgLy8gTm9ybWFsaXplIHRhc2sgZGF0YVxuICAgIGNvbnN0IG5vcm1hbGl6ZVRhc2sgPSAodDogYW55KSA9PiAoe1xuICAgICAgICAuLi50LFxuICAgICAgICBzdGF0dXM6IHQuc3RhdHVzSWQgPz8gKHR5cGVvZiB0LnN0YXR1cyA9PT0gJ3N0cmluZycgJiYgL15bMC05YS1mQS1GLV17MzZ9JC8udGVzdCh0LnN0YXR1cykgPyB0LnN0YXR1cyA6IG51bGwpLFxuICAgICAgICBhc3NpZ25lZUlkOiB0LmFzc2lnbmVlSWQgPz8gdW5kZWZpbmVkLFxuICAgICAgICBwYXJlbnRJZDogdC5wYXJlbnRJZCA/PyB1bmRlZmluZWQsXG4gICAgfSk7XG5cbiAgICAvLyBUYXNrIGZldGNoaW5nIGZ1bmN0aW9uIGZvciBib3RoIGluaXRpYWwgbG9hZCBhbmQgZmFsbGJhY2sgcG9sbGluZ1xuICAgIGNvbnN0IGZldGNoVGFza3MgPSBhc3luYyAoZm9yY2VSZWZyZXNoID0gZmFsc2UpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgICAgICAgICBwcm9qZWN0Q2h1bmtzLm1hcChjaHVuayA9PiBcbiAgICAgICAgICAgICAgICAgICAgZ2V0Q2FjaGVkVGFza3NCeVByb2plY3RJZHMoY2h1bmssIHsgXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JjZVJlZnJlc2gsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFsZVdoaWxlUmV2YWxpZGF0ZTogIWZvcmNlUmVmcmVzaCBcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29uc3QgY29tYmluZWQ6IGFueVtdID0gcmVzdWx0cy5mbGF0KCk7XG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkVGFza3MgPSBjb21iaW5lZC5tYXAobm9ybWFsaXplVGFzayk7XG4gICAgICAgICAgICBzZXRUYXNrcyhub3JtYWxpemVkVGFza3MpO1xuICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRUYXNrcztcbiAgICAgICAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHRhc2tzOicsIGVycik7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdbREVCVUddIEZhaWxlZCB0byBmZXRjaCB0YXNrcyBmb3IgcHJvamVjdCBJRHM6JywgYWxsUHJvamVjdElkcyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIElmIHdlIGdldCBhIDQwMyBlcnJvciwgaXQncyBsaWtlbHkgZHVlIHRvIHJlcXVlc3RpbmcgdGFza3MgZm9yIHByb2plY3RzXG4gICAgICAgICAgICAvLyB0aGUgdXNlciBubyBsb25nZXIgaGFzIGFjY2VzcyB0by4gQ2xlYXIgY2FjaGVzIGJ1dCBkb24ndCByZXRyeSBhdXRvbWF0aWNhbGx5LlxuICAgICAgICAgICAgaWYgKGVycj8uc3RhdHVzID09PSA0MDMpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0ZvcmJpZGRlbiBlcnJvciBmZXRjaGluZyB0YXNrcywgY2xlYXJpbmcgY2FjaGVzJyk7XG4gICAgICAgICAgICAgICAgY2xlYXJBbGxDYWNoZXMoKTtcbiAgICAgICAgICAgICAgICAvLyBEb24ndCByZXRyeSBhdXRvbWF0aWNhbGx5IHRvIGF2b2lkIGluZmluaXRlIGxvb3BzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gSW5pdGlhbCB0YXNrIGZldGNoXG4gICAgZmV0Y2hUYXNrcygpO1xuXG4gICAgLy8gUG9sbGluZyBmYWxsYmFjayB2YXJpYWJsZXNcbiAgICBsZXQgcG9sbGluZ0ludGVydmFsOiBOb2RlSlMuVGltZW91dCB8IG51bGwgPSBudWxsO1xuICAgIGxldCBsYXN0VGFza0NvdW50ID0gMDtcbiAgICBsZXQgY29uc2VjdXRpdmVOb0NoYW5nZXMgPSAwO1xuICAgIGxldCBpc1dpbmRvd0FjdGl2ZSA9IHRydWU7XG4gICAgXG4gICAgLy8gU21hcnQgcG9sbGluZyBpbnRlcnZhbHMgZm9yIGZhbGxiYWNrXG4gICAgY29uc3QgZ2V0UG9sbGluZ0ludGVydmFsID0gKCkgPT4ge1xuICAgICAgICBpZiAoIWlzV2luZG93QWN0aXZlKSByZXR1cm4gNjAwMDA7IC8vIDEgbWludXRlIHdoZW4gdGFiIGlzIG5vdCBhY3RpdmVcbiAgICAgICAgaWYgKGNvbnNlY3V0aXZlTm9DaGFuZ2VzID4gMykgcmV0dXJuIDMwMDAwOyAvLyAzMCBzZWNvbmRzIGFmdGVyIG5vIGNoYW5nZXNcbiAgICAgICAgcmV0dXJuIDE1MDAwOyAvLyAxNSBzZWNvbmRzIGZvciBmYWxsYmFjayBwb2xsaW5nIChmYXN0ZXIgdGhhbiBiZWZvcmUpXG4gICAgfTtcblxuICAgIGNvbnN0IHN0YXJ0UG9sbGluZyA9ICgpID0+IHtcbiAgICAgICAgaWYgKHBvbGxpbmdJbnRlcnZhbCkgY2xlYXJJbnRlcnZhbChwb2xsaW5nSW50ZXJ2YWwpO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgcG9sbCA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRhc2tzID0gYXdhaXQgZmV0Y2hUYXNrcygpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBUcmFjayBjaGFuZ2VzIHRvIGFkanVzdCBwb2xsaW5nIGZyZXF1ZW5jeVxuICAgICAgICAgICAgaWYgKHRhc2tzLmxlbmd0aCA9PT0gbGFzdFRhc2tDb3VudCkge1xuICAgICAgICAgICAgICAgIGNvbnNlY3V0aXZlTm9DaGFuZ2VzKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNlY3V0aXZlTm9DaGFuZ2VzID0gMDtcbiAgICAgICAgICAgICAgICBsYXN0VGFza0NvdW50ID0gdGFza3MubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBSZXN0YXJ0IHdpdGggcG90ZW50aWFsbHkgbmV3IGludGVydmFsXG4gICAgICAgICAgICBzdGFydFBvbGxpbmcoKTtcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIHBvbGxpbmdJbnRlcnZhbCA9IHNldEludGVydmFsKHBvbGwsIGdldFBvbGxpbmdJbnRlcnZhbCgpKTtcbiAgICB9O1xuXG4gICAgLy8gV2luZG93IGZvY3VzL2JsdXIgZGV0ZWN0aW9uIGZvciBzbWFydCBwb2xsaW5nXG4gICAgY29uc3QgaGFuZGxlRm9jdXMgPSAoKSA9PiB7XG4gICAgICAgIGlzV2luZG93QWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgY29uc2VjdXRpdmVOb0NoYW5nZXMgPSAwOyAvLyBSZXNldCB3aGVuIHVzZXIgcmV0dXJuc1xuICAgIH07XG4gICAgXG4gICAgY29uc3QgaGFuZGxlQmx1ciA9ICgpID0+IHtcbiAgICAgICAgaXNXaW5kb3dBY3RpdmUgPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgLy8gVHJ5IHRvIGluaXRpYWxpemUgU1NFIGNvbm5lY3Rpb24gZm9yIHJlYWwtdGltZSB1cGRhdGVzIHdpdGggaW1wcm92ZWQgaW1wbGVtZW50YXRpb25cbiAgICBpZiAoIXJlYWx0aW1lQ2xpZW50LmN1cnJlbnQpIHtcbiAgICAgICAgLy8gVXNlIHRoZSBzYW1lIEFQSSBiYXNlIGFzIHRoZSByZXN0IG9mIHRoZSBhcHAgZm9yIGNvbnNpc3RlbmN5XG4gICAgICAgIGNvbnN0IGdldEFwaUJhc2UgPSAoKSA9PiB7XG4gICAgICAgICAgICAvLyBVc2UgZW52aXJvbm1lbnQgdmFyaWFibGUgaWYgc2V0XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQkFDS0VORF9VUkwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQkFDS0VORF9VUkw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX0JBU0UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX0JBU0U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuICdodHRwOi8vbG9jYWxob3N0OjMwMDAnO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBob3N0bmFtZSA9IHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZTtcbiAgICAgICAgICAgIGNvbnN0IHByb3RvY29sID0gd2luZG93LmxvY2F0aW9uLnByb3RvY29sO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBMb2NhbCBkZXZlbG9wbWVudFxuICAgICAgICAgICAgaWYgKGhvc3RuYW1lID09PSAnbG9jYWxob3N0JyB8fCBob3N0bmFtZSA9PT0gJzEyNy4wLjAuMScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEV4dGVybmFsIHNlcnZlciAtIGNvbnN0cnVjdCBiYWNrZW5kIFVSTFxuICAgICAgICAgICAgLy8gSW4gQ29kZXIgZW52aXJvbm1lbnQsIHVzZSBIVFRQUyBmb3IgYmFja2VuZCBhcyB3ZWxsXG4gICAgICAgICAgICBjb25zdCBpc0NvZGVyRW52ID0gaG9zdG5hbWUuaW5jbHVkZXMoJ2NvZGVyLmpvc2Vybi5jb20nKTtcbiAgICAgICAgICAgIGNvbnN0IGJhY2tlbmRQcm90b2NvbCA9IGlzQ29kZXJFbnYgPyAnaHR0cHM6JyA6IHByb3RvY29sO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoaXNDb2RlckVudikge1xuICAgICAgICAgICAgICAgIC8vIFNwZWNpYWwgaGFuZGxpbmcgZm9yIENvZGVyIHN1YmRvbWFpbiBwYXR0ZXJuXG4gICAgICAgICAgICAgICAgY29uc3QgYmFja2VuZEhvc3RuYW1lID0gaG9zdG5hbWUucmVwbGFjZSgvXjkwMDItLS8sICczMDAwLS0nKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7YmFja2VuZFByb3RvY29sfS8vJHtiYWNrZW5kSG9zdG5hbWV9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIGAke2JhY2tlbmRQcm90b2NvbH0vLyR7aG9zdG5hbWV9OjMwMDBgO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGJhc2VVcmwgPSBnZXRBcGlCYXNlKCk7XG5cbiAgICAgICAgcmVhbHRpbWVDbGllbnQuY3VycmVudCA9IG5ldyBSZWFsdGltZUNsaWVudChiYXNlVXJsKTtcblxuICAgICAgICAvLyBTZXQgdXAgZXZlbnQgbGlzdGVuZXJzIGZvciByZWFsLXRpbWUgdXBkYXRlc1xuICAgICAgICByZWFsdGltZUNsaWVudC5jdXJyZW50Lm9uKCd0YXNrX3VwZGF0ZScsIChkYXRhOiBhbnkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgYWN0aW9uLCBkYXRhOiB0YXNrRGF0YSB9ID0gZGF0YTtcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRUYXNrID0gbm9ybWFsaXplVGFzayh0YXNrRGF0YSk7XG5cbiAgICAgICAgICAgIHNldFRhc2tzKHByZXYgPT4ge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NyZWF0ZWQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIG5ldyB0YXNrIGlmIG5vdCBhbHJlYWR5IHByZXNlbnQgKGNoZWNrIGJ5IElEKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdUYXNrID0gcHJldi5maW5kKHQgPT4gdC5pZCA9PT0gbm9ybWFsaXplZFRhc2suaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFleGlzdGluZ1Rhc2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWy4uLnByZXYsIG5vcm1hbGl6ZWRUYXNrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3VwZGF0ZWQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIGV4aXN0aW5nIHRhc2tcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmV2Lm1hcCh0ID0+IHQuaWQgPT09IG5vcm1hbGl6ZWRUYXNrLmlkID8gbm9ybWFsaXplZFRhc2sgOiB0KTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZGVsZXRlZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgZGVsZXRlZCB0YXNrXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJldi5maWx0ZXIodCA9PiB0LmlkICE9PSBub3JtYWxpemVkVGFzay5pZCk7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJldjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmVhbHRpbWVDbGllbnQuY3VycmVudC5vbigncHJvamVjdF91cGRhdGUnLCAoZGF0YTogYW55KSA9PiB7XG4gICAgICAgICAgICAvLyBIYW5kbGUgcHJvamVjdCB1cGRhdGVzIC0gcmVmcmVzaCBwcm9qZWN0cyB0byBnZXQgdXBkYXRlZCBtZW1iZXJzaGlwL2FjY2Vzc1xuICAgICAgICAgICAgcmVmcmVzaFByb2plY3RzKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlYWx0aW1lQ2xpZW50LmN1cnJlbnQub24oJ3N0YXR1c191cGRhdGUnLCAoZGF0YTogYW55KSA9PiB7XG4gICAgICAgICAgICAvLyBIYW5kbGUgc3RhdHVzIHVwZGF0ZXMgLSBjb3VsZCB1cGRhdGUgcHJvamVjdCBzdGF0dXMgb3B0aW9uc1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBIYW5kbGUgU1NFIGNvbm5lY3Rpb24gZmFpbHVyZSAtIGZhbGwgYmFjayB0byBwb2xsaW5nXG4gICAgICAgIHJlYWx0aW1lQ2xpZW50LmN1cnJlbnQub24oJ2Nvbm5lY3Rpb25fZmFpbGVkJywgKGRhdGE6IGFueSkgPT4ge1xuICAgICAgICAgICAgc2V0SXNSZWFsdGltZUNvbm5lY3RlZChmYWxzZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFNldCB1cCB3aW5kb3cgZm9jdXMvYmx1ciBsaXN0ZW5lcnMgZm9yIHNtYXJ0IHBvbGxpbmdcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIGhhbmRsZUZvY3VzKTtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgaGFuZGxlQmx1cik7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFN0YXJ0IHBvbGxpbmcgYXMgZmFsbGJhY2tcbiAgICAgICAgICAgIHN0YXJ0UG9sbGluZygpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBUcnkgdG8gY29ubmVjdCB0byByZWFsLXRpbWUgdXBkYXRlc1xuICAgIHJlYWx0aW1lQ2xpZW50LmN1cnJlbnQuY29ubmVjdCgpO1xuICAgIFxuICAgIC8vIFNldCBhIHRpbWVvdXQgdG8gZmFsbCBiYWNrIHRvIHBvbGxpbmcgaWYgU1NFIGRvZXNuJ3QgY29ubmVjdCB3aXRoaW4gMTAgc2Vjb25kc1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAoIXJlYWx0aW1lQ2xpZW50LmN1cnJlbnQ/LmdldENvbm5lY3Rpb25TdGF0dXMoKSkge1xuICAgICAgICAgICAgc2V0SXNSZWFsdGltZUNvbm5lY3RlZChmYWxzZSk7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCBoYW5kbGVGb2N1cyk7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIGhhbmRsZUJsdXIpO1xuICAgICAgICAgICAgc3RhcnRQb2xsaW5nKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXRJc1JlYWx0aW1lQ29ubmVjdGVkKHRydWUpO1xuICAgICAgICB9XG4gICAgfSwgMTAwMDApO1xuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgLy8gQ2xlYW4gdXAgb24gdW5tb3VudCBvciBkZXBlbmRlbmN5IGNoYW5nZVxuICAgICAgICBpZiAocmVhbHRpbWVDbGllbnQuY3VycmVudCkge1xuICAgICAgICAgICAgcmVhbHRpbWVDbGllbnQuY3VycmVudC5kaXNjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmIChwb2xsaW5nSW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwocG9sbGluZ0ludGVydmFsKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgaGFuZGxlRm9jdXMpO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmx1cicsIGhhbmRsZUJsdXIpO1xuICAgICAgICBzZXRJc1JlYWx0aW1lQ29ubmVjdGVkKGZhbHNlKTtcbiAgICB9O1xufSwgW2N1cnJlbnRVc2VyLCBwcm9qZWN0c10pO1xuXG4gICAgY29uc3QgYWRkRGVmYXVsdFRhc2tTdGF0dXNlcyA9IGFzeW5jIChwcm9qZWN0SWQ6IHN0cmluZykgPT4ge1xuICAgICAgICBpZiAoIWN1cnJlbnRVc2VyKSB0aHJvdyBuZXcgRXJyb3IoJ1VzZXIgbm90IGF1dGhlbnRpY2F0ZWQnKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRTdGF0dXNlcyA9IFtcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICdUbyBEbycsIGNvbG9yOiAnIzNCODJGNicsIG9yZGVyOiAwLCBzaG93U3RyaWtlVGhyb3VnaDogZmFsc2UsIGhpZGRlbjogZmFsc2UsIHJlcXVpcmVzQ29tbWVudDogZmFsc2UsIGFsbG93c0NvbW1lbnQ6IGZhbHNlIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnSW4gUHJvZ3Jlc3MnLCBjb2xvcjogJyNFQUIzMDgnLCBvcmRlcjogMSwgc2hvd1N0cmlrZVRocm91Z2g6IGZhbHNlLCBoaWRkZW46IGZhbHNlLCByZXF1aXJlc0NvbW1lbnQ6IGZhbHNlLCBhbGxvd3NDb21tZW50OiB0cnVlIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnRG9uZScsIGNvbG9yOiAnIzIyQzU1RScsIG9yZGVyOiAzLCBzaG93U3RyaWtlVGhyb3VnaDogdHJ1ZSwgaGlkZGVuOiBmYWxzZSwgcmVxdWlyZXNDb21tZW50OiBmYWxzZSwgYWxsb3dzQ29tbWVudDogZmFsc2UgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICdSZW1vdmUnLCBjb2xvcjogJyNFRjQ0NDQnLCBvcmRlcjogMiwgc2hvd1N0cmlrZVRocm91Z2g6IGZhbHNlLCBoaWRkZW46IGZhbHNlLCByZXF1aXJlc0NvbW1lbnQ6IHRydWUsIGFsbG93c0NvbW1lbnQ6IHRydWUgfSxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIE9wdGltaXN0aWNhbGx5IGFkZCBzdGF0dXNlcyB0byBsb2NhbCBzdGF0ZSB3aXRoIHRlbXBvcmFyeSBJRHNcbiAgICAgICAgICAgIGNvbnN0IHRlbXBTdGF0dXNlczogVGFza1N0YXR1c09wdGlvbltdID0gZGVmYXVsdFN0YXR1c2VzLm1hcCgocywgaW5kZXgpID0+ICh7XG4gICAgICAgICAgICAgICAgLi4ucyxcbiAgICAgICAgICAgICAgICBpZDogYHRlbXAtJHtEYXRlLm5vdygpfS0ke2luZGV4fWAgLy8gdGVtcG9yYXJ5IElEXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHNldFByb2plY3RzKHByZXYgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZVByb2plY3QgPSAocHJvamVjdHM6IFByb2plY3RbXSk6IFByb2plY3RbXSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9qZWN0cy5tYXAocCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocC5pZCA9PT0gcHJvamVjdElkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4ucCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFza1N0YXR1c09wdGlvbnM6IFsuLi4ocC50YXNrU3RhdHVzT3B0aW9ucyB8fCBbXSksIC4uLnRlbXBTdGF0dXNlc11cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHAuc3ViUHJvamVjdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyAuLi5wLCBzdWJQcm9qZWN0czogdXBkYXRlUHJvamVjdChwLnN1YlByb2plY3RzKSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVByb2plY3QocHJldik7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gQ3JlYXRlIHN0YXR1c2VzIHZpYSBBUEkgYW5kIGNvbGxlY3QgcmVhbCBJRHNcbiAgICAgICAgICAgIGNvbnN0IGNyZWF0ZWRTdGF0dXNlczogVGFza1N0YXR1c09wdGlvbltdID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHMgb2YgZGVmYXVsdFN0YXR1c2VzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3JlYXRlZCA9IGF3YWl0IGNyZWF0ZVByb2plY3RTdGF0dXMocHJvamVjdElkLCB7IFxuICAgICAgICAgICAgICAgICAgICBsYWJlbDogcy5uYW1lLCAvLyBBUEkgZXhwZWN0cyAnbGFiZWwnIGJ1dCByZXR1cm5zICduYW1lJ1xuICAgICAgICAgICAgICAgICAgICBjb2xvcjogcy5jb2xvciwgXG4gICAgICAgICAgICAgICAgICAgIG9yZGVyOiBzLm9yZGVyLCBcbiAgICAgICAgICAgICAgICAgICAgc2hvd1N0cmlrZVRocm91Z2g6IHMuc2hvd1N0cmlrZVRocm91Z2gsIFxuICAgICAgICAgICAgICAgICAgICBoaWRkZW46IHMuaGlkZGVuIFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNyZWF0ZWRTdGF0dXNlcy5wdXNoKGNyZWF0ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBSZXBsYWNlIHRlbXBvcmFyeSBzdGF0dXNlcyB3aXRoIHJlYWwgb25lc1xuICAgICAgICAgICAgc2V0UHJvamVjdHMocHJldiA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlUHJvamVjdCA9IChwcm9qZWN0czogUHJvamVjdFtdKTogUHJvamVjdFtdID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb2plY3RzLm1hcChwID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwLmlkID09PSBwcm9qZWN0SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXNrU3RhdHVzT3B0aW9uczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uKHAudGFza1N0YXR1c09wdGlvbnM/LmZpbHRlcihzID0+ICFzLmlkLnN0YXJ0c1dpdGgoJ3RlbXAtJykpIHx8IFtdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmNyZWF0ZWRTdGF0dXNlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwLnN1YlByb2plY3RzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgLi4ucCwgc3ViUHJvamVjdHM6IHVwZGF0ZVByb2plY3QocC5zdWJQcm9qZWN0cykgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiB1cGRhdGVQcm9qZWN0KHByZXYpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoJ0Vycm9yIGFkZGluZyBkZWZhdWx0IHRhc2sgc3RhdHVzZXMnLCB7IFxuICAgICAgICAgICAgICAgIHVzZXJJZDogY3VycmVudFVzZXIuaWQsIFxuICAgICAgICAgICAgICAgIHByb2plY3RJZCxcbiAgICAgICAgICAgICAgICBhY3Rpb246ICdhZGREZWZhdWx0VGFza1N0YXR1c2VzJyBcbiAgICAgICAgICAgIH0sIGVycm9yKTtcbiAgICAgICAgICAgIC8vIFJldmVydCBvcHRpbWlzdGljIHVwZGF0ZSBvbiBlcnJvclxuICAgICAgICAgICAgYXdhaXQgZmV0Y2hEYXRhKGN1cnJlbnRVc2VyLmlkKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfTtcblxuXG4gIGNvbnN0IGxvZ2luID0gYXN5bmMgKGVtYWlsOiBzdHJpbmcsIHBhc3N3b3JkOiBzdHJpbmcpOiBQcm9taXNlPHsgc3VjY2VzczogYm9vbGVhbjsgZXJyb3I/OiBzdHJpbmcgfT4gPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3AgPSBhd2FpdCBhdXRoTG9naW4oZW1haWwsIHBhc3N3b3JkKTtcbiAgICAgICAgXG4gICAgICAgIC8vIENoZWNrIGlmIGl0J3MgYW4gZXhwZWN0ZWQgZXJyb3IgcmVzcG9uc2VcbiAgICAgICAgaWYgKHJlc3AgJiYgJ3N1Y2Nlc3MnIGluIHJlc3AgJiYgcmVzcC5zdWNjZXNzID09PSBmYWxzZSAmJiByZXNwLmlzRXhwZWN0ZWQpIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygnTG9naW4gZmFpbGVkIC0gaW52YWxpZCBjcmVkZW50aWFscycsIHtcbiAgICAgICAgICAgICAgICBlbWFpbCxcbiAgICAgICAgICAgICAgICBhY3Rpb246ICdsb2dpbicsXG4gICAgICAgICAgICAgICAgZXJyb3JUeXBlOiAnYXV0aGVudGljYXRpb25fZmFpbGVkJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IHJlc3AuZXJyb3IgfTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY29uc3QgdXNlciA9IHJlc3A/LnVzZXIgYXMgVXNlciB8IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHVzZXIpIHtcbiAgICAgICAgICBzZXRDdXJyZW50VXNlcih1c2VyKTtcbiAgICAgICAgICBhd2FpdCBmZXRjaERhdGEodXNlci5pZCk7XG4gICAgICAgICAgbG9nZ2VyLmluZm8oJ1VzZXIgbG9naW4gc3VjY2Vzc2Z1bCcsIHsgXG4gICAgICAgICAgICB1c2VySWQ6IHVzZXIuaWQsIFxuICAgICAgICAgICAgZW1haWwsXG4gICAgICAgICAgICBhY3Rpb246ICdsb2dpbicgXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogJ0xvZ2luIGZhaWxlZCcgfTtcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgIC8vIEZvciBhdXRoIGVycm9ycywgbG9nIHRoZW0gZGlmZmVyZW50bHkgdG8gYXZvaWQgc2NhcnkgY29uc29sZSBtZXNzYWdlc1xuICAgICAgICBpZiAoZXJyb3I/LnN0YXR1cyA9PT0gNDAxIHx8IGVycm9yPy5zdGF0dXMgPT09IDQwMCB8fCBlcnJvcj8uaXNFeHBlY3RlZCkge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdMb2dpbiBmYWlsZWQgLSBpbnZhbGlkIGNyZWRlbnRpYWxzJywge1xuICAgICAgICAgICAgICAgIGVtYWlsLFxuICAgICAgICAgICAgICAgIGFjdGlvbjogJ2xvZ2luJyxcbiAgICAgICAgICAgICAgICBlcnJvclR5cGU6ICdhdXRoZW50aWNhdGlvbl9mYWlsZWQnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcignTG9naW4gZXJyb3InLCB7IFxuICAgICAgICAgICAgICAgIGVtYWlsLFxuICAgICAgICAgICAgICAgIGFjdGlvbjogJ2xvZ2luJyxcbiAgICAgICAgICAgICAgICBlcnJvclR5cGU6IGVycm9yPy5ib2R5Py5lcnJvciB8fCBlcnJvcj8ubWVzc2FnZSB8fCAndW5rbm93bicsXG4gICAgICAgICAgICAgICAgc3RhdHVzOiBlcnJvcj8uc3RhdHVzXG4gICAgICAgICAgICB9LCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3I/LmJvZHk/LmVycm9yIHx8IGVycm9yPy5tZXNzYWdlIHx8ICdMb2dpbiBmYWlsZWQnO1xuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGVycm9yTWVzc2FnZSB9O1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGxvZ291dCA9IGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgICBhd2FpdCBhdXRoTG9nb3V0KCk7XG4gICAgICAgIGNsZWFyU3RhdGUoKTtcbiAgICAgICAgY2xlYXJBbGxDYWNoZXMoKTsgLy8gQ2xlYXIgYWxsIGNhY2hlZCBkYXRhIG9uIGxvZ291dFxuICAgICAgICByb3V0ZXIucHVzaCgnL2xvZ2luJyk7XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICAvLyBGb3IgbG9nb3V0IGVycm9ycywgb25seSBsb2cgaWYgdGhleSdyZSB1bmV4cGVjdGVkIChub3QgYXV0aCBmYWlsdXJlcylcbiAgICAgICAgaWYgKGVycm9yPy5zdGF0dXMgIT09IDQwMSAmJiAhZXJyb3I/LmlzRXhwZWN0ZWQpIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcignTG9nb3V0IGVycm9yJywgeyBcbiAgICAgICAgICAgICAgICB1c2VySWQ6IGN1cnJlbnRVc2VyPy5pZCxcbiAgICAgICAgICAgICAgICBhY3Rpb246ICdsb2dvdXQnIFxuICAgICAgICAgICAgfSwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29uc3QgYWRkUHJvamVjdCA9IGFzeW5jIChwcm9qZWN0OiBPbWl0PFByb2plY3QsICdpZCcgfCAnc3ViUHJvamVjdHMnPikgPT4ge1xuICAgIGlmICghY3VycmVudFVzZXIpIHRocm93IG5ldyBFcnJvcihcIlVzZXIgbm90IGF1dGhlbnRpY2F0ZWRcIik7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyBwYXJlbnRQcm9qZWN0SWQsIC4uLnJlc3RPZlByb2plY3QgfSA9IHByb2plY3Q7XG4gICAgICAgIC8vIGRlZmF1bHQgb3duZXIgbWVtYmVyc2hpcCBoYW5kbGVkIGJ5IGJhY2tlbmRcbiAgICAgICAgY29uc3QgcGF5bG9hZDogYW55ID0geyAuLi5yZXN0T2ZQcm9qZWN0IH07XG4gICAgICAgIGlmIChwYXJlbnRQcm9qZWN0SWQpIHBheWxvYWQucGFyZW50UHJvamVjdElkID0gcGFyZW50UHJvamVjdElkO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgbmV3UHJvamVjdCA9IGF3YWl0IGNyZWF0ZVByb2plY3QocGF5bG9hZCk7XG4gICAgICAgIFxuICAgICAgICAvLyBJbnZhbGlkYXRlIGFsbCBwcm9qZWN0IGNhY2hlc1xuICAgICAgICBpbnZhbGlkYXRlQWxsUHJvamVjdENhY2hlcygpO1xuICAgICAgICBcbiAgICAgICAgLy8gSW5zdGVhZCBvZiBvcHRpbWlzdGljIHVwZGF0ZXMgdGhhdCBtYXkgaGF2ZSB3cm9uZyBtZW1iZXJzaGlwIGRhdGEsXG4gICAgICAgIC8vIHJlZnJlc2ggdGhlIHByb2plY3RzIGxpc3QgdG8gZ2V0IGFjY3VyYXRlIGFjY2VzcyBwZXJtaXNzaW9uc1xuICAgICAgICBhd2FpdCByZWZyZXNoUHJvamVjdHMoKTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBuZXdQcm9qZWN0O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBhZGRpbmcgcHJvamVjdDogXCIsIGVycm9yKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHVwZGF0ZVByb2plY3QgPSBhc3luYyAocHJvamVjdElkOiBzdHJpbmcsIHByb2plY3REYXRhOiBQYXJ0aWFsPE9taXQ8UHJvamVjdCwgJ2lkJyB8ICdzdWJQcm9qZWN0cyc+PikgPT4ge1xuICAgIGlmICghY3VycmVudFVzZXIpIHRocm93IG5ldyBFcnJvcihcIlVzZXIgbm90IGF1dGhlbnRpY2F0ZWRcIik7XG5cbiAgICB0cnkge1xuICAgICAgICAvLyBPcHRpbWlzdGljYWxseSB1cGRhdGUgcHJvamVjdCBpbiBsb2NhbCBzdGF0ZVxuICAgICAgICBzZXRQcm9qZWN0cyhwcmV2ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZVByb2plY3QgPSAocHJvamVjdHM6IFByb2plY3RbXSk6IFByb2plY3RbXSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb2plY3RzLm1hcChwID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHAuaWQgPT09IHByb2plY3RJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlZCA9IHsgLi4ucCwgLi4ucHJvamVjdERhdGEgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBjYWNoZSBvcHRpbWlzdGljYWxseVxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZVByb2plY3QodXBkYXRlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocC5zdWJQcm9qZWN0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgLi4ucCwgc3ViUHJvamVjdHM6IHVwZGF0ZVByb2plY3QocC5zdWJQcm9qZWN0cykgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlUHJvamVjdChwcmV2KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgYXdhaXQgdXBkYXRlUHJvamVjdEFwaShwcm9qZWN0SWQsIHByb2plY3REYXRhKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEludmFsaWRhdGUgcHJvamVjdCBjYWNoZXNcbiAgICAgICAgaW52YWxpZGF0ZVByb2plY3RDYWNoZXMocHJvamVjdElkKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgdXBkYXRpbmcgcHJvamVjdChzKTogXCIsIGVycm9yKTtcbiAgICAgICAgLy8gUmV2ZXJ0IG9wdGltaXN0aWMgdXBkYXRlIG9uIGVycm9yXG4gICAgICAgIGlmKGN1cnJlbnRVc2VyPy5pZCkgYXdhaXQgZmV0Y2hEYXRhKGN1cnJlbnRVc2VyLmlkKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGdldFByb2plY3QgPSBhc3luYyAocHJvamVjdElkOiBzdHJpbmcpOiBQcm9taXNlPFByb2plY3QgfCBudWxsPiA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcCA9IGF3YWl0IGFwaUdldFByb2plY3QocHJvamVjdElkKTtcbiAgICAgICAgY29uc3QgcHJvaiA9IHJlc3AgPyAobm9ybWFsaXplUHJvamVjdChyZXNwKSBhcyBQcm9qZWN0KSA6IG51bGw7XG4gICAgICAgIGlmIChwcm9qKSB7XG4gICAgICAgICAgICAvLyB1cHNlcnQgaW50byBsb2NhbCBwcm9qZWN0cyBzdGF0ZSBzbyBVSSBjb21wb25lbnRzIHVzaW5nIGBwcm9qZWN0c2AgZ2V0IHRoZSBub3JtYWxpemVkIHByb2plY3RcbiAgICAgICAgICAgIHNldFByb2plY3RzKHByZXYgPT4ge1xuICAgICAgICAgICAgICAgIC8vIHRyeSB0byByZXBsYWNlIGV4aXN0aW5nIHByb2plY3QgaW4gbmVzdGVkIHRyZWVcbiAgICAgICAgICAgICAgICBjb25zdCByZXBsYWNlID0gKGFycjogUHJvamVjdFtdKTogUHJvamVjdFtdID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyci5tYXAocCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocC5pZCA9PT0gcHJvai5pZCkgcmV0dXJuIHsgLi4ucHJvaiwgc3ViUHJvamVjdHM6IHAuc3ViUHJvamVjdHMgfHwgW10gfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwLnN1YlByb2plY3RzKSByZXR1cm4geyAuLi5wLCBzdWJQcm9qZWN0czogcmVwbGFjZShwLnN1YlByb2plY3RzKSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvLyBpZiBwcm9qZWN0IGV4aXN0cyBzb21ld2hlcmUsIHJlcGxhY2UgaXRcbiAgICAgICAgICAgICAgICBjb25zdCBleGlzdHMgPSAoZnVuY3Rpb24gZmluZChhcnI6IFByb2plY3RbXSk6IGJvb2xlYW4ge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHAgb2YgYXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocC5pZCA9PT0gcHJvai5pZCkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocC5zdWJQcm9qZWN0cyAmJiBmaW5kKHAuc3ViUHJvamVjdHMpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSkocHJldik7XG5cbiAgICAgICAgICAgICAgICBpZiAoZXhpc3RzKSByZXR1cm4gcmVwbGFjZShwcmV2KTtcblxuICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSBhcHBlbmQgYXQgcm9vdFxuICAgICAgICAgICAgICAgIHJldHVybiBbLi4ucHJldiwgeyAuLi4ocHJvaiBhcyBhbnkpLCBzdWJQcm9qZWN0czogcHJvai5zdWJQcm9qZWN0cyB8fCBbXSB9XTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9qO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBnZXR0aW5nIHByb2plY3Q6IFwiLCBlcnJvcik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfTtcblxuICAgIGNvbnN0IGR1cGxpY2F0ZVByb2plY3QgPSBhc3luYyAocHJvamVjdElkOiBzdHJpbmcpID0+IHtcbiAgICAgICAgaWYgKCFjdXJyZW50VXNlcikgdGhyb3cgbmV3IEVycm9yKFwiVXNlciBub3QgYXV0aGVudGljYXRlZFwiKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgaWRNYXAgPSBuZXcgTWFwPHN0cmluZywgc3RyaW5nPigpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBmaW5kUHJvamVjdEluU3RhdGUgPSAocHJvanM6IFByb2plY3RbXSwgcElkOiBzdHJpbmcpOiBQcm9qZWN0IHwgbnVsbCA9PiB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwIG9mIHByb2pzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwLmlkID09PSBwSWQpIHJldHVybiBwO1xuICAgICAgICAgICAgICAgICAgICBpZiAocC5zdWJQcm9qZWN0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZm91bmQgPSBmaW5kUHJvamVjdEluU3RhdGUocC5zdWJQcm9qZWN0cywgcElkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGZvdW5kO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgY29uc3QgZ2V0UHJvamVjdHNUb0R1cGxpY2F0ZSA9IChwcm9qZWN0OiBQcm9qZWN0KTogUHJvamVjdFtdID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgbGlzdDogUHJvamVjdFtdID0gW3Byb2plY3RdO1xuICAgICAgICAgICAgICAgIGlmIChwcm9qZWN0LnN1YlByb2plY3RzKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2plY3Quc3ViUHJvamVjdHMuZm9yRWFjaChzdWIgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdCA9IGxpc3QuY29uY2F0KGdldFByb2plY3RzVG9EdXBsaWNhdGUoc3ViKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbGlzdDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGNvbnN0IHJvb3RQcm9qZWN0VG9EdXBsaWNhdGUgPSBmaW5kUHJvamVjdEluU3RhdGUocHJvamVjdHMsIHByb2plY3RJZCk7XG4gICAgICAgICAgICBpZiAoIXJvb3RQcm9qZWN0VG9EdXBsaWNhdGUpIHRocm93IG5ldyBFcnJvcihcIlByb2plY3QgdG8gZHVwbGljYXRlIG5vdCBmb3VuZC5cIik7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IGFsbFByb2plY3RzVG9EdXBsaWNhdGUgPSBnZXRQcm9qZWN0c1RvRHVwbGljYXRlKHJvb3RQcm9qZWN0VG9EdXBsaWNhdGUpO1xuICAgICAgICAgICAgY29uc3Qgb2xkUHJvamVjdElkcyA9IGFsbFByb2plY3RzVG9EdXBsaWNhdGUubWFwKHAgPT4gcC5pZCk7XG5cbiAgICAgICAgICAgIC8vIGR1cGxpY2F0aW9uIGlzIGNvbXBsZXg7IGZhbGwgYmFjayB0byBjcmVhdGluZyBjb3BpZXMgdmlhIGJhY2tlbmQgd2hlcmUgcG9zc2libGVcbiAgICAgICAgICAgIGZvciAoY29uc3QgcCBvZiBhbGxQcm9qZWN0c1RvRHVwbGljYXRlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBpZCwgc3ViUHJvamVjdHMsIG1lbWJlcnMsIC4uLnByb2plY3REYXRhIH0gPSBwO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBheWxvYWQ6IGFueSA9IHsgLi4ucHJvamVjdERhdGEsIG5hbWU6IGAke3AubmFtZX0gKENvcHkpYCB9O1xuICAgICAgICAgICAgICAgIC8vIGJhY2tlbmQgc2hvdWxkIGNyZWF0ZSBuZXcgcHJvamVjdCBhbmQgaGFuZGxlIHBhcmVudCBsaW5rYWdlXG4gICAgICAgICAgICAgICAgYXdhaXQgY3JlYXRlUHJvamVjdChwYXlsb2FkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKG9sZFByb2plY3RJZHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIGR1cGxpY2F0ZSB0YXNrcyB2aWEgYmFja2VuZDogZmV0Y2ggYW5kIHJlY3JlYXRlXG4gICAgICAgICAgICAgICAgLy8gZmV0Y2ggdGFza3MgZm9yIGVhY2ggb2xkUHJvamVjdElkIGFuZCBjcmVhdGUgbmV3IG9uZXNcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG9sZElkIG9mIG9sZFByb2plY3RJZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFza3MgPSBhd2FpdCBnZXRUYXNrc0J5UHJvamVjdElkcyhbb2xkSWRdKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB0IG9mIHRhc2tzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdQcm9qZWN0SWQgPSBpZE1hcC5nZXQodC5wcm9qZWN0SWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1Byb2plY3RJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgaWQ6IHRpZCwgLi4udGFza0RhdGEgfSA9IHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgY3JlYXRlVGFza0FwaSh7IC4uLnRhc2tEYXRhLCBwcm9qZWN0SWQ6IG5ld1Byb2plY3RJZCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgYXdhaXQgcmVmcmVzaFByb2plY3RzKCk7XG4gICAgICAgICAgICBcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBkdXBsaWNhdGluZyBwcm9qZWN0OlwiLCBlcnJvcik7XG4gICAgICAgICAgICBhd2FpdCByZWZyZXNoUHJvamVjdHMoKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBcbiAgICBjb25zdCBkZWxldGVQcm9qZWN0ID0gYXN5bmMgKHByb2plY3RJZDogc3RyaW5nLCBwYXRobmFtZTogc3RyaW5nKSA9PiB7XG4gICAgICAgIGlmICghY3VycmVudFVzZXIpIHRocm93IG5ldyBFcnJvcihcIlVzZXIgbm90IGF1dGhlbnRpY2F0ZWRcIik7XG4gICAgXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBnZXRQcm9qZWN0SWRzRnJvbVN0YXRlID0gKGFsbFByb2plY3RzOiBQcm9qZWN0W10sIHN0YXJ0SWQ6IHN0cmluZyk6IHN0cmluZ1tdID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgaWRzOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbmRBbmRDb2xsZWN0ID0gKHByb2pzOiBQcm9qZWN0W10sIHBJZDogc3RyaW5nKTogYm9vbGVhbiA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcCBvZiBwcm9qcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHAuaWQgPT09IHBJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbGxlY3QgPSAocHJvajogUHJvamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZHMucHVzaChwcm9qLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb2ouc3ViUHJvamVjdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2ouc3ViUHJvamVjdHMuZm9yRWFjaChjb2xsZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdChwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwLnN1YlByb2plY3RzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbmRBbmRDb2xsZWN0KHAuc3ViUHJvamVjdHMsIHBJZCkpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgIFxuICAgICAgICAgICAgICAgIGZpbmRBbmRDb2xsZWN0KGFsbFByb2plY3RzLCBzdGFydElkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWRzO1xuICAgICAgICAgICAgfTtcbiAgICBcbiAgICAgICAgICAgIGNvbnN0IGFsbFByb2plY3RJZHNUb0RlbGV0ZSA9IGdldFByb2plY3RJZHNGcm9tU3RhdGUocHJvamVjdHMsIHByb2plY3RJZCk7XG5cbiAgICAgICAgICAgIC8vIE9wdGltaXN0aWNhbGx5IHJlbW92ZSBwcm9qZWN0cyBmcm9tIGxvY2FsIHN0YXRlXG4gICAgICAgICAgICBzZXRQcm9qZWN0cyhwcmV2ID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZW1vdmVQcm9qZWN0ID0gKHByb2plY3RzOiBQcm9qZWN0W10sIHRhcmdldElkOiBzdHJpbmcpOiBQcm9qZWN0W10gPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvamVjdHMuZmlsdGVyKHAgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHAuaWQgPT09IHRhcmdldElkKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocC5zdWJQcm9qZWN0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuc3ViUHJvamVjdHMgPSByZW1vdmVQcm9qZWN0KHAuc3ViUHJvamVjdHMsIHRhcmdldElkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGxldCB1cGRhdGVkUHJvamVjdHMgPSBwcmV2O1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcElkIG9mIGFsbFByb2plY3RJZHNUb0RlbGV0ZSkge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVkUHJvamVjdHMgPSByZW1vdmVQcm9qZWN0KHVwZGF0ZWRQcm9qZWN0cywgcElkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZWRQcm9qZWN0cztcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBBbHNvIG9wdGltaXN0aWNhbGx5IHJlbW92ZSByZWxhdGVkIHRhc2tzXG4gICAgICAgICAgICBzZXRUYXNrcyhwcmV2ID0+IHByZXYuZmlsdGVyKHRhc2sgPT4gIWFsbFByb2plY3RJZHNUb0RlbGV0ZS5pbmNsdWRlcyh0YXNrLnByb2plY3RJZCkpKTtcbiAgICBcbiAgICAgICAgICAgIC8vIGRlbGV0ZSBwcm9qZWN0cyB2aWEgYmFja2VuZFxuICAgICAgICAgICAgZm9yIChjb25zdCBwSWQgb2YgYWxsUHJvamVjdElkc1RvRGVsZXRlKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgZGVsZXRlUHJvamVjdEFwaShwSWQpO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgY29uc3QgcmVtYWluaW5nUHJvamVjdElkcyA9IG5ldyBTZXQoYWxsUHJvamVjdElkc1RvRGVsZXRlKTtcbiAgICAgICAgICAgIGNvbnN0IGlzVmlld2luZ0RlbGV0ZWRQcm9qZWN0ID0gWy4uLnJlbWFpbmluZ1Byb2plY3RJZHNdLnNvbWUoaWQgPT4gcGF0aG5hbWUuaW5jbHVkZXMoaWQpKTtcblxuICAgICAgICAgICAgaWYgKGlzVmlld2luZ0RlbGV0ZWRQcm9qZWN0KSB7XG4gICAgICAgICAgICAgICAgcm91dGVyLnB1c2goJy9kYXNoYm9hcmQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkZJTkFMIERFTEVUSU9OIEVSUk9SOlwiLCBlcnJvcik7XG4gICAgICAgICAgICAvLyBSZXZlcnQgb3B0aW1pc3RpYyB1cGRhdGUgb24gZXJyb3JcbiAgICAgICAgICAgIGlmKGN1cnJlbnRVc2VyLmlkKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgZmV0Y2hEYXRhKGN1cnJlbnRVc2VyLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfTtcblxuICAvLyBQcm9qZWN0IE1lbWJlciBNYW5hZ2VtZW50XG4gIGNvbnN0IGFkZFByb2plY3RNZW1iZXJGdW5jID0gYXN5bmMgKHByb2plY3RJZDogc3RyaW5nLCB1c2VySWQ6IHN0cmluZywgcm9sZTogc3RyaW5nKSA9PiB7XG4gICAgaWYgKCFjdXJyZW50VXNlcikgdGhyb3cgbmV3IEVycm9yKFwiVXNlciBub3QgYXV0aGVudGljYXRlZFwiKTtcbiAgICB0cnkge1xuICAgICAgLy8gT3B0aW1pc3RpY2FsbHkgYWRkIG1lbWJlciB0byBsb2NhbCBzdGF0ZVxuICAgICAgc2V0UHJvamVjdHMocHJldiA9PiB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZVByb2plY3QgPSAocHJvamVjdHM6IFByb2plY3RbXSk6IFByb2plY3RbXSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHByb2plY3RzLm1hcChwID0+IHtcbiAgICAgICAgICAgIGlmIChwLmlkID09PSBwcm9qZWN0SWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5wLFxuICAgICAgICAgICAgICAgIG1lbWJlcnM6IHtcbiAgICAgICAgICAgICAgICAgIC4uLihwLm1lbWJlcnMgfHwge30pLFxuICAgICAgICAgICAgICAgICAgW3VzZXJJZF06IHJvbGUgYXMgUHJvamVjdFJvbGVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocC5zdWJQcm9qZWN0cykge1xuICAgICAgICAgICAgICByZXR1cm4geyAuLi5wLCBzdWJQcm9qZWN0czogdXBkYXRlUHJvamVjdChwLnN1YlByb2plY3RzKSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB1cGRhdGVQcm9qZWN0KHByZXYpO1xuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IGFkZFByb2plY3RNZW1iZXIocHJvamVjdElkLCB1c2VySWQsIHJvbGUpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgYWRkaW5nIHByb2plY3QgbWVtYmVyOlwiLCBlcnJvcik7XG4gICAgICAvLyBSZXZlcnQgb3B0aW1pc3RpYyB1cGRhdGUgb24gZXJyb3JcbiAgICAgIGF3YWl0IGZldGNoRGF0YShjdXJyZW50VXNlci5pZCk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgdXBkYXRlUHJvamVjdE1lbWJlclJvbGVGdW5jID0gYXN5bmMgKHByb2plY3RJZDogc3RyaW5nLCB1c2VySWQ6IHN0cmluZywgcm9sZTogc3RyaW5nKSA9PiB7XG4gICAgaWYgKCFjdXJyZW50VXNlcikgdGhyb3cgbmV3IEVycm9yKFwiVXNlciBub3QgYXV0aGVudGljYXRlZFwiKTtcbiAgICB0cnkge1xuICAgICAgLy8gT3B0aW1pc3RpY2FsbHkgdXBkYXRlIG1lbWJlciByb2xlIGluIGxvY2FsIHN0YXRlXG4gICAgICBzZXRQcm9qZWN0cyhwcmV2ID0+IHtcbiAgICAgICAgY29uc3QgdXBkYXRlUHJvamVjdCA9IChwcm9qZWN0czogUHJvamVjdFtdKTogUHJvamVjdFtdID0+IHtcbiAgICAgICAgICByZXR1cm4gcHJvamVjdHMubWFwKHAgPT4ge1xuICAgICAgICAgICAgaWYgKHAuaWQgPT09IHByb2plY3RJZCAmJiBwLm1lbWJlcnMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5wLFxuICAgICAgICAgICAgICAgIG1lbWJlcnM6IHtcbiAgICAgICAgICAgICAgICAgIC4uLnAubWVtYmVycyxcbiAgICAgICAgICAgICAgICAgIFt1c2VySWRdOiByb2xlIGFzIFByb2plY3RSb2xlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHAuc3ViUHJvamVjdHMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHsgLi4ucCwgc3ViUHJvamVjdHM6IHVwZGF0ZVByb2plY3QocC5zdWJQcm9qZWN0cykgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdXBkYXRlUHJvamVjdChwcmV2KTtcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCB1cGRhdGVQcm9qZWN0TWVtYmVyUm9sZShwcm9qZWN0SWQsIHVzZXJJZCwgcm9sZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciB1cGRhdGluZyBwcm9qZWN0IG1lbWJlciByb2xlOlwiLCBlcnJvcik7XG4gICAgICAvLyBSZXZlcnQgb3B0aW1pc3RpYyB1cGRhdGUgb24gZXJyb3JcbiAgICAgIGF3YWl0IGZldGNoRGF0YShjdXJyZW50VXNlci5pZCk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgcmVtb3ZlUHJvamVjdE1lbWJlckZ1bmMgPSBhc3luYyAocHJvamVjdElkOiBzdHJpbmcsIHVzZXJJZDogc3RyaW5nKSA9PiB7XG4gICAgaWYgKCFjdXJyZW50VXNlcikgdGhyb3cgbmV3IEVycm9yKFwiVXNlciBub3QgYXV0aGVudGljYXRlZFwiKTtcbiAgICB0cnkge1xuICAgICAgLy8gT3B0aW1pc3RpY2FsbHkgcmVtb3ZlIG1lbWJlciBmcm9tIGxvY2FsIHN0YXRlXG4gICAgICBzZXRQcm9qZWN0cyhwcmV2ID0+IHtcbiAgICAgICAgY29uc3QgdXBkYXRlUHJvamVjdCA9IChwcm9qZWN0czogUHJvamVjdFtdKTogUHJvamVjdFtdID0+IHtcbiAgICAgICAgICByZXR1cm4gcHJvamVjdHMubWFwKHAgPT4ge1xuICAgICAgICAgICAgaWYgKHAuaWQgPT09IHByb2plY3RJZCAmJiBwLm1lbWJlcnMpIHtcbiAgICAgICAgICAgICAgY29uc3QgbmV3TWVtYmVycyA9IHsgLi4ucC5tZW1iZXJzIH07XG4gICAgICAgICAgICAgIGRlbGV0ZSBuZXdNZW1iZXJzW3VzZXJJZF07XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4ucCxcbiAgICAgICAgICAgICAgICBtZW1iZXJzOiBuZXdNZW1iZXJzXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocC5zdWJQcm9qZWN0cykge1xuICAgICAgICAgICAgICByZXR1cm4geyAuLi5wLCBzdWJQcm9qZWN0czogdXBkYXRlUHJvamVjdChwLnN1YlByb2plY3RzKSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB1cGRhdGVQcm9qZWN0KHByZXYpO1xuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IHJlbW92ZVByb2plY3RNZW1iZXIocHJvamVjdElkLCB1c2VySWQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgcmVtb3ZpbmcgcHJvamVjdCBtZW1iZXI6XCIsIGVycm9yKTtcbiAgICAgIC8vIFJldmVydCBvcHRpbWlzdGljIHVwZGF0ZSBvbiBlcnJvclxuICAgICAgYXdhaXQgZmV0Y2hEYXRhKGN1cnJlbnRVc2VyLmlkKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfTtcblxuXG4gIGNvbnN0IGFkZFRhc2sgPSBhc3luYyAodGFzazogT21pdDxUYXNrLCAnaWQnPik6IFByb21pc2U8VGFzaz4gPT4ge1xuICAgIGlmICghY3VycmVudFVzZXIpIHRocm93IG5ldyBFcnJvcihcIlVzZXIgbm90IGF1dGhlbnRpY2F0ZWRcIik7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYm9keTogYW55ID0geyAuLi50YXNrIH07XG4gICAgICAgIFxuICAgICAgICAvLyBDb252ZXJ0IHN0YXR1cyBmaWVsZCB0byBzdGF0dXNJZCBmb3IgQVBJIGNvbXBhdGliaWxpdHlcbiAgICAgICAgaWYgKGJvZHkuc3RhdHVzKSB7XG4gICAgICAgICAgICBib2R5LnN0YXR1c0lkID0gYm9keS5zdGF0dXM7XG4gICAgICAgICAgICBkZWxldGUgYm9keS5zdGF0dXM7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIHJlbW92ZSB1bmRlZmluZWQsIG51bGwsIGFuZCBlbXB0eS1zdHJpbmcgdmFsdWVzIHRvIGF2b2lkIHNlbmRpbmcgaW52YWxpZCBGSyByZWZlcmVuY2VzXG4gICAgICAgIE9iamVjdC5rZXlzKGJvZHkpLmZvckVhY2goayA9PiB7XG4gICAgICAgICAgICBpZiAoYm9keVtrXSA9PT0gdW5kZWZpbmVkIHx8IGJvZHlba10gPT09IG51bGwgfHwgKHR5cGVvZiBib2R5W2tdID09PSAnc3RyaW5nJyAmJiBib2R5W2tdLnRyaW0oKSA9PT0gJycpKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGJvZHlba107XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgLy8gQ2FsbCBBUEkgdG8gY3JlYXRlIHRhc2tcbiAgICAgICAgY29uc3QgbmV3VGFzayA9IGF3YWl0IGNyZWF0ZVRhc2tBcGkoYm9keSk7XG4gICAgICAgIFxuICAgICAgICAvLyBJbnZhbGlkYXRlIHRhc2sgY2FjaGVzIGZvciBhZmZlY3RlZCBwcm9qZWN0c1xuICAgICAgICBpZiAobmV3VGFzayAmJiBuZXdUYXNrLnByb2plY3RJZCkge1xuICAgICAgICAgICAgaW52YWxpZGF0ZVRhc2tDYWNoZXMobmV3VGFzayk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIE9wdGltaXN0aWNhbGx5IGFkZCB0aGUgdGFzayB0byBsb2NhbCBzdGF0ZSAoU1NFIHdpbGwgYWxzbyBicm9hZGNhc3QsIGJ1dCB3ZSBoYXZlIGR1cGxpY2F0ZSBwcm90ZWN0aW9uKVxuICAgICAgICBpZiAobmV3VGFzaykge1xuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZFRhc2sgPSB7XG4gICAgICAgICAgICAgICAgLi4ubmV3VGFzayxcbiAgICAgICAgICAgICAgICBzdGF0dXM6IG5ld1Rhc2suc3RhdHVzID8/IG5ld1Rhc2suc3RhdHVzSWQgPz8gbnVsbCxcbiAgICAgICAgICAgICAgICBhc3NpZ25lZUlkOiBuZXdUYXNrLmFzc2lnbmVlSWQgPz8gdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHBhcmVudElkOiBuZXdUYXNrLnBhcmVudElkID8/IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHNldFRhc2tzKHByZXYgPT4ge1xuICAgICAgICAgICAgICAgIC8vIEV4dHJhIHNhZmV0eSBjaGVjayB0byBwcmV2ZW50IGR1cGxpY2F0ZXNcbiAgICAgICAgICAgICAgICBpZiAocHJldi5maW5kKHQgPT4gdC5pZCA9PT0gbm9ybWFsaXplZFRhc2suaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gWy4uLnByZXYsIG5vcm1hbGl6ZWRUYXNrXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplZFRhc2s7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGNyZWF0ZSB0YXNrJyk7XG5cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgYWRkaW5nIHRhc2s6IFwiLCBlcnJvcik7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCB1cGRhdGVUYXNrID0gYXN5bmMgKHVwZGF0ZWRUYXNrOiBUYXNrKSA9PiB7XG4gICAgaWYgKCFjdXJyZW50VXNlcikgdGhyb3cgbmV3IEVycm9yKFwiVXNlciBub3QgYXV0aGVudGljYXRlZFwiKTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgICBjb25zdCB7IGlkLCAuLi50YXNrRGF0YSB9ID0gdXBkYXRlZFRhc2s7XG4gICAgICAgIGNvbnN0IGJvZHk6IGFueSA9IHsgLi4udGFza0RhdGEgfTtcbiAgICAgICAgLy8gcmVtb3ZlIHVuZGVmaW5lZCBmaWVsZHNcbiAgICAgICAgT2JqZWN0LmtleXMoYm9keSkuZm9yRWFjaChrID0+IGJvZHlba10gPT09IHVuZGVmaW5lZCAmJiBkZWxldGUgYm9keVtrXSk7XG5cbiAgICAgICAgLy8gc3RyaXAgc2VydmVyLW9ubHkgdGltZXN0YW1wIGZpZWxkcyBpZiBwcmVzZW50XG4gICAgICAgIGRlbGV0ZSBib2R5LmNyZWF0ZWRBdDtcbiAgICAgICAgZGVsZXRlIGJvZHkudXBkYXRlZEF0O1xuXG4gICAgICAgIC8vIE5vcm1hbGl6ZSBzdGF0dXM6IGVuc3VyZSB3ZSBzZW5kIG9ubHkgYHN0YXR1c0lkYCAoYmFja2VuZCBhY2NlcHRzIGVpdGhlciBidXQgcHJlZmVycyBzdGF0dXNJZCB3aGVuIGJvdGggcHJlc2VudCkuXG4gICAgICAgIC8vIElmIHRoZSBjYWxsZXIgcHJvdmlkZWQgYHN0YXR1c2AgKG5ldyBpZCksIHVzZSBpdDsgb3RoZXJ3aXNlIGtlZXAgYW55IGV4cGxpY2l0IHN0YXR1c0lkLlxuICAgICAgICBpZiAoYm9keS5zdGF0dXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYm9keS5zdGF0dXNJZCA9IGJvZHkuc3RhdHVzO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlbW92ZSBjbGllbnQtc2lkZSBgc3RhdHVzYCBmaWVsZCB0byBhdm9pZCBzZW5kaW5nIGJvdGhcbiAgICAgICAgZGVsZXRlIGJvZHkuc3RhdHVzO1xuXG4gICAgICAgIC8vIG9wdGltaXN0aWMgdXBkYXRlOiBtZXJnZSB0aGUgcmVxdWVzdGVkIGNoYW5nZXMgaW50byBsb2NhbCBzdGF0ZSBzbyBVSSB1cGRhdGVzIGltbWVkaWF0ZWx5XG4gICAgICAgIGNvbnN0IG9wdGltaXN0aWMgPSB7XG4gICAgICAgICAgICAuLi51cGRhdGVkVGFzayxcbiAgICAgICAgICAgIC8vIGVuc3VyZSB3ZSByZWZsZWN0IHRoZSByZXF1ZXN0ZWQgc3RhdHVzSWQvc3RhdHVzIHNoYXBlXG4gICAgICAgICAgICBzdGF0dXM6IGJvZHkuc3RhdHVzSWQgPz8gdXBkYXRlZFRhc2suc3RhdHVzID8/IG51bGwsXG4gICAgICAgICAgICBhc3NpZ25lZUlkOiBib2R5LmFzc2lnbmVlSWQgIT09IHVuZGVmaW5lZCA/IGJvZHkuYXNzaWduZWVJZCA6IHVwZGF0ZWRUYXNrLmFzc2lnbmVlSWQsXG4gICAgICAgICAgICBwYXJlbnRJZDogYm9keS5wYXJlbnRJZCAhPT0gdW5kZWZpbmVkID8gYm9keS5wYXJlbnRJZCA6IHVwZGF0ZWRUYXNrLnBhcmVudElkLFxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgLy8gVXBkYXRlIGxvY2FsIHN0YXRlXG4gICAgICAgIHNldFRhc2tzKHByZXYgPT4gcHJldi5tYXAodCA9PiB0LmlkID09PSBpZCA/IG9wdGltaXN0aWMgOiB0KSk7XG4gICAgICAgIFxuICAgICAgICAvLyBVcGRhdGUgY2FjaGUgb3B0aW1pc3RpY2FsbHlcbiAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZVRhc2sob3B0aW1pc3RpYyk7XG5cbiAgICAgICAgLy8gY2FsbCBBUEkgYW5kIHJlY29uY2lsZSByZXNwb25zZVxuICAgICAgICBjb25zdCByZXNwOiBhbnkgPSBhd2FpdCB1cGRhdGVUYXNrQXBpKGlkLCBib2R5KTtcblxuICAgICAgICAvLyBJbnZhbGlkYXRlIHRhc2sgY2FjaGVzIGZvciBhZmZlY3RlZCBwcm9qZWN0c1xuICAgICAgICBpbnZhbGlkYXRlVGFza0NhY2hlcyhvcHRpbWlzdGljKTtcblxuICAgICAgICAvLyBub3JtYWxpemUgcmVzcG9uc2UgdG8gZnJvbnRlbmQgc2hhcGUgKG1hdGNoIGZldGNoVGFza3NGb3JDaHVua3Mgbm9ybWFsaXphdGlvbilcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IHtcbiAgICAgICAgICAgIC4uLnJlc3AsXG4gICAgICAgICAgICBzdGF0dXM6IHJlc3Auc3RhdHVzID8/IHJlc3Auc3RhdHVzSWQgPz8gbnVsbCxcbiAgICAgICAgICAgIGFzc2lnbmVlSWQ6IHJlc3AuYXNzaWduZWVJZCA/PyB1bmRlZmluZWQsXG4gICAgICAgICAgICBwYXJlbnRJZDogcmVzcC5wYXJlbnRJZCA/PyB1bmRlZmluZWQsXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gcmVjb25jaWxlIGF1dGhvcml0YXRpdmUgc2VydmVyIHJlc3BvbnNlXG4gICAgICAgIHNldFRhc2tzKHByZXYgPT4gcHJldi5tYXAodCA9PiB0LmlkID09PSBub3JtYWxpemVkLmlkID8gbm9ybWFsaXplZCA6IHQpKTtcblxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciB1cGRhdGluZyB0YXNrOiBcIiwgZXJyb3IpO1xuICAgICAgICAvLyBJbnZhbGlkYXRlIGNhY2hlIHRvIGZvcmNlIHJlZnJlc2ggb24gZXJyb3JcbiAgICAgICAgaWYgKHVwZGF0ZWRUYXNrLnByb2plY3RJZCkge1xuICAgICAgICAgICAgaW52YWxpZGF0ZVRhc2tDYWNoZXModXBkYXRlZFRhc2spO1xuICAgICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIEZhc3QgdXBkYXRlIGZvciBkcmFnIG9wZXJhdGlvbnMgLSBvbmx5IHVwZGF0ZXMgVUksIGRlYm91bmNlcyBBUEkgY2FsbHNcbiAgY29uc3QgdXBkYXRlVGFza0ltbWVkaWF0ZSA9IHVzZUNhbGxiYWNrKCh1cGRhdGVkVGFzazogVGFzaykgPT4ge1xuICAgIGlmICghY3VycmVudFVzZXIpIHJldHVybjtcblxuICAgIC8vIFVwZGF0ZSBVSSBpbW1lZGlhdGVseVxuICAgIHNldFRhc2tzKHByZXYgPT4gcHJldi5tYXAodCA9PiB0LmlkID09PSB1cGRhdGVkVGFzay5pZCA/IHVwZGF0ZWRUYXNrIDogdCkpO1xuXG4gICAgLy8gU3RvcmUgdGhlIHBlbmRpbmcgdXBkYXRlXG4gICAgcGVuZGluZ1Rhc2tVcGRhdGVzLmN1cnJlbnQuc2V0KHVwZGF0ZWRUYXNrLmlkLCB1cGRhdGVkVGFzayk7XG5cbiAgICAvLyBDbGVhciBleGlzdGluZyB0aW1lb3V0IGZvciB0aGlzIHRhc2tcbiAgICBjb25zdCBleGlzdGluZ1RpbWVvdXQgPSB1cGRhdGVUYXNrVGltZW91dHMuY3VycmVudC5nZXQodXBkYXRlZFRhc2suaWQpO1xuICAgIGlmIChleGlzdGluZ1RpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dChleGlzdGluZ1RpbWVvdXQpO1xuICAgIH1cblxuICAgIC8vIFNldCBuZXcgZGVib3VuY2VkIEFQSSBjYWxsXG4gICAgY29uc3QgdGltZW91dCA9IHNldFRpbWVvdXQoYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGFza1RvVXBkYXRlID0gcGVuZGluZ1Rhc2tVcGRhdGVzLmN1cnJlbnQuZ2V0KHVwZGF0ZWRUYXNrLmlkKTtcbiAgICAgIGlmICh0YXNrVG9VcGRhdGUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCB7IGlkLCAuLi50YXNrRGF0YSB9ID0gdGFza1RvVXBkYXRlO1xuICAgICAgICAgIGNvbnN0IGJvZHk6IGFueSA9IHsgLi4udGFza0RhdGEgfTtcbiAgICAgICAgICBPYmplY3Qua2V5cyhib2R5KS5mb3JFYWNoKGsgPT4gYm9keVtrXSA9PT0gdW5kZWZpbmVkICYmIGRlbGV0ZSBib2R5W2tdKTtcblxuICAgICAgICAgIGRlbGV0ZSBib2R5LmNyZWF0ZWRBdDtcbiAgICAgICAgICBkZWxldGUgYm9keS51cGRhdGVkQXQ7XG5cbiAgICAgICAgICBpZiAoYm9keS5zdGF0dXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYm9keS5zdGF0dXNJZCA9IGJvZHkuc3RhdHVzO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWxldGUgYm9keS5zdGF0dXM7XG5cbiAgICAgICAgICBhd2FpdCB1cGRhdGVUYXNrQXBpKGlkLCBib2R5KTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDbGVhbiB1cFxuICAgICAgICAgIHBlbmRpbmdUYXNrVXBkYXRlcy5jdXJyZW50LmRlbGV0ZSh1cGRhdGVkVGFzay5pZCk7XG4gICAgICAgICAgdXBkYXRlVGFza1RpbWVvdXRzLmN1cnJlbnQuZGVsZXRlKHVwZGF0ZWRUYXNrLmlkKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW4gZGVib3VuY2VkIHRhc2sgdXBkYXRlOlwiLCBlcnJvcik7XG4gICAgICAgICAgLy8gUmV2ZXJ0IHRvIHNlcnZlciBzdGF0ZSBvbiBlcnJvclxuICAgICAgICAgIGlmIChjdXJyZW50VXNlcj8uaWQpIGF3YWl0IGZldGNoRGF0YShjdXJyZW50VXNlci5pZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCA1MDApOyAvLyA1MDBtcyBkZWJvdW5jZVxuXG4gICAgdXBkYXRlVGFza1RpbWVvdXRzLmN1cnJlbnQuc2V0KHVwZGF0ZWRUYXNrLmlkLCB0aW1lb3V0KTtcbiAgfSwgW2N1cnJlbnRVc2VyXSk7XG4gIFxuICBjb25zdCBkZWxldGVUYXNrID0gYXN5bmMgKHRhc2tJZDogc3RyaW5nKSA9PiB7XG4gICAgaWYgKCFjdXJyZW50VXNlcikgdGhyb3cgbmV3IEVycm9yKFwiVXNlciBub3QgYXV0aGVudGljYXRlZFwiKTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgICAvLyBPcHRpbWlzdGljYWxseSByZW1vdmUgdGhlIHRhc2sgZnJvbSBsb2NhbCBzdGF0ZVxuICAgICAgICBzZXRUYXNrcyhwcmV2ID0+IHByZXYuZmlsdGVyKHQgPT4gdC5pZCAhPT0gdGFza0lkKSk7XG4gICAgICAgIFxuICAgICAgICAvLyBDYWxsIEFQSSB0byBkZWxldGUgdGFza1xuICAgICAgICBhd2FpdCBkZWxldGVUYXNrQXBpKHRhc2tJZCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGRlbGV0aW5nIHRhc2s6IFwiLCBlcnJvcik7XG4gICAgICAgIC8vIFJldmVydCB0aGUgb3B0aW1pc3RpYyB1cGRhdGUgYnkgcmVmZXRjaGluZyBvbiBlcnJvclxuICAgICAgICBpZiAoY3VycmVudFVzZXI/LmlkKSBhd2FpdCBmZXRjaERhdGEoY3VycmVudFVzZXIuaWQpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgdXBkYXRlVXNlciA9IGFzeW5jICh1c2VySWQ6IHN0cmluZywgdXNlckRhdGE6IFBhcnRpYWw8UGljazxVc2VyLCAnbmFtZScgfCAnZW1haWwnIHwgJ2F2YXRhclVybCc+PikgPT4ge1xuICAgIGlmICghY3VycmVudFVzZXIpIHRocm93IG5ldyBFcnJvcihcIlVzZXIgbm90IGF1dGhlbnRpY2F0ZWRcIik7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwOiBhbnkgPSBhd2FpdCB1cGRhdGVVc2VyQXBpKHVzZXJJZCwgeyBuYW1lOiB1c2VyRGF0YS5uYW1lLCBlbWFpbDogdXNlckRhdGEuZW1haWwgfSk7XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkID0gcmVzcD8udXNlciB8fCB7IGlkOiB1c2VySWQsIC4uLnVzZXJEYXRhIH07XG5cbiAgICAgICAgICAgIHNldFVzZXJzKHByZXZVc2VycyA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3VXNlcnMgPSBuZXcgTWFwKHByZXZVc2Vycyk7XG4gICAgICAgICAgICAgICAgaWYgKG5ld1VzZXJzLmhhcyh1c2VySWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nVXNlciA9IG5ld1VzZXJzLmdldCh1c2VySWQpITtcbiAgICAgICAgICAgICAgICAgICAgbmV3VXNlcnMuc2V0KHVzZXJJZCwgeyAuLi5leGlzdGluZ1VzZXIsIC4uLnVwZGF0ZWQgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXdVc2VycztcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoY3VycmVudFVzZXIuaWQgPT09IHVzZXJJZCkge1xuICAgICAgICAgICAgICAgIHNldEN1cnJlbnRVc2VyKHByZXYgPT4gcHJldiA/IHsgLi4ucHJldiwgLi4udXBkYXRlZCB9IDogbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgdXBkYXRpbmcgdXNlcjpcIiwgZXJyb3IpO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgfTtcblxuICAgIGNvbnN0IGNyZWF0ZVVzZXIgPSBhc3luYyAodXNlcjogT21pdDxVc2VyLCAnaWQnPiwgcGFzc3dvcmQ6IHN0cmluZykgPT4ge1xuICAgICAgICBjb25zdCByZXNwID0gYXdhaXQgYXV0aFNpZ251cCh1c2VyLm5hbWUsIHVzZXIuZW1haWwsIHBhc3N3b3JkKTtcbiAgICAgICAgXG4gICAgICAgIC8vIENoZWNrIGlmIGl0J3MgYW4gZXhwZWN0ZWQgZXJyb3IgcmVzcG9uc2VcbiAgICAgICAgaWYgKHJlc3AgJiYgJ3N1Y2Nlc3MnIGluIHJlc3AgJiYgcmVzcC5zdWNjZXNzID09PSBmYWxzZSAmJiByZXNwLmlzRXhwZWN0ZWQpIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygnU2lnbnVwIGZhaWxlZCAtIHVzZXIgaW5wdXQgZXJyb3InLCB7XG4gICAgICAgICAgICAgICAgZW1haWw6IHVzZXIuZW1haWwsXG4gICAgICAgICAgICAgICAgYWN0aW9uOiAnc2lnbnVwJyxcbiAgICAgICAgICAgICAgICBlcnJvclR5cGU6ICd1c2VyX2lucHV0X2Vycm9yJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBwbGFpbiBlcnJvciBvYmplY3Qgd2l0aG91dCB0aHJvd2luZyB0byBhdm9pZCBjb25zb2xlIGxvZ2dpbmdcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0ge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHJlc3AuZXJyb3IsXG4gICAgICAgICAgICAgICAgc3RhdHVzOiByZXNwLnN0YXR1cyxcbiAgICAgICAgICAgICAgICBpc0V4cGVjdGVkOiB0cnVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGNyZWF0ZWQgPSByZXNwPy51c2VyIGFzIFVzZXIgfCB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChjcmVhdGVkKSB7XG4gICAgICAgICAgICAvLyBPcHRpb25hbGx5IHVwZGF0ZSBsb2NhbCB1c2VycyBsaXN0XG4gICAgICAgICAgICBzZXRVc2VycyhwcmV2ID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdVc2VycyA9IG5ldyBNYXAocHJldik7XG4gICAgICAgICAgICAgICAgbmV3VXNlcnMuc2V0KGNyZWF0ZWQuaWQsIGNyZWF0ZWQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXdVc2VycztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2V0Q3VycmVudFVzZXIoY3JlYXRlZCk7XG4gICAgICAgICAgICBhd2FpdCBmZXRjaERhdGEoY3JlYXRlZC5pZCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgYWRkUHJvamVjdFRhc2tTdGF0dXMgPSBhc3luYyAocHJvamVjdElkOiBzdHJpbmcsIHN0YXR1czogT21pdDxUYXNrU3RhdHVzT3B0aW9uLCAnaWQnPikgPT4ge1xuICAgICAgICBpZiAoIWN1cnJlbnRVc2VyKSB0aHJvdyBuZXcgRXJyb3IoJ1VzZXIgbm90IGF1dGhlbnRpY2F0ZWQnKTtcbiAgICAgICAgXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBHZW5lcmF0ZSBhIHRlbXBvcmFyeSBJRCBmb3Igb3B0aW1pc3RpYyB1cGRhdGVcbiAgICAgICAgICAgIGNvbnN0IHRlbXBJZCA9IGB0ZW1wLSR7RGF0ZS5ub3coKX1gO1xuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdTdGF0dXNlcyA9ICgoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvamVjdCA9IHByb2plY3RzLmZpbmQocCA9PiBwLmlkID09PSBwcm9qZWN0SWQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9qZWN0Py50YXNrU3RhdHVzT3B0aW9ucyB8fCBbXTtcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICBjb25zdCBuZXdPcmRlciA9IGV4aXN0aW5nU3RhdHVzZXMubGVuZ3RoO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBDcmVhdGUgb3B0aW1pc3RpYyBzdGF0dXMgb2JqZWN0XG4gICAgICAgICAgICBjb25zdCBvcHRpbWlzdGljU3RhdHVzOiBUYXNrU3RhdHVzT3B0aW9uID0ge1xuICAgICAgICAgICAgICAgIGlkOiB0ZW1wSWQsXG4gICAgICAgICAgICAgICAgbmFtZTogKHN0YXR1cyBhcyBhbnkpLm5hbWUgfHwgKHN0YXR1cyBhcyBhbnkpLmxhYmVsIHx8ICdTdGF0dXMnLFxuICAgICAgICAgICAgICAgIGNvbG9yOiAoc3RhdHVzIGFzIGFueSkuY29sb3IgfHwgJyMzQjgyRjYnLFxuICAgICAgICAgICAgICAgIG9yZGVyOiBuZXdPcmRlcixcbiAgICAgICAgICAgICAgICBzaG93U3RyaWtlVGhyb3VnaDogKHN0YXR1cyBhcyBhbnkpLnNob3dTdHJpa2VUaHJvdWdoIHx8IGZhbHNlLFxuICAgICAgICAgICAgICAgIGhpZGRlbjogKHN0YXR1cyBhcyBhbnkpLmhpZGRlbiB8fCBmYWxzZSxcbiAgICAgICAgICAgICAgICByZXF1aXJlc0NvbW1lbnQ6IChzdGF0dXMgYXMgYW55KS5yZXF1aXJlc0NvbW1lbnQgfHwgZmFsc2UsXG4gICAgICAgICAgICAgICAgYWxsb3dzQ29tbWVudDogKHN0YXR1cyBhcyBhbnkpLmFsbG93c0NvbW1lbnQgIT09IGZhbHNlXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBPcHRpbWlzdGljYWxseSBhZGQgdGhlIHN0YXR1cyB0byBsb2NhbCBzdGF0ZVxuICAgICAgICAgICAgc2V0UHJvamVjdHMocHJldiA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlUHJvamVjdCA9IChwcm9qZWN0czogUHJvamVjdFtdKTogUHJvamVjdFtdID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb2plY3RzLm1hcChwID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwLmlkID09PSBwcm9qZWN0SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXNrU3RhdHVzT3B0aW9uczogWy4uLihwLnRhc2tTdGF0dXNPcHRpb25zIHx8IFtdKSwgb3B0aW1pc3RpY1N0YXR1c11cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHAuc3ViUHJvamVjdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyAuLi5wLCBzdWJQcm9qZWN0czogdXBkYXRlUHJvamVjdChwLnN1YlByb2plY3RzKSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVByb2plY3QocHJldik7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gQ2FsbCBBUEkgdG8gY3JlYXRlIHN0YXR1c1xuICAgICAgICAgICAgY29uc3QgY3JlYXRlZFN0YXR1cyA9IGF3YWl0IGNyZWF0ZVByb2plY3RTdGF0dXMocHJvamVjdElkLCB7IFxuICAgICAgICAgICAgICAgIGxhYmVsOiBvcHRpbWlzdGljU3RhdHVzLm5hbWUsIFxuICAgICAgICAgICAgICAgIGNvbG9yOiBvcHRpbWlzdGljU3RhdHVzLmNvbG9yLCBcbiAgICAgICAgICAgICAgICBvcmRlcjogbmV3T3JkZXIsIFxuICAgICAgICAgICAgICAgIHNob3dTdHJpa2VUaHJvdWdoOiBvcHRpbWlzdGljU3RhdHVzLnNob3dTdHJpa2VUaHJvdWdoLCBcbiAgICAgICAgICAgICAgICBoaWRkZW46IG9wdGltaXN0aWNTdGF0dXMuaGlkZGVuLFxuICAgICAgICAgICAgICAgIHJlcXVpcmVzQ29tbWVudDogb3B0aW1pc3RpY1N0YXR1cy5yZXF1aXJlc0NvbW1lbnQsXG4gICAgICAgICAgICAgICAgYWxsb3dzQ29tbWVudDogb3B0aW1pc3RpY1N0YXR1cy5hbGxvd3NDb21tZW50XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gUmVwbGFjZSB0ZW1wIHN0YXR1cyB3aXRoIHJlYWwgb25lXG4gICAgICAgICAgICBzZXRQcm9qZWN0cyhwcmV2ID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB1cGRhdGVQcm9qZWN0ID0gKHByb2plY3RzOiBQcm9qZWN0W10pOiBQcm9qZWN0W10gPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvamVjdHMubWFwKHAgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHAuaWQgPT09IHByb2plY3RJZCAmJiBwLnRhc2tTdGF0dXNPcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4ucCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFza1N0YXR1c09wdGlvbnM6IHAudGFza1N0YXR1c09wdGlvbnMubWFwKHMgPT4gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzLmlkID09PSB0ZW1wSWQgPyB7IC4uLmNyZWF0ZWRTdGF0dXMsIG5hbWU6IGNyZWF0ZWRTdGF0dXMubGFiZWwgfHwgY3JlYXRlZFN0YXR1cy5uYW1lIH0gOiBzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHAuc3ViUHJvamVjdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyAuLi5wLCBzdWJQcm9qZWN0czogdXBkYXRlUHJvamVjdChwLnN1YlByb2plY3RzKSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVByb2plY3QocHJldik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFkZGluZyBwcm9qZWN0IHRhc2sgc3RhdHVzOicsIGVycm9yKTtcbiAgICAgICAgICAgIC8vIFJldmVydCBvcHRpbWlzdGljIHVwZGF0ZSBvbiBlcnJvclxuICAgICAgICAgICAgaWYgKGN1cnJlbnRVc2VyPy5pZCkgYXdhaXQgZmV0Y2hEYXRhKGN1cnJlbnRVc2VyLmlkKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IHVwZGF0ZVByb2plY3RUYXNrU3RhdHVzID0gYXN5bmMgKHByb2plY3RJZDogc3RyaW5nLCBzdGF0dXNJZDogc3RyaW5nLCBzdGF0dXNEYXRhOiBQYXJ0aWFsPE9taXQ8VGFza1N0YXR1c09wdGlvbiwgJ2lkJz4+KSA9PiB7XG4gICAgICAgIGlmICghY3VycmVudFVzZXIpIHRocm93IG5ldyBFcnJvcignVXNlciBub3QgYXV0aGVudGljYXRlZCcpO1xuICAgICAgICBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIE9wdGltaXN0aWNhbGx5IHVwZGF0ZSB0aGUgcHJvamVjdCBzdGF0dXMgaW4gbG9jYWwgc3RhdGVcbiAgICAgICAgICAgIHNldFByb2plY3RzKHByZXYgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZVByb2plY3QgPSAocHJvamVjdHM6IFByb2plY3RbXSk6IFByb2plY3RbXSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9qZWN0cy5tYXAocCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocC5pZCA9PT0gcHJvamVjdElkICYmIHAudGFza1N0YXR1c09wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXNrU3RhdHVzT3B0aW9uczogcC50YXNrU3RhdHVzT3B0aW9ucy5tYXAocyA9PiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMuaWQgPT09IHN0YXR1c0lkID8geyAuLi5zLCAuLi5zdGF0dXNEYXRhIH0gOiBzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHAuc3ViUHJvamVjdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyAuLi5wLCBzdWJQcm9qZWN0czogdXBkYXRlUHJvamVjdChwLnN1YlByb2plY3RzKSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVByb2plY3QocHJldik7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gQ2FsbCBBUEkgdG8gdXBkYXRlIHN0YXR1c1xuICAgICAgICAgICAgYXdhaXQgdXBkYXRlUHJvamVjdFN0YXR1cyhwcm9qZWN0SWQsIHN0YXR1c0lkLCB7IFxuICAgICAgICAgICAgICAgIGxhYmVsOiAoc3RhdHVzRGF0YSBhcyBhbnkpLm5hbWUgfHwgKHN0YXR1c0RhdGEgYXMgYW55KS5sYWJlbCwgXG4gICAgICAgICAgICAgICAgb3JkZXI6IChzdGF0dXNEYXRhIGFzIGFueSkub3JkZXIsIFxuICAgICAgICAgICAgICAgIGNvbG9yOiAoc3RhdHVzRGF0YSBhcyBhbnkpLmNvbG9yLCBcbiAgICAgICAgICAgICAgICBzaG93U3RyaWtlVGhyb3VnaDogKHN0YXR1c0RhdGEgYXMgYW55KS5zaG93U3RyaWtlVGhyb3VnaCwgXG4gICAgICAgICAgICAgICAgaGlkZGVuOiAoc3RhdHVzRGF0YSBhcyBhbnkpLmhpZGRlbixcbiAgICAgICAgICAgICAgICByZXF1aXJlc0NvbW1lbnQ6IChzdGF0dXNEYXRhIGFzIGFueSkucmVxdWlyZXNDb21tZW50LFxuICAgICAgICAgICAgICAgIGFsbG93c0NvbW1lbnQ6IChzdGF0dXNEYXRhIGFzIGFueSkuYWxsb3dzQ29tbWVudFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyBwcm9qZWN0IHRhc2sgc3RhdHVzOicsIGVycm9yKTtcbiAgICAgICAgICAgIC8vIFJldmVydCBvcHRpbWlzdGljIHVwZGF0ZSBvbiBlcnJvclxuICAgICAgICAgICAgaWYgKGN1cnJlbnRVc2VyPy5pZCkgYXdhaXQgZmV0Y2hEYXRhKGN1cnJlbnRVc2VyLmlkKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IGRlbGV0ZVByb2plY3RUYXNrU3RhdHVzID0gYXN5bmMgKHByb2plY3RJZDogc3RyaW5nLCBzdGF0dXNJZDogc3RyaW5nKSA9PiB7XG4gICAgICAgIGlmICghY3VycmVudFVzZXIpIHRocm93IG5ldyBFcnJvcignVXNlciBub3QgYXV0aGVudGljYXRlZCcpO1xuICAgICAgICBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIE9wdGltaXN0aWNhbGx5IHJlbW92ZSB0aGUgc3RhdHVzIGZyb20gbG9jYWwgc3RhdGVcbiAgICAgICAgICAgIHNldFByb2plY3RzKHByZXYgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZVByb2plY3QgPSAocHJvamVjdHM6IFByb2plY3RbXSk6IFByb2plY3RbXSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9qZWN0cy5tYXAocCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocC5pZCA9PT0gcHJvamVjdElkICYmIHAudGFza1N0YXR1c09wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXNrU3RhdHVzT3B0aW9uczogcC50YXNrU3RhdHVzT3B0aW9ucy5maWx0ZXIocyA9PiBzLmlkICE9PSBzdGF0dXNJZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHAuc3ViUHJvamVjdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyAuLi5wLCBzdWJQcm9qZWN0czogdXBkYXRlUHJvamVjdChwLnN1YlByb2plY3RzKSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVByb2plY3QocHJldik7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gQ2FsbCBBUEkgdG8gZGVsZXRlIHN0YXR1c1xuICAgICAgICAgICAgYXdhaXQgZGVsZXRlUHJvamVjdFN0YXR1cyhwcm9qZWN0SWQsIHN0YXR1c0lkKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGRlbGV0aW5nIHByb2plY3QgdGFzayBzdGF0dXM6JywgZXJyb3IpO1xuICAgICAgICAgICAgLy8gUmV2ZXJ0IG9wdGltaXN0aWMgdXBkYXRlIG9uIGVycm9yXG4gICAgICAgICAgICBpZiAoY3VycmVudFVzZXI/LmlkKSBhd2FpdCBmZXRjaERhdGEoY3VycmVudFVzZXIuaWQpO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgdXBkYXRlUHJvamVjdFRhc2tTdGF0dXNPcmRlciA9IGFzeW5jIChwcm9qZWN0SWQ6IHN0cmluZywgc3RhdHVzZXM6IFRhc2tTdGF0dXNPcHRpb25bXSkgPT4ge1xuICAgICAgICBpZiAoIWN1cnJlbnRVc2VyKSB0aHJvdyBuZXcgRXJyb3IoJ1VzZXIgbm90IGF1dGhlbnRpY2F0ZWQnKTtcbiAgICAgICAgXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBPcHRpbWlzdGljYWxseSB1cGRhdGUgdGhlIG9yZGVyIGluIGxvY2FsIHN0YXRlXG4gICAgICAgICAgICBzZXRQcm9qZWN0cyhwcmV2ID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB1cGRhdGVQcm9qZWN0ID0gKHByb2plY3RzOiBQcm9qZWN0W10pOiBQcm9qZWN0W10gPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvamVjdHMubWFwKHAgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHAuaWQgPT09IHByb2plY3RJZCAmJiBwLnRhc2tTdGF0dXNPcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgbWFwIGZvciBxdWljayBsb29rdXAgb2YgbmV3IG9yZGVyc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9yZGVyTWFwID0gbmV3IE1hcChzdGF0dXNlcy5tYXAocyA9PiBbcy5pZCwgcy5vcmRlcl0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXNrU3RhdHVzT3B0aW9uczogcC50YXNrU3RhdHVzT3B0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChzID0+ICh7IC4uLnMsIG9yZGVyOiBvcmRlck1hcC5nZXQocy5pZCkgPz8gcy5vcmRlciB9KSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiBhLm9yZGVyIC0gYi5vcmRlcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHAuc3ViUHJvamVjdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyAuLi5wLCBzdWJQcm9qZWN0czogdXBkYXRlUHJvamVjdChwLnN1YlByb2plY3RzKSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVByb2plY3QocHJldik7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gQ2FsbCBBUEkgdG8gdXBkYXRlIG9yZGVyXG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gc3RhdHVzZXMubWFwKHMgPT4gKHsgaWQ6IHMuaWQsIG9yZGVyOiBzLm9yZGVyIH0pKTtcbiAgICAgICAgICAgIGF3YWl0IHVwZGF0ZVByb2plY3RTdGF0dXNlc09yZGVyKHByb2plY3RJZCwgcGF5bG9hZCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyBwcm9qZWN0IHRhc2sgc3RhdHVzIG9yZGVyOicsIGVycm9yKTtcbiAgICAgICAgICAgIC8vIFJldmVydCBvcHRpbWlzdGljIHVwZGF0ZSBvbiBlcnJvclxuICAgICAgICAgICAgaWYgKGN1cnJlbnRVc2VyPy5pZCkgYXdhaXQgZmV0Y2hEYXRhKGN1cnJlbnRVc2VyLmlkKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfTtcblxuXG4gICAgY29uc3QgY2hhbmdlUGFzc3dvcmQgPSBhc3luYyAoY3VycmVudFBhc3N3b3JkOiBzdHJpbmcsIG5ld1Bhc3N3b3JkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IGF1dGhDaGFuZ2VQYXNzd29yZChjdXJyZW50UGFzc3dvcmQsIG5ld1Bhc3N3b3JkKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNoYW5naW5nIHBhc3N3b3JkOicsIGVycm9yKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfTtcblxuICBjb25zdCBmaW5kVXNlckJ5RW1haWwgPSBhc3luYyAoZW1haWw6IHN0cmluZyk6IFByb21pc2U8VXNlciB8IG51bGw+ID0+IHtcbiAgICAvLyBQcmVmZXIgc2VhcmNoaW5nIGNhY2hlZCB1c2VyczsgZmFsbCBiYWNrIHRvIEFQSSBmZXRjaFxuICAgIGNvbnN0IGZvdW5kID0gQXJyYXkuZnJvbSh1c2Vycy52YWx1ZXMoKSkuZmluZCh1ID0+IHUuZW1haWwgPT09IGVtYWlsKTtcbiAgICBpZiAoZm91bmQpIHJldHVybiBmb3VuZDtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBhbGwgPSBhd2FpdCBnZXRVc2VycygpO1xuICAgICAgICBjb25zdCBhcnIgPSAoYWxsIHx8IFtdKSBhcyBVc2VyW107XG4gICAgICAgIGNvbnN0IG1hdGNoID0gYXJyLmZpbmQodSA9PiB1LmVtYWlsID09PSBlbWFpbCkgfHwgbnVsbDtcbiAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmaW5kaW5nIHVzZXIgYnkgZW1haWwgdmlhIGJhY2tlbmQ6JywgZXJyKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGZpbmRVc2VyQnlFbWFpbE9yTmFtZSA9IGFzeW5jIChxdWVyeTogc3RyaW5nKTogUHJvbWlzZTxVc2VyIHwgbnVsbD4gPT4ge1xuICAgIC8vIFByZWZlciBzZWFyY2hpbmcgY2FjaGVkIHVzZXJzOyBmYWxsIGJhY2sgdG8gQVBJIGZldGNoXG4gICAgY29uc3QgZm91bmQgPSBBcnJheS5mcm9tKHVzZXJzLnZhbHVlcygpKS5maW5kKHUgPT4gdS5lbWFpbCA9PT0gcXVlcnkgfHwgdS5uYW1lID09PSBxdWVyeSk7XG4gICAgaWYgKGZvdW5kKSByZXR1cm4gZm91bmQ7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYWxsID0gYXdhaXQgZ2V0VXNlcnMoKTtcbiAgICAgICAgY29uc3QgYXJyID0gKGFsbCB8fCBbXSkgYXMgVXNlcltdO1xuICAgICAgICBjb25zdCBtYXRjaCA9IGFyci5maW5kKHUgPT4gdS5lbWFpbCA9PT0gcXVlcnkgfHwgdS5uYW1lID09PSBxdWVyeSkgfHwgbnVsbDtcbiAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmaW5kaW5nIHVzZXIgYnkgZW1haWwgb3IgbmFtZSB2aWEgYmFja2VuZDonLCBlcnIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgY29udGV4dFZhbHVlID0gdXNlTWVtbygoKSA9PiAoe1xuICAgIHVzZXJzLCBwcm9qZWN0cywgdGFza3MsIGxvYWRpbmcsIGN1cnJlbnRVc2VyLCBcbiAgICBsb2dpbiwgbG9nb3V0LCBhZGRQcm9qZWN0LCB1cGRhdGVQcm9qZWN0LCBnZXRQcm9qZWN0LCBkdXBsaWNhdGVQcm9qZWN0LCBcbiAgICBhZGRQcm9qZWN0TWVtYmVyOiBhZGRQcm9qZWN0TWVtYmVyRnVuYywgdXBkYXRlUHJvamVjdE1lbWJlclJvbGU6IHVwZGF0ZVByb2plY3RNZW1iZXJSb2xlRnVuYywgcmVtb3ZlUHJvamVjdE1lbWJlcjogcmVtb3ZlUHJvamVjdE1lbWJlckZ1bmMsXG4gICAgYWRkVGFzaywgdXBkYXRlVGFzaywgdXBkYXRlVGFza0ltbWVkaWF0ZSwgZGVsZXRlVGFzaywgdXBkYXRlVXNlciwgY3JlYXRlVXNlciwgY2hhbmdlUGFzc3dvcmQsIGZpbmRVc2VyQnlFbWFpbCwgZmluZFVzZXJCeUVtYWlsT3JOYW1lLCBcbiAgICBkZWxldGVQcm9qZWN0LCBpc0thbmJhbkhlYWRlclZpc2libGUsXG4gICAgdG9nZ2xlS2FuYmFuSGVhZGVyLCBpc1NpZGViYXJPcGVuQnlEZWZhdWx0LCB0b2dnbGVTaWRlYmFyRGVmYXVsdCxcbiAgICBjYXJkRGVuc2l0eSwgc2V0Q2FyZERlbnNpdHksXG4gICAgZGVmYXVsdFZpZXcsIHNldERlZmF1bHRWaWV3LFxuICAgIGdyb3VwQnlTdGF0dXMsIHNldEdyb3VwQnlTdGF0dXMsXG4gICAgYWRkUHJvamVjdFRhc2tTdGF0dXMsIHVwZGF0ZVByb2plY3RUYXNrU3RhdHVzLCBkZWxldGVQcm9qZWN0VGFza1N0YXR1cywgdXBkYXRlUHJvamVjdFRhc2tTdGF0dXNPcmRlciwgYWRkRGVmYXVsdFRhc2tTdGF0dXNlc1xuICB9KSwgW1xuICAgIHVzZXJzLCBwcm9qZWN0cywgdGFza3MsIGxvYWRpbmcsIGN1cnJlbnRVc2VyLCBcbiAgICBsb2dpbiwgbG9nb3V0LCBhZGRQcm9qZWN0LCB1cGRhdGVQcm9qZWN0LCBnZXRQcm9qZWN0LCBkdXBsaWNhdGVQcm9qZWN0LCBcbiAgICBhZGRQcm9qZWN0TWVtYmVyRnVuYywgdXBkYXRlUHJvamVjdE1lbWJlclJvbGVGdW5jLCByZW1vdmVQcm9qZWN0TWVtYmVyRnVuYyxcbiAgICBhZGRUYXNrLCB1cGRhdGVUYXNrLCB1cGRhdGVUYXNrSW1tZWRpYXRlLCBkZWxldGVUYXNrLCB1cGRhdGVVc2VyLCBjcmVhdGVVc2VyLCBjaGFuZ2VQYXNzd29yZCwgZmluZFVzZXJCeUVtYWlsLCBmaW5kVXNlckJ5RW1haWxPck5hbWUsIFxuICAgIGRlbGV0ZVByb2plY3QsIGlzS2FuYmFuSGVhZGVyVmlzaWJsZSxcbiAgICB0b2dnbGVLYW5iYW5IZWFkZXIsIGlzU2lkZWJhck9wZW5CeURlZmF1bHQsIHRvZ2dsZVNpZGViYXJEZWZhdWx0LFxuICAgIGNhcmREZW5zaXR5LCBzZXRDYXJkRGVuc2l0eSxcbiAgICBkZWZhdWx0Vmlldywgc2V0RGVmYXVsdFZpZXcsXG4gICAgZ3JvdXBCeVN0YXR1cywgc2V0R3JvdXBCeVN0YXR1cyxcbiAgICBhZGRQcm9qZWN0VGFza1N0YXR1cywgdXBkYXRlUHJvamVjdFRhc2tTdGF0dXMsIGRlbGV0ZVByb2plY3RUYXNrU3RhdHVzLCB1cGRhdGVQcm9qZWN0VGFza1N0YXR1c09yZGVyLCBhZGREZWZhdWx0VGFza1N0YXR1c2VzXG4gIF0pO1xuXG4gIHJldHVybiAoXG4gICAgPEFwcENvbnRleHQuUHJvdmlkZXIgdmFsdWU9e2NvbnRleHRWYWx1ZX0+XG4gICAgICB7Y2hpbGRyZW59XG4gICAgPC9BcHBDb250ZXh0LlByb3ZpZGVyPlxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlQXBwKCkge1xuICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dChBcHBDb250ZXh0KTtcbiAgaWYgKGNvbnRleHQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcigndXNlQXBwIG11c3QgYmUgdXNlZCB3aXRoaW4gYW4gQXBwUHJvdmlkZXInKTtcbiAgfVxuICByZXR1cm4gY29udGV4dDtcbn1cblxuIl0sIm5hbWVzIjpbIlJlYWN0IiwiY3JlYXRlQ29udGV4dCIsInVzZUNvbnRleHQiLCJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsInVzZUNhbGxiYWNrIiwidXNlUmVmIiwidXNlTWVtbyIsImNyZWF0ZVByb2plY3QiLCJ1cGRhdGVQcm9qZWN0QXBpIiwiZGVsZXRlUHJvamVjdEFwaSIsImNyZWF0ZVRhc2tBcGkiLCJ1cGRhdGVUYXNrQXBpIiwiZGVsZXRlVGFza0FwaSIsImdldFByb2plY3QiLCJhcGlHZXRQcm9qZWN0IiwiZ2V0VXNlcnMiLCJnZXRUYXNrc0J5UHJvamVjdElkcyIsImF1dGhMb2dpbiIsImF1dGhTaWdudXAiLCJhdXRoTG9nb3V0IiwiYXV0aE1lIiwiYXV0aENoYW5nZVBhc3N3b3JkIiwiY3JlYXRlUHJvamVjdFN0YXR1cyIsInVwZGF0ZVByb2plY3RTdGF0dXMiLCJkZWxldGVQcm9qZWN0U3RhdHVzIiwidXBkYXRlUHJvamVjdFN0YXR1c2VzT3JkZXIiLCJ1cGRhdGVVc2VyQXBpIiwiYWRkUHJvamVjdE1lbWJlciIsInVwZGF0ZVByb2plY3RNZW1iZXJSb2xlIiwicmVtb3ZlUHJvamVjdE1lbWJlciIsInVzZVJvdXRlciIsInVzZVBhdGhuYW1lIiwiUmVhbHRpbWVDbGllbnQiLCJjcmVhdGVDb21wb25lbnRMb2dnZXIiLCJnZXRDYWNoZWRQcm9qZWN0cyIsImdldENhY2hlZFVzZXJzIiwiZ2V0Q2FjaGVkVGFza3NCeVByb2plY3RJZHMiLCJpbnZhbGlkYXRlUHJvamVjdENhY2hlcyIsImludmFsaWRhdGVUYXNrQ2FjaGVzIiwiaW52YWxpZGF0ZUFsbFByb2plY3RDYWNoZXMiLCJvcHRpbWlzdGljVXBkYXRlVGFzayIsIm9wdGltaXN0aWNVcGRhdGVQcm9qZWN0IiwiY2xlYXJBbGxDYWNoZXMiLCJnZXRDYWNoZVN0YXRzIiwiQXBwQ29udGV4dCIsInVuZGVmaW5lZCIsImxvZ2dlciIsIkFwcFByb3ZpZGVyIiwiY2hpbGRyZW4iLCJ1c2VycyIsInNldFVzZXJzIiwiTWFwIiwicHJvamVjdHMiLCJzZXRQcm9qZWN0cyIsInRhc2tzIiwic2V0VGFza3MiLCJjdXJyZW50VXNlciIsInNldEN1cnJlbnRVc2VyIiwibG9hZGluZyIsInNldExvYWRpbmciLCJpc0thbmJhbkhlYWRlclZpc2libGUiLCJzZXRJc0thbmJhbkhlYWRlclZpc2libGUiLCJpc1NpZGViYXJPcGVuQnlEZWZhdWx0Iiwic2V0SXNTaWRlYmFyT3BlbkJ5RGVmYXVsdCIsImNhcmREZW5zaXR5Iiwic2V0Q2FyZERlbnNpdHlTdGF0ZSIsImRlZmF1bHRWaWV3Iiwic2V0RGVmYXVsdFZpZXdTdGF0ZSIsImdyb3VwQnlTdGF0dXMiLCJzZXRHcm91cEJ5U3RhdHVzU3RhdGUiLCJyb3V0ZXIiLCJwYXRobmFtZSIsInBlbmRpbmdUYXNrVXBkYXRlcyIsInVwZGF0ZVRhc2tUaW1lb3V0cyIsInJlYWx0aW1lQ2xpZW50IiwiaXNSZWFsdGltZUNvbm5lY3RlZCIsInNldElzUmVhbHRpbWVDb25uZWN0ZWQiLCJub3JtYWxpemVQcm9qZWN0IiwicCIsInRhc2tTdGF0dXNPcHRpb25zIiwiQXJyYXkiLCJpc0FycmF5Iiwic3RhdHVzZXMiLCJtYXAiLCJzIiwibGFiZWwiLCJ0b1N0cmluZyIsImZhbGxiYWNrIiwia2V5IiwidHJpbSIsInRvTG93ZXJDYXNlIiwiaWQiLCJuYW1lIiwiY29sb3IiLCJvcmRlciIsInNob3dTdHJpa2VUaHJvdWdoIiwiaGlkZGVuIiwicmVxdWlyZXNDb21tZW50IiwiYWxsb3dzQ29tbWVudCIsIm1lbWJlcnMiLCJmb3JFYWNoIiwibSIsInVzZXJJZCIsInJvbGUiLCJkb2N1bWVudCIsImNvb2tpZVZhbHVlIiwiY29va2llIiwic3BsaXQiLCJmaW5kIiwicm93Iiwic3RhcnRzV2l0aCIsInN0b3JlZCIsIndpbmRvdyIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJkdiIsImdiIiwiZSIsInRvZ2dsZVNpZGViYXJEZWZhdWx0IiwicHJldlN0YXRlIiwibmV3U3RhdGUiLCJzZXRDYXJkRGVuc2l0eSIsImQiLCJzZXRJdGVtIiwic2V0RGVmYXVsdFZpZXciLCJ2Iiwic2V0R3JvdXBCeVN0YXR1cyIsImJvZHkiLCJjbGFzc0xpc3QiLCJhZGQiLCJyZW1vdmUiLCJ0b2dnbGVLYW5iYW5IZWFkZXIiLCJjbGVhclN0YXRlIiwiY2xlYXJBbGxBdXRoRGF0YSIsImZldGNoRGF0YSIsImN1cnJlbnRVc2VySWQiLCJwcm9qZWN0c1Jlc3AiLCJzdGFsZVdoaWxlUmV2YWxpZGF0ZSIsImFsbFByb2plY3RzRmxhdCIsInByb2plY3RNYXAiLCJzZXQiLCJzdWJQcm9qZWN0cyIsIm5lc3RlZFByb2plY3RzIiwicHJvamVjdCIsInBhcmVudFByb2plY3RJZCIsInBhcmVudCIsImdldCIsInB1c2giLCJ1c2Vyc1Jlc3AiLCJ1c2VyTGlzdCIsInVzZXJNYXAiLCJ1Iiwic3RhdHMiLCJkZWJ1ZyIsImNvbXBvbmVudCIsImhpdFJhdGUiLCJ0b0ZpeGVkIiwiaGl0cyIsIm1pc3NlcyIsInNpemUiLCJlcnJvciIsImNvbnNvbGUiLCJzdGF0dXMiLCJ3YXJuIiwicmVmcmVzaFByb2plY3RzIiwiZm9yY2VSZWZyZXNoIiwiY2xlYXJPcmNoZVBsYW5DYWNoZSIsIm1vdW50ZWQiLCJyZXNwIiwidXNlciIsImVyciIsImxlbmd0aCIsImdldEFsbFByb2plY3RJZHMiLCJwcm9qcyIsImlkcyIsImNvbmNhdCIsImFsbFByb2plY3RJZHMiLCJDSFVOS19TSVpFIiwicHJvamVjdENodW5rcyIsImkiLCJzbGljZSIsIm5vcm1hbGl6ZVRhc2siLCJ0Iiwic3RhdHVzSWQiLCJ0ZXN0IiwiYXNzaWduZWVJZCIsInBhcmVudElkIiwiZmV0Y2hUYXNrcyIsInJlc3VsdHMiLCJQcm9taXNlIiwiYWxsIiwiY2h1bmsiLCJjb21iaW5lZCIsImZsYXQiLCJub3JtYWxpemVkVGFza3MiLCJwb2xsaW5nSW50ZXJ2YWwiLCJsYXN0VGFza0NvdW50IiwiY29uc2VjdXRpdmVOb0NoYW5nZXMiLCJpc1dpbmRvd0FjdGl2ZSIsImdldFBvbGxpbmdJbnRlcnZhbCIsInN0YXJ0UG9sbGluZyIsImNsZWFySW50ZXJ2YWwiLCJwb2xsIiwic2V0SW50ZXJ2YWwiLCJoYW5kbGVGb2N1cyIsImhhbmRsZUJsdXIiLCJjdXJyZW50IiwiZ2V0QXBpQmFzZSIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19CQUNLRU5EX1VSTCIsIk5FWFRfUFVCTElDX0FQSV9CQVNFIiwiaG9zdG5hbWUiLCJsb2NhdGlvbiIsInByb3RvY29sIiwiaXNDb2RlckVudiIsImluY2x1ZGVzIiwiYmFja2VuZFByb3RvY29sIiwiYmFja2VuZEhvc3RuYW1lIiwicmVwbGFjZSIsImJhc2VVcmwiLCJvbiIsImRhdGEiLCJhY3Rpb24iLCJ0YXNrRGF0YSIsIm5vcm1hbGl6ZWRUYXNrIiwicHJldiIsImV4aXN0aW5nVGFzayIsImZpbHRlciIsImFkZEV2ZW50TGlzdGVuZXIiLCJjb25uZWN0Iiwic2V0VGltZW91dCIsImdldENvbm5lY3Rpb25TdGF0dXMiLCJkaXNjb25uZWN0IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImFkZERlZmF1bHRUYXNrU3RhdHVzZXMiLCJwcm9qZWN0SWQiLCJFcnJvciIsImRlZmF1bHRTdGF0dXNlcyIsInRlbXBTdGF0dXNlcyIsImluZGV4IiwiRGF0ZSIsIm5vdyIsInVwZGF0ZVByb2plY3QiLCJjcmVhdGVkU3RhdHVzZXMiLCJjcmVhdGVkIiwibG9naW4iLCJlbWFpbCIsInBhc3N3b3JkIiwic3VjY2VzcyIsImlzRXhwZWN0ZWQiLCJlcnJvclR5cGUiLCJpbmZvIiwibWVzc2FnZSIsImVycm9yTWVzc2FnZSIsImxvZ291dCIsImFkZFByb2plY3QiLCJyZXN0T2ZQcm9qZWN0IiwicGF5bG9hZCIsIm5ld1Byb2plY3QiLCJwcm9qZWN0RGF0YSIsInVwZGF0ZWQiLCJwcm9qIiwiYXJyIiwiZXhpc3RzIiwiZHVwbGljYXRlUHJvamVjdCIsImlkTWFwIiwiZmluZFByb2plY3RJblN0YXRlIiwicElkIiwiZm91bmQiLCJnZXRQcm9qZWN0c1RvRHVwbGljYXRlIiwibGlzdCIsInN1YiIsInJvb3RQcm9qZWN0VG9EdXBsaWNhdGUiLCJhbGxQcm9qZWN0c1RvRHVwbGljYXRlIiwib2xkUHJvamVjdElkcyIsIm9sZElkIiwibmV3UHJvamVjdElkIiwidGlkIiwiZGVsZXRlUHJvamVjdCIsImdldFByb2plY3RJZHNGcm9tU3RhdGUiLCJhbGxQcm9qZWN0cyIsInN0YXJ0SWQiLCJmaW5kQW5kQ29sbGVjdCIsImNvbGxlY3QiLCJhbGxQcm9qZWN0SWRzVG9EZWxldGUiLCJyZW1vdmVQcm9qZWN0IiwidGFyZ2V0SWQiLCJ1cGRhdGVkUHJvamVjdHMiLCJ0YXNrIiwicmVtYWluaW5nUHJvamVjdElkcyIsIlNldCIsImlzVmlld2luZ0RlbGV0ZWRQcm9qZWN0Iiwic29tZSIsImFkZFByb2plY3RNZW1iZXJGdW5jIiwidXBkYXRlUHJvamVjdE1lbWJlclJvbGVGdW5jIiwicmVtb3ZlUHJvamVjdE1lbWJlckZ1bmMiLCJuZXdNZW1iZXJzIiwiYWRkVGFzayIsIk9iamVjdCIsImtleXMiLCJrIiwibmV3VGFzayIsInVwZGF0ZVRhc2siLCJ1cGRhdGVkVGFzayIsImNyZWF0ZWRBdCIsInVwZGF0ZWRBdCIsIm9wdGltaXN0aWMiLCJub3JtYWxpemVkIiwidXBkYXRlVGFza0ltbWVkaWF0ZSIsImV4aXN0aW5nVGltZW91dCIsImNsZWFyVGltZW91dCIsInRpbWVvdXQiLCJ0YXNrVG9VcGRhdGUiLCJkZWxldGUiLCJkZWxldGVUYXNrIiwidGFza0lkIiwidXBkYXRlVXNlciIsInVzZXJEYXRhIiwicHJldlVzZXJzIiwibmV3VXNlcnMiLCJoYXMiLCJleGlzdGluZ1VzZXIiLCJjcmVhdGVVc2VyIiwiYWRkUHJvamVjdFRhc2tTdGF0dXMiLCJ0ZW1wSWQiLCJleGlzdGluZ1N0YXR1c2VzIiwibmV3T3JkZXIiLCJvcHRpbWlzdGljU3RhdHVzIiwiY3JlYXRlZFN0YXR1cyIsInVwZGF0ZVByb2plY3RUYXNrU3RhdHVzIiwic3RhdHVzRGF0YSIsImRlbGV0ZVByb2plY3RUYXNrU3RhdHVzIiwidXBkYXRlUHJvamVjdFRhc2tTdGF0dXNPcmRlciIsIm9yZGVyTWFwIiwic29ydCIsImEiLCJiIiwiY2hhbmdlUGFzc3dvcmQiLCJjdXJyZW50UGFzc3dvcmQiLCJuZXdQYXNzd29yZCIsImZpbmRVc2VyQnlFbWFpbCIsImZyb20iLCJ2YWx1ZXMiLCJtYXRjaCIsImZpbmRVc2VyQnlFbWFpbE9yTmFtZSIsInF1ZXJ5IiwiY29udGV4dFZhbHVlIiwiUHJvdmlkZXIiLCJ2YWx1ZSIsInVzZUFwcCIsImNvbnRleHQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/context/app-context.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/lib/api.ts":
/*!************************!*\
  !*** ./src/lib/api.ts ***!
  \************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addProjectMember: () => (/* binding */ addProjectMember),\n/* harmony export */   api: () => (/* binding */ api),\n/* harmony export */   authChangePassword: () => (/* binding */ authChangePassword),\n/* harmony export */   authLogin: () => (/* binding */ authLogin),\n/* harmony export */   authLogout: () => (/* binding */ authLogout),\n/* harmony export */   authMe: () => (/* binding */ authMe),\n/* harmony export */   authSignup: () => (/* binding */ authSignup),\n/* harmony export */   createProject: () => (/* binding */ createProject),\n/* harmony export */   createProjectStatus: () => (/* binding */ createProjectStatus),\n/* harmony export */   createTaskApi: () => (/* binding */ createTaskApi),\n/* harmony export */   createTaskComment: () => (/* binding */ createTaskComment),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   deleteProjectApi: () => (/* binding */ deleteProjectApi),\n/* harmony export */   deleteProjectStatus: () => (/* binding */ deleteProjectStatus),\n/* harmony export */   deleteTaskApi: () => (/* binding */ deleteTaskApi),\n/* harmony export */   deleteTaskComment: () => (/* binding */ deleteTaskComment),\n/* harmony export */   externalProxy: () => (/* binding */ externalProxy),\n/* harmony export */   getApiBase: () => (/* binding */ getApiBase),\n/* harmony export */   getProject: () => (/* binding */ getProject),\n/* harmony export */   getProjectStatuses: () => (/* binding */ getProjectStatuses),\n/* harmony export */   getProjects: () => (/* binding */ getProjects),\n/* harmony export */   getTaskComments: () => (/* binding */ getTaskComments),\n/* harmony export */   getTasksByProjectIds: () => (/* binding */ getTasksByProjectIds),\n/* harmony export */   getUsers: () => (/* binding */ getUsers),\n/* harmony export */   moveTaskToStatus: () => (/* binding */ moveTaskToStatus),\n/* harmony export */   removeProjectMember: () => (/* binding */ removeProjectMember),\n/* harmony export */   updateProjectApi: () => (/* binding */ updateProjectApi),\n/* harmony export */   updateProjectMemberRole: () => (/* binding */ updateProjectMemberRole),\n/* harmony export */   updateProjectStatus: () => (/* binding */ updateProjectStatus),\n/* harmony export */   updateProjectStatusesOrder: () => (/* binding */ updateProjectStatusesOrder),\n/* harmony export */   updateTaskApi: () => (/* binding */ updateTaskApi),\n/* harmony export */   updateTaskComment: () => (/* binding */ updateTaskComment),\n/* harmony export */   updateUserApi: () => (/* binding */ updateUserApi)\n/* harmony export */ });\n/* harmony import */ var _csrf__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./csrf */ \"(app-pages-browser)/./src/lib/csrf.ts\");\n/* __next_internal_client_entry_do_not_use__ getApiBase,authLogin,authSignup,authLogout,authMe,authChangePassword,externalProxy,getProjects,getProject,createProject,updateProjectApi,deleteProjectApi,addProjectMember,updateProjectMemberRole,removeProjectMember,getUsers,updateUserApi,getTasksByProjectIds,createTaskApi,updateTaskApi,deleteTaskApi,getTaskComments,createTaskComment,updateTaskComment,deleteTaskComment,getProjectStatuses,createProjectStatus,updateProjectStatus,deleteProjectStatus,updateProjectStatusesOrder,api,moveTaskToStatus,default auto */ \n// Smart API base URL detection\nconst getApiBase = ()=>{\n    // Server-side rendering\n    if (false) {}\n    // Client-side - use environment variable or auto-detect\n    if (true) {\n        return \"https://3000--main--orcheplan--andreas.coder.josern.com\";\n    }\n    // Auto-detect based on current location\n    const hostname = window.location.hostname;\n    const protocol = window.location.protocol;\n    // Local development\n    if (hostname === 'localhost' || hostname === '127.0.0.1') {\n        return 'http://localhost:3000';\n    }\n    // External server - construct backend URL\n    // In Coder environment, use HTTPS for backend as well\n    const isCoderEnv = hostname.includes('coder.josern.com');\n    const backendProtocol = isCoderEnv ? 'https:' : protocol;\n    if (isCoderEnv) {\n        // Special handling for Coder subdomain pattern\n        const backendHostname = hostname.replace(/^9002--/, '3000--');\n        const apiBase = \"\".concat(backendProtocol, \"//\").concat(backendHostname);\n        return apiBase;\n    }\n    const apiBase = \"\".concat(backendProtocol, \"//\").concat(hostname, \":3000\");\n    return apiBase;\n};\nconst API_BASE = getApiBase();\n// We use cookie-based auth (HttpOnly cookie). Avoid relying on client-stored JWTs.\nlet authToken = null;\nfunction setAuthToken(token) {\n    // Keep function for legacy cleanup; do not persist tokens to localStorage by default.\n    authToken = null;\n    try {\n        if ( true && token === null) {\n            // remove any legacy token value\n            window.localStorage.removeItem('orcheplan_token');\n        }\n    } catch (e) {\n    // ignore storage errors in restricted environments\n    }\n}\n// Create an error that won't log stack traces (expected user error)\nfunction createExpectedError(message, status, body) {\n    const error = new Error(message);\n    error.status = status;\n    error.body = body;\n    error.isExpected = true;\n    return error;\n}\nasync function request(path) {\n    let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const headers = opts.headers ? {\n        ...opts.headers\n    } : {};\n    // Add CSRF token for state-changing requests\n    if (opts.method && [\n        'POST',\n        'PUT',\n        'DELETE',\n        'PATCH'\n    ].includes(opts.method.toUpperCase())) {\n        try {\n            await (0,_csrf__WEBPACK_IMPORTED_MODULE_0__.addCsrfHeaders)(headers);\n        } catch (error) {\n            // In production, this should fail the request\n            if (false) {}\n        }\n    }\n    // We rely on cookie-based authentication (credentials: 'include').\n    // Do not attach Authorization header from client-side JWTs.\n    if (opts.body && typeof opts.body === 'object') {\n        headers['Content-Type'] = 'application/json';\n        opts.body = JSON.stringify(opts.body);\n    }\n    const url = API_BASE + path;\n    try {\n        const res = await fetch(url, {\n            credentials: 'include',\n            ...opts,\n            headers\n        });\n        const text = await res.text();\n        let data = undefined;\n        try {\n            data = text ? JSON.parse(text) : undefined;\n        } catch (e) {\n            data = text;\n        }\n        // debug: log small request/response summaries to aid local troubleshooting\n        try {\n            const safeBody = (()=>{\n                try {\n                    return opts.body ? JSON.parse(opts.body) : null;\n                } catch (e) {\n                    return opts.body;\n                }\n            })();\n        // Remove debug logging in production\n        } catch (e) {}\n        if (!res.ok) {\n            const msg = (data === null || data === void 0 ? void 0 : data.message) || (data === null || data === void 0 ? void 0 : data.error) || res.statusText || 'Request failed';\n            // Check if this is an expected error that shouldn't create a logged Error\n            const isAuthEndpoint = url.includes('/auth/');\n            const is400 = res.status === 400;\n            const is401 = res.status === 401;\n            const is404 = res.status === 404;\n            const is409 = res.status === 409;\n            const isExpectedAuth = isAuthEndpoint && (is400 || is401 || is404 || is409);\n            // Create error object\n            let err;\n            if (isExpectedAuth) {\n                // For expected auth errors, create a plain object that won't be logged by the browser\n                err = {\n                    message: msg,\n                    status: res.status,\n                    body: data,\n                    isExpected: true,\n                    name: 'ExpectedAPIError'\n                };\n            } else {\n                // For unexpected errors, create a proper Error object for debugging\n                err = new Error(msg);\n                err.status = res.status;\n                err.body = data;\n            }\n            throw err;\n        }\n        return data;\n    } catch (error) {\n        var _error_body;\n        // Check if this is a CSRF error (403 status often indicates CSRF failure)\n        if ((error === null || error === void 0 ? void 0 : error.status) === 403 && (error === null || error === void 0 ? void 0 : (_error_body = error.body) === null || _error_body === void 0 ? void 0 : _error_body.code) === 'EBADCSRFTOKEN') {\n            // Clear cached CSRF token and retry once\n            const { clearCsrfToken } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./csrf */ \"(app-pages-browser)/./src/lib/csrf.ts\"));\n            clearCsrfToken();\n            // Only retry once to avoid infinite loops\n            if (!opts._csrfRetry) {\n                return request(path, {\n                    ...opts,\n                    _csrfRetry: true\n                });\n            }\n        }\n        // Check if this is an expected error that shouldn't be logged\n        const isAuthEndpoint = url.includes('/auth/');\n        const is400 = (error === null || error === void 0 ? void 0 : error.status) === 400;\n        const is401 = (error === null || error === void 0 ? void 0 : error.status) === 401;\n        const is404 = (error === null || error === void 0 ? void 0 : error.status) === 404;\n        const is409 = (error === null || error === void 0 ? void 0 : error.status) === 409;\n        const isExpectedAuth = isAuthEndpoint && (is400 || is401 || is404 || is409);\n        const isStaleAuth = !isAuthEndpoint && (is401 || is404);\n        // Mark expected errors\n        if (isExpectedAuth || isStaleAuth) {\n            error.isExpected = true;\n        }\n        // Only log unexpected errors\n        if (!isExpectedAuth && !isStaleAuth) {\n            var _error_constructor;\n            console.error('[api] Request failed:', {\n                url,\n                method: opts.method || 'GET',\n                error: error instanceof Error ? error.message : String(error),\n                status: error === null || error === void 0 ? void 0 : error.status,\n                statusText: error === null || error === void 0 ? void 0 : error.statusText,\n                body: error === null || error === void 0 ? void 0 : error.body,\n                stack: error instanceof Error ? error.stack : undefined,\n                fullError: error,\n                errorType: typeof error,\n                errorConstructor: error === null || error === void 0 ? void 0 : (_error_constructor = error.constructor) === null || _error_constructor === void 0 ? void 0 : _error_constructor.name,\n                isNetworkError: !(error === null || error === void 0 ? void 0 : error.status),\n                timestamp: new Date().toISOString(),\n                // Additional debugging info\n                errorKeys: error ? Object.keys(error) : [],\n                errorJson: error ? JSON.stringify(error, null, 2) : 'null',\n                hasErrorMessage: !!(error === null || error === void 0 ? void 0 : error.message),\n                hasErrorStatus: !!(error === null || error === void 0 ? void 0 : error.status),\n                hasErrorBody: !!(error === null || error === void 0 ? void 0 : error.body),\n                isAuthEndpoint,\n                expectedAuthFlags: {\n                    isExpectedAuth,\n                    isStaleAuth,\n                    is400,\n                    is401,\n                    is404,\n                    is409\n                }\n            });\n        } else if (isStaleAuth) {\n            // Log stale auth as warning only\n            console.warn('[api] Authentication may be stale:', {\n                url,\n                status: error.status,\n                message: 'Consider clearing browser data if this persists'\n            });\n        }\n        // For isExpectedAuth, we don't log anything (silent)\n        throw error;\n    }\n}\nasync function authLogin(email, password) {\n    // For cookie-based auth we don't need to persist the JWT client-side.\n    // The server sets an HttpOnly cookie with the token.\n    try {\n        const resp = await request('/auth/login', {\n            method: 'POST',\n            body: {\n                email,\n                password\n            }\n        });\n        return resp;\n    } catch (error) {\n        // For expected auth errors, don't re-throw to avoid console logging\n        if (error.status === 400 || error.status === 401) {\n            var _error_body;\n            // Return the error as a structured response instead of throwing\n            return {\n                success: false,\n                error: ((_error_body = error.body) === null || _error_body === void 0 ? void 0 : _error_body.error) || error.message || 'Login failed',\n                status: error.status,\n                isExpected: true\n            };\n        }\n        // For unexpected errors, still throw\n        throw error;\n    }\n}\nasync function authSignup(name, email, password) {\n    try {\n        const resp = await request('/auth/signup', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n                name,\n                email,\n                password\n            })\n        });\n        return resp;\n    } catch (error) {\n        // For expected auth errors, don't re-throw to avoid console logging\n        if (error.status === 400 || error.status === 409) {\n            var _error_body;\n            // Return the error as a structured response instead of throwing\n            return {\n                success: false,\n                error: ((_error_body = error.body) === null || _error_body === void 0 ? void 0 : _error_body.error) || error.message || 'Signup failed',\n                status: error.status,\n                isExpected: true\n            };\n        }\n        // For unexpected errors, still throw\n        throw error;\n    }\n}\nasync function authLogout() {\n    try {\n        const resp = await request('/auth/logout', {\n            method: 'POST'\n        });\n        return resp;\n    } finally{\n        // clear token client-side regardless of server response\n        setAuthToken(null);\n    }\n}\nasync function authMe() {\n    try {\n        return await request('/auth/me', {\n            method: 'GET'\n        });\n    } catch (error) {\n        // If unauthorized (401) or user not found (404), return null instead of throwing\n        // This is expected when no user is logged in or session is invalid\n        if (error.status === 401 || error.status === 404) {\n            return null;\n        }\n        // For other errors, mark as unexpected and re-throw\n        error.isExpected = false;\n        throw error;\n    }\n}\nasync function authChangePassword(currentPassword, newPassword) {\n    return request('/auth/change-password', {\n        method: 'POST',\n        body: {\n            currentPassword,\n            newPassword\n        }\n    });\n}\n// Server-side external proxy helper\n// Usage: externalProxy('coder.josern.com', '/api/v2/applications/auth-redirect')\nasync function externalProxy(host, target) {\n    let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    const params = new URLSearchParams();\n    params.set('host', host);\n    params.set('target', target);\n    const path = \"/external-proxy?\".concat(params.toString());\n    return request(path, {\n        method: opts.method || 'GET',\n        body: opts.body,\n        headers: opts.headers\n    });\n}\n// Projects\nasync function getProjects() {\n    return request('/projects', {\n        method: 'GET'\n    });\n}\nasync function getProject(projectId) {\n    return request(\"/projects/\".concat(projectId), {\n        method: 'GET'\n    });\n}\nasync function createProject(body) {\n    return request('/projects', {\n        method: 'POST',\n        body\n    });\n}\nasync function updateProjectApi(projectId, body) {\n    return request(\"/projects/\".concat(projectId), {\n        method: 'PUT',\n        body\n    });\n}\nasync function deleteProjectApi(projectId) {\n    return request(\"/projects/\".concat(projectId), {\n        method: 'DELETE'\n    });\n}\n// Project Members\nasync function addProjectMember(projectId, userId, role) {\n    return request(\"/projects/\".concat(projectId, \"/members\"), {\n        method: 'POST',\n        body: {\n            userId,\n            role\n        }\n    });\n}\nasync function updateProjectMemberRole(projectId, userId, role) {\n    return request(\"/projects/\".concat(projectId, \"/members/\").concat(userId), {\n        method: 'PUT',\n        body: {\n            role\n        }\n    });\n}\nasync function removeProjectMember(projectId, userId) {\n    return request(\"/projects/\".concat(projectId, \"/members/\").concat(userId), {\n        method: 'DELETE'\n    });\n}\n// Users\nasync function getUsers() {\n    return request('/users', {\n        method: 'GET'\n    });\n}\nasync function updateUserApi(userId, body) {\n    return request(\"/users/\".concat(userId), {\n        method: 'PUT',\n        body\n    });\n}\n// Tasks\nasync function getTasksByProjectIds(projectIds) {\n    const params = new URLSearchParams();\n    projectIds.forEach((id)=>params.append('projectId', id));\n    return request(\"/tasks?\".concat(params.toString()), {\n        method: 'GET'\n    });\n}\nasync function createTaskApi(body) {\n    return request('/tasks', {\n        method: 'POST',\n        body\n    });\n}\nasync function updateTaskApi(taskId, body) {\n    return request(\"/tasks/\".concat(taskId), {\n        method: 'PUT',\n        body\n    });\n}\nasync function deleteTaskApi(taskId) {\n    return request(\"/tasks/\".concat(taskId), {\n        method: 'DELETE'\n    });\n}\n// Task Comments\nasync function getTaskComments(taskId) {\n    return request(\"/tasks/\".concat(taskId, \"/comments\"), {\n        method: 'GET'\n    });\n}\nasync function createTaskComment(taskId, content) {\n    return request(\"/tasks/\".concat(taskId, \"/comments\"), {\n        method: 'POST',\n        body: {\n            content\n        }\n    });\n}\nasync function updateTaskComment(taskId, commentId, content) {\n    return request(\"/tasks/\".concat(taskId, \"/comments/\").concat(commentId), {\n        method: 'PUT',\n        body: {\n            content\n        }\n    });\n}\nasync function deleteTaskComment(taskId, commentId) {\n    return request(\"/tasks/\".concat(taskId, \"/comments/\").concat(commentId), {\n        method: 'DELETE'\n    });\n}\n// Statuses (task_statuses)\nasync function getProjectStatuses(projectId) {\n    return request(\"/projects/\".concat(projectId, \"/statuses\"), {\n        method: 'GET'\n    });\n}\nasync function createProjectStatus(projectId, body) {\n    return request(\"/projects/\".concat(projectId, \"/statuses\"), {\n        method: 'POST',\n        body\n    });\n}\nasync function updateProjectStatus(projectId, statusId, body) {\n    return request(\"/projects/\".concat(projectId, \"/statuses/\").concat(statusId), {\n        method: 'PUT',\n        body\n    });\n}\nasync function deleteProjectStatus(projectId, statusId) {\n    return request(\"/projects/\".concat(projectId, \"/statuses/\").concat(statusId), {\n        method: 'DELETE'\n    });\n}\nasync function updateProjectStatusesOrder(projectId, statuses) {\n    return request(\"/projects/\".concat(projectId, \"/statuses/order\"), {\n        method: 'PATCH',\n        body: {\n            statuses\n        }\n    });\n}\n// Generic API utility for admin and other custom endpoints\nconst api = {\n    get: function(path) {\n        let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        return request(path, {\n            ...opts,\n            method: 'GET'\n        });\n    },\n    post: function(path, body) {\n        let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        return request(path, {\n            ...opts,\n            method: 'POST',\n            body\n        });\n    },\n    put: function(path, body) {\n        let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        return request(path, {\n            ...opts,\n            method: 'PUT',\n            body\n        });\n    },\n    delete: function(path) {\n        let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        return request(path, {\n            ...opts,\n            method: 'DELETE'\n        });\n    },\n    patch: function(path, body) {\n        let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        return request(path, {\n            ...opts,\n            method: 'PATCH',\n            body\n        });\n    }\n};\n// Task move with comment requirements\nasync function moveTaskToStatus(taskId, statusId, comment) {\n    return request(\"/tasks/\".concat(taskId, \"/move\"), {\n        method: 'POST',\n        body: {\n            statusId,\n            comment\n        }\n    });\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n    authLogin,\n    authSignup,\n    authLogout,\n    authMe,\n    authChangePassword,\n    getProjects,\n    getProject,\n    createProject,\n    updateProjectApi,\n    deleteProjectApi,\n    addProjectMember,\n    updateProjectMemberRole,\n    removeProjectMember,\n    getUsers,\n    updateUserApi,\n    getTasksByProjectIds,\n    createTaskApi,\n    updateTaskApi,\n    deleteTaskApi,\n    getTaskComments,\n    createTaskComment,\n    updateTaskComment,\n    deleteTaskComment,\n    getProjectStatuses,\n    createProjectStatus,\n    updateProjectStatus,\n    deleteProjectStatus,\n    updateProjectStatusesOrder\n});\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QyxDQUFDO2VBQ3hERixRQUFRQyxNQUFNO1lBQUUsR0FBR0MsSUFBSTtZQUFFRSxRQUFRO1FBQU07O0lBQ3pDc0csTUFBTSxTQUFDekcsTUFBY0w7WUFBWU0sd0VBQThDLENBQUM7ZUFDOUVGLFFBQVFDLE1BQU07WUFBRSxHQUFHQyxJQUFJO1lBQUVFLFFBQVE7WUFBUVI7UUFBSzs7SUFDaEQrRyxLQUFLLFNBQUMxRyxNQUFjTDtZQUFZTSx3RUFBOEMsQ0FBQztlQUM3RUYsUUFBUUMsTUFBTTtZQUFFLEdBQUdDLElBQUk7WUFBRUUsUUFBUTtZQUFPUjtRQUFLOztJQUMvQ2dILFFBQVEsU0FBQzNHO1lBQWNDLHdFQUFxQyxDQUFDO2VBQzNERixRQUFRQyxNQUFNO1lBQUUsR0FBR0MsSUFBSTtZQUFFRSxRQUFRO1FBQVM7O0lBQzVDeUcsT0FBTyxTQUFDNUcsTUFBY0w7WUFBWU0sd0VBQThDLENBQUM7ZUFDL0VGLFFBQVFDLE1BQU07WUFBRSxHQUFHQyxJQUFJO1lBQUVFLFFBQVE7WUFBU1I7UUFBSzs7QUFDbkQsRUFBRTtBQUVGLHNDQUFzQztBQUMvQixlQUFla0gsaUJBQWlCckIsTUFBYyxFQUFFVyxRQUFnQixFQUFFVyxPQUFnQjtJQUN2RixPQUFPL0csUUFBUSxVQUFpQixPQUFQeUYsUUFBTyxVQUFRO1FBQUVyRixRQUFRO1FBQVFSLE1BQU07WUFBRXdHO1lBQVVXO1FBQVE7SUFBRTtBQUN4RjtBQUVBLGlFQUFlO0lBQUU1RDtJQUFXSztJQUFZQztJQUFZQztJQUFRQztJQUFvQlU7SUFBYUM7SUFBWUU7SUFBZUM7SUFBa0JDO0lBQWtCQztJQUFrQkc7SUFBeUJDO0lBQXFCQztJQUFVQztJQUFlQztJQUFzQks7SUFBZUM7SUFBZUU7SUFBZUM7SUFBaUJDO0lBQW1CRTtJQUFtQkU7SUFBbUJDO0lBQW9CQztJQUFxQkM7SUFBcUJFO0lBQXFCQztBQUEyQixDQUFDIiwic291cmNlcyI6WyIvaG9tZS9jb2Rlci9PcmNoZVBsYW4vZnJvbnRlbmQvc3JjL2xpYi9hcGkudHMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCJcblxuaW1wb3J0IHsgYWRkQ3NyZkhlYWRlcnMgfSBmcm9tICcuL2NzcmYnO1xuXG4vLyBTbWFydCBBUEkgYmFzZSBVUkwgZGV0ZWN0aW9uXG5leHBvcnQgY29uc3QgZ2V0QXBpQmFzZSA9ICgpID0+IHtcbiAgLy8gU2VydmVyLXNpZGUgcmVuZGVyaW5nXG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfQkFTRSB8fCAnaHR0cDovL2xvY2FsaG9zdDozMDAwJztcbiAgfVxuICBcbiAgLy8gQ2xpZW50LXNpZGUgLSB1c2UgZW52aXJvbm1lbnQgdmFyaWFibGUgb3IgYXV0by1kZXRlY3RcbiAgaWYgKHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9CQVNFKSB7XG4gICAgcmV0dXJuIHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9CQVNFO1xuICB9XG4gIFxuICAvLyBBdXRvLWRldGVjdCBiYXNlZCBvbiBjdXJyZW50IGxvY2F0aW9uXG4gIGNvbnN0IGhvc3RuYW1lID0gd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lO1xuICBjb25zdCBwcm90b2NvbCA9IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbDtcbiAgXG4gIC8vIExvY2FsIGRldmVsb3BtZW50XG4gIGlmIChob3N0bmFtZSA9PT0gJ2xvY2FsaG9zdCcgfHwgaG9zdG5hbWUgPT09ICcxMjcuMC4wLjEnKSB7XG4gICAgcmV0dXJuICdodHRwOi8vbG9jYWxob3N0OjMwMDAnO1xuICB9XG4gIFxuICAvLyBFeHRlcm5hbCBzZXJ2ZXIgLSBjb25zdHJ1Y3QgYmFja2VuZCBVUkxcbiAgLy8gSW4gQ29kZXIgZW52aXJvbm1lbnQsIHVzZSBIVFRQUyBmb3IgYmFja2VuZCBhcyB3ZWxsXG4gIGNvbnN0IGlzQ29kZXJFbnYgPSBob3N0bmFtZS5pbmNsdWRlcygnY29kZXIuam9zZXJuLmNvbScpO1xuICBjb25zdCBiYWNrZW5kUHJvdG9jb2wgPSBpc0NvZGVyRW52ID8gJ2h0dHBzOicgOiBwcm90b2NvbDtcbiAgXG4gIGlmIChpc0NvZGVyRW52KSB7XG4gICAgLy8gU3BlY2lhbCBoYW5kbGluZyBmb3IgQ29kZXIgc3ViZG9tYWluIHBhdHRlcm5cbiAgICBjb25zdCBiYWNrZW5kSG9zdG5hbWUgPSBob3N0bmFtZS5yZXBsYWNlKC9eOTAwMi0tLywgJzMwMDAtLScpO1xuICAgIGNvbnN0IGFwaUJhc2UgPSBgJHtiYWNrZW5kUHJvdG9jb2x9Ly8ke2JhY2tlbmRIb3N0bmFtZX1gO1xuICAgIHJldHVybiBhcGlCYXNlO1xuICB9XG4gIFxuICBjb25zdCBhcGlCYXNlID0gYCR7YmFja2VuZFByb3RvY29sfS8vJHtob3N0bmFtZX06MzAwMGA7XG4gIHJldHVybiBhcGlCYXNlO1xufTtcblxuY29uc3QgQVBJX0JBU0UgPSBnZXRBcGlCYXNlKCk7XG5cbi8vIFdlIHVzZSBjb29raWUtYmFzZWQgYXV0aCAoSHR0cE9ubHkgY29va2llKS4gQXZvaWQgcmVseWluZyBvbiBjbGllbnQtc3RvcmVkIEpXVHMuXG5sZXQgYXV0aFRva2VuOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcblxuZnVuY3Rpb24gc2V0QXV0aFRva2VuKHRva2VuOiBzdHJpbmcgfCBudWxsKSB7XG4gIC8vIEtlZXAgZnVuY3Rpb24gZm9yIGxlZ2FjeSBjbGVhbnVwOyBkbyBub3QgcGVyc2lzdCB0b2tlbnMgdG8gbG9jYWxTdG9yYWdlIGJ5IGRlZmF1bHQuXG4gIGF1dGhUb2tlbiA9IG51bGw7XG4gIHRyeSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHRva2VuID09PSBudWxsKSB7XG4gICAgICAvLyByZW1vdmUgYW55IGxlZ2FjeSB0b2tlbiB2YWx1ZVxuICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdvcmNoZXBsYW5fdG9rZW4nKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBpZ25vcmUgc3RvcmFnZSBlcnJvcnMgaW4gcmVzdHJpY3RlZCBlbnZpcm9ubWVudHNcbiAgfVxufVxuXG50eXBlIEZldGNoT3B0aW9ucyA9IE9taXQ8UmVxdWVzdEluaXQsICdib2R5Jz4gJiB7IFxuICBib2R5PzogYW55O1xuICBfY3NyZlJldHJ5PzogYm9vbGVhbjsgLy8gSW50ZXJuYWwgZmxhZyB0byBwcmV2ZW50IGluZmluaXRlIHJldHJ5IGxvb3BzXG59XG5cbi8vIENyZWF0ZSBhbiBlcnJvciB0aGF0IHdvbid0IGxvZyBzdGFjayB0cmFjZXMgKGV4cGVjdGVkIHVzZXIgZXJyb3IpXG5mdW5jdGlvbiBjcmVhdGVFeHBlY3RlZEVycm9yKG1lc3NhZ2U6IHN0cmluZywgc3RhdHVzPzogbnVtYmVyLCBib2R5PzogYW55KTogRXJyb3Ige1xuICBjb25zdCBlcnJvcjogYW55ID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICBlcnJvci5zdGF0dXMgPSBzdGF0dXM7XG4gIGVycm9yLmJvZHkgPSBib2R5O1xuICBlcnJvci5pc0V4cGVjdGVkID0gdHJ1ZTtcbiAgcmV0dXJuIGVycm9yO1xufVxuXG5hc3luYyBmdW5jdGlvbiByZXF1ZXN0KHBhdGg6IHN0cmluZywgb3B0czogRmV0Y2hPcHRpb25zID0ge30pIHtcbiAgY29uc3QgaGVhZGVyczogYW55ID0gb3B0cy5oZWFkZXJzID8gey4uLm9wdHMuaGVhZGVyc30gOiB7fVxuICBcbiAgLy8gQWRkIENTUkYgdG9rZW4gZm9yIHN0YXRlLWNoYW5naW5nIHJlcXVlc3RzXG4gIGlmIChvcHRzLm1ldGhvZCAmJiBbJ1BPU1QnLCAnUFVUJywgJ0RFTEVURScsICdQQVRDSCddLmluY2x1ZGVzKG9wdHMubWV0aG9kLnRvVXBwZXJDYXNlKCkpKSB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGFkZENzcmZIZWFkZXJzKGhlYWRlcnMpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBJbiBwcm9kdWN0aW9uLCB0aGlzIHNob3VsZCBmYWlsIHRoZSByZXF1ZXN0XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgXG4gIC8vIFdlIHJlbHkgb24gY29va2llLWJhc2VkIGF1dGhlbnRpY2F0aW9uIChjcmVkZW50aWFsczogJ2luY2x1ZGUnKS5cbiAgLy8gRG8gbm90IGF0dGFjaCBBdXRob3JpemF0aW9uIGhlYWRlciBmcm9tIGNsaWVudC1zaWRlIEpXVHMuXG4gIGlmIChvcHRzLmJvZHkgJiYgdHlwZW9mIG9wdHMuYm9keSA9PT0gJ29iamVjdCcpIHtcbiAgICBoZWFkZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgIG9wdHMuYm9keSA9IEpTT04uc3RyaW5naWZ5KG9wdHMuYm9keSlcbiAgfVxuXG4gIGNvbnN0IHVybCA9IEFQSV9CQVNFICsgcGF0aDtcblxuICB0cnkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgY3JlZGVudGlhbHM6ICdpbmNsdWRlJywgLy8gYWxsb3cgY29va2llc1xuICAgICAgLi4ub3B0cyxcbiAgICAgIGhlYWRlcnMsXG4gICAgfSlcblxuICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXMudGV4dCgpXG4gICAgbGV0IGRhdGE6IGFueSA9IHVuZGVmaW5lZFxuICAgIHRyeSB7IGRhdGEgPSB0ZXh0ID8gSlNPTi5wYXJzZSh0ZXh0KSA6IHVuZGVmaW5lZCB9IGNhdGNoKGUpIHsgZGF0YSA9IHRleHQgfVxuXG4gICAgICAgIC8vIGRlYnVnOiBsb2cgc21hbGwgcmVxdWVzdC9yZXNwb25zZSBzdW1tYXJpZXMgdG8gYWlkIGxvY2FsIHRyb3VibGVzaG9vdGluZ1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzYWZlQm9keSA9ICgoKSA9PiB7XG4gICAgICAgIHRyeSB7IHJldHVybiBvcHRzLmJvZHkgPyBKU09OLnBhcnNlKG9wdHMuYm9keSBhcyBzdHJpbmcpIDogbnVsbCB9IGNhdGNoIHsgcmV0dXJuIG9wdHMuYm9keSB9XG4gICAgICB9KSgpXG4gICAgICAvLyBSZW1vdmUgZGVidWcgbG9nZ2luZyBpbiBwcm9kdWN0aW9uXG4gICAgfSBjYXRjaCAoZSkge31cblxuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICBjb25zdCBtc2cgPSBkYXRhPy5tZXNzYWdlIHx8IGRhdGE/LmVycm9yIHx8IHJlcy5zdGF0dXNUZXh0IHx8ICdSZXF1ZXN0IGZhaWxlZCdcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhbiBleHBlY3RlZCBlcnJvciB0aGF0IHNob3VsZG4ndCBjcmVhdGUgYSBsb2dnZWQgRXJyb3JcbiAgICAgIGNvbnN0IGlzQXV0aEVuZHBvaW50ID0gdXJsLmluY2x1ZGVzKCcvYXV0aC8nKTtcbiAgICAgIGNvbnN0IGlzNDAwID0gcmVzLnN0YXR1cyA9PT0gNDAwO1xuICAgICAgY29uc3QgaXM0MDEgPSByZXMuc3RhdHVzID09PSA0MDE7XG4gICAgICBjb25zdCBpczQwNCA9IHJlcy5zdGF0dXMgPT09IDQwNDtcbiAgICAgIGNvbnN0IGlzNDA5ID0gcmVzLnN0YXR1cyA9PT0gNDA5O1xuICAgICAgY29uc3QgaXNFeHBlY3RlZEF1dGggPSBpc0F1dGhFbmRwb2ludCAmJiAoaXM0MDAgfHwgaXM0MDEgfHwgaXM0MDQgfHwgaXM0MDkpO1xuICAgICAgXG4gICAgICAvLyBDcmVhdGUgZXJyb3Igb2JqZWN0XG4gICAgICBsZXQgZXJyOiBhbnk7XG4gICAgICBcbiAgICAgIGlmIChpc0V4cGVjdGVkQXV0aCkge1xuICAgICAgICAvLyBGb3IgZXhwZWN0ZWQgYXV0aCBlcnJvcnMsIGNyZWF0ZSBhIHBsYWluIG9iamVjdCB0aGF0IHdvbid0IGJlIGxvZ2dlZCBieSB0aGUgYnJvd3NlclxuICAgICAgICBlcnIgPSB7XG4gICAgICAgICAgbWVzc2FnZTogbXNnLFxuICAgICAgICAgIHN0YXR1czogcmVzLnN0YXR1cyxcbiAgICAgICAgICBib2R5OiBkYXRhLFxuICAgICAgICAgIGlzRXhwZWN0ZWQ6IHRydWUsXG4gICAgICAgICAgbmFtZTogJ0V4cGVjdGVkQVBJRXJyb3InXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3IgdW5leHBlY3RlZCBlcnJvcnMsIGNyZWF0ZSBhIHByb3BlciBFcnJvciBvYmplY3QgZm9yIGRlYnVnZ2luZ1xuICAgICAgICBlcnIgPSBuZXcgRXJyb3IobXNnKTtcbiAgICAgICAgZXJyLnN0YXR1cyA9IHJlcy5zdGF0dXM7XG4gICAgICAgIGVyci5ib2R5ID0gZGF0YTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGFcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgYSBDU1JGIGVycm9yICg0MDMgc3RhdHVzIG9mdGVuIGluZGljYXRlcyBDU1JGIGZhaWx1cmUpXG4gICAgaWYgKGVycm9yPy5zdGF0dXMgPT09IDQwMyAmJiBlcnJvcj8uYm9keT8uY29kZSA9PT0gJ0VCQURDU1JGVE9LRU4nKSB7XG4gICAgICAvLyBDbGVhciBjYWNoZWQgQ1NSRiB0b2tlbiBhbmQgcmV0cnkgb25jZVxuICAgICAgY29uc3QgeyBjbGVhckNzcmZUb2tlbiB9ID0gYXdhaXQgaW1wb3J0KCcuL2NzcmYnKTtcbiAgICAgIGNsZWFyQ3NyZlRva2VuKCk7XG4gICAgICBcbiAgICAgIC8vIE9ubHkgcmV0cnkgb25jZSB0byBhdm9pZCBpbmZpbml0ZSBsb29wc1xuICAgICAgaWYgKCFvcHRzLl9jc3JmUmV0cnkpIHtcbiAgICAgICAgcmV0dXJuIHJlcXVlc3QocGF0aCwgeyAuLi5vcHRzLCBfY3NyZlJldHJ5OiB0cnVlIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBDaGVjayBpZiB0aGlzIGlzIGFuIGV4cGVjdGVkIGVycm9yIHRoYXQgc2hvdWxkbid0IGJlIGxvZ2dlZFxuICAgIGNvbnN0IGlzQXV0aEVuZHBvaW50ID0gdXJsLmluY2x1ZGVzKCcvYXV0aC8nKTtcbiAgICBjb25zdCBpczQwMCA9IGVycm9yPy5zdGF0dXMgPT09IDQwMDtcbiAgICBjb25zdCBpczQwMSA9IGVycm9yPy5zdGF0dXMgPT09IDQwMTtcbiAgICBjb25zdCBpczQwNCA9IGVycm9yPy5zdGF0dXMgPT09IDQwNDtcbiAgICBjb25zdCBpczQwOSA9IGVycm9yPy5zdGF0dXMgPT09IDQwOTtcbiAgICBjb25zdCBpc0V4cGVjdGVkQXV0aCA9IGlzQXV0aEVuZHBvaW50ICYmIChpczQwMCB8fCBpczQwMSB8fCBpczQwNCB8fCBpczQwOSk7XG4gICAgY29uc3QgaXNTdGFsZUF1dGggPSAhaXNBdXRoRW5kcG9pbnQgJiYgKGlzNDAxIHx8IGlzNDA0KTtcbiAgICBcbiAgICAvLyBNYXJrIGV4cGVjdGVkIGVycm9yc1xuICAgIGlmIChpc0V4cGVjdGVkQXV0aCB8fCBpc1N0YWxlQXV0aCkge1xuICAgICAgZXJyb3IuaXNFeHBlY3RlZCA9IHRydWU7XG4gICAgfVxuICAgIFxuICAgIC8vIE9ubHkgbG9nIHVuZXhwZWN0ZWQgZXJyb3JzXG4gICAgaWYgKCFpc0V4cGVjdGVkQXV0aCAmJiAhaXNTdGFsZUF1dGgpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1thcGldIFJlcXVlc3QgZmFpbGVkOicsIHtcbiAgICAgICAgdXJsLFxuICAgICAgICBtZXRob2Q6IG9wdHMubWV0aG9kIHx8ICdHRVQnLFxuICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpLFxuICAgICAgICBzdGF0dXM6IGVycm9yPy5zdGF0dXMsXG4gICAgICAgIHN0YXR1c1RleHQ6IGVycm9yPy5zdGF0dXNUZXh0LFxuICAgICAgICBib2R5OiBlcnJvcj8uYm9keSxcbiAgICAgICAgc3RhY2s6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5zdGFjayA6IHVuZGVmaW5lZCxcbiAgICAgICAgZnVsbEVycm9yOiBlcnJvcixcbiAgICAgICAgZXJyb3JUeXBlOiB0eXBlb2YgZXJyb3IsXG4gICAgICAgIGVycm9yQ29uc3RydWN0b3I6IGVycm9yPy5jb25zdHJ1Y3Rvcj8ubmFtZSxcbiAgICAgICAgaXNOZXR3b3JrRXJyb3I6ICFlcnJvcj8uc3RhdHVzLFxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgLy8gQWRkaXRpb25hbCBkZWJ1Z2dpbmcgaW5mb1xuICAgICAgICBlcnJvcktleXM6IGVycm9yID8gT2JqZWN0LmtleXMoZXJyb3IpIDogW10sXG4gICAgICAgIGVycm9ySnNvbjogZXJyb3IgPyBKU09OLnN0cmluZ2lmeShlcnJvciwgbnVsbCwgMikgOiAnbnVsbCcsXG4gICAgICAgIGhhc0Vycm9yTWVzc2FnZTogISFlcnJvcj8ubWVzc2FnZSxcbiAgICAgICAgaGFzRXJyb3JTdGF0dXM6ICEhZXJyb3I/LnN0YXR1cyxcbiAgICAgICAgaGFzRXJyb3JCb2R5OiAhIWVycm9yPy5ib2R5LFxuICAgICAgICBpc0F1dGhFbmRwb2ludCxcbiAgICAgICAgZXhwZWN0ZWRBdXRoRmxhZ3M6IHsgaXNFeHBlY3RlZEF1dGgsIGlzU3RhbGVBdXRoLCBpczQwMCwgaXM0MDEsIGlzNDA0LCBpczQwOSB9XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGlzU3RhbGVBdXRoKSB7XG4gICAgICAvLyBMb2cgc3RhbGUgYXV0aCBhcyB3YXJuaW5nIG9ubHlcbiAgICAgIGNvbnNvbGUud2FybignW2FwaV0gQXV0aGVudGljYXRpb24gbWF5IGJlIHN0YWxlOicsIHtcbiAgICAgICAgdXJsLFxuICAgICAgICBzdGF0dXM6IGVycm9yLnN0YXR1cyxcbiAgICAgICAgbWVzc2FnZTogJ0NvbnNpZGVyIGNsZWFyaW5nIGJyb3dzZXIgZGF0YSBpZiB0aGlzIHBlcnNpc3RzJ1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIEZvciBpc0V4cGVjdGVkQXV0aCwgd2UgZG9uJ3QgbG9nIGFueXRoaW5nIChzaWxlbnQpXG4gICAgXG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGF1dGhMb2dpbihlbWFpbDogc3RyaW5nLCBwYXNzd29yZDogc3RyaW5nKSB7XG4gIC8vIEZvciBjb29raWUtYmFzZWQgYXV0aCB3ZSBkb24ndCBuZWVkIHRvIHBlcnNpc3QgdGhlIEpXVCBjbGllbnQtc2lkZS5cbiAgLy8gVGhlIHNlcnZlciBzZXRzIGFuIEh0dHBPbmx5IGNvb2tpZSB3aXRoIHRoZSB0b2tlbi5cbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwOiBhbnkgPSBhd2FpdCByZXF1ZXN0KCcvYXV0aC9sb2dpbicsIHsgbWV0aG9kOiAnUE9TVCcsIGJvZHk6IHsgZW1haWwsIHBhc3N3b3JkIH0gfSlcbiAgICByZXR1cm4gcmVzcFxuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgLy8gRm9yIGV4cGVjdGVkIGF1dGggZXJyb3JzLCBkb24ndCByZS10aHJvdyB0byBhdm9pZCBjb25zb2xlIGxvZ2dpbmdcbiAgICBpZiAoZXJyb3Iuc3RhdHVzID09PSA0MDAgfHwgZXJyb3Iuc3RhdHVzID09PSA0MDEpIHtcbiAgICAgIC8vIFJldHVybiB0aGUgZXJyb3IgYXMgYSBzdHJ1Y3R1cmVkIHJlc3BvbnNlIGluc3RlYWQgb2YgdGhyb3dpbmdcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogZXJyb3IuYm9keT8uZXJyb3IgfHwgZXJyb3IubWVzc2FnZSB8fCAnTG9naW4gZmFpbGVkJyxcbiAgICAgICAgc3RhdHVzOiBlcnJvci5zdGF0dXMsXG4gICAgICAgIGlzRXhwZWN0ZWQ6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICAgIC8vIEZvciB1bmV4cGVjdGVkIGVycm9ycywgc3RpbGwgdGhyb3dcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYXV0aFNpZ251cChuYW1lOiBzdHJpbmcsIGVtYWlsOiBzdHJpbmcsIHBhc3N3b3JkOiBzdHJpbmcpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwID0gYXdhaXQgcmVxdWVzdCgnL2F1dGgvc2lnbnVwJywge1xuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgbmFtZSwgZW1haWwsIHBhc3N3b3JkIH0pXG4gICAgfSlcbiAgICByZXR1cm4gcmVzcFxuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgLy8gRm9yIGV4cGVjdGVkIGF1dGggZXJyb3JzLCBkb24ndCByZS10aHJvdyB0byBhdm9pZCBjb25zb2xlIGxvZ2dpbmdcbiAgICBpZiAoZXJyb3Iuc3RhdHVzID09PSA0MDAgfHwgZXJyb3Iuc3RhdHVzID09PSA0MDkpIHtcbiAgICAgIC8vIFJldHVybiB0aGUgZXJyb3IgYXMgYSBzdHJ1Y3R1cmVkIHJlc3BvbnNlIGluc3RlYWQgb2YgdGhyb3dpbmdcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogZXJyb3IuYm9keT8uZXJyb3IgfHwgZXJyb3IubWVzc2FnZSB8fCAnU2lnbnVwIGZhaWxlZCcsXG4gICAgICAgIHN0YXR1czogZXJyb3Iuc3RhdHVzLFxuICAgICAgICBpc0V4cGVjdGVkOiB0cnVlXG4gICAgICB9O1xuICAgIH1cbiAgICAvLyBGb3IgdW5leHBlY3RlZCBlcnJvcnMsIHN0aWxsIHRocm93XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGF1dGhMb2dvdXQoKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcCA9IGF3YWl0IHJlcXVlc3QoJy9hdXRoL2xvZ291dCcsIHsgbWV0aG9kOiAnUE9TVCcgfSlcbiAgICByZXR1cm4gcmVzcFxuICB9IGZpbmFsbHkge1xuICAgIC8vIGNsZWFyIHRva2VuIGNsaWVudC1zaWRlIHJlZ2FyZGxlc3Mgb2Ygc2VydmVyIHJlc3BvbnNlXG4gICAgc2V0QXV0aFRva2VuKG51bGwpXG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGF1dGhNZSgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gYXdhaXQgcmVxdWVzdCgnL2F1dGgvbWUnLCB7IG1ldGhvZDogJ0dFVCcgfSk7XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAvLyBJZiB1bmF1dGhvcml6ZWQgKDQwMSkgb3IgdXNlciBub3QgZm91bmQgKDQwNCksIHJldHVybiBudWxsIGluc3RlYWQgb2YgdGhyb3dpbmdcbiAgICAvLyBUaGlzIGlzIGV4cGVjdGVkIHdoZW4gbm8gdXNlciBpcyBsb2dnZWQgaW4gb3Igc2Vzc2lvbiBpcyBpbnZhbGlkXG4gICAgaWYgKGVycm9yLnN0YXR1cyA9PT0gNDAxIHx8IGVycm9yLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gRm9yIG90aGVyIGVycm9ycywgbWFyayBhcyB1bmV4cGVjdGVkIGFuZCByZS10aHJvd1xuICAgIGVycm9yLmlzRXhwZWN0ZWQgPSBmYWxzZTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYXV0aENoYW5nZVBhc3N3b3JkKGN1cnJlbnRQYXNzd29yZDogc3RyaW5nLCBuZXdQYXNzd29yZDogc3RyaW5nKSB7XG4gIHJldHVybiByZXF1ZXN0KCcvYXV0aC9jaGFuZ2UtcGFzc3dvcmQnLCB7IG1ldGhvZDogJ1BPU1QnLCBib2R5OiB7IGN1cnJlbnRQYXNzd29yZCwgbmV3UGFzc3dvcmQgfSB9KVxufVxuXG4vLyBTZXJ2ZXItc2lkZSBleHRlcm5hbCBwcm94eSBoZWxwZXJcbi8vIFVzYWdlOiBleHRlcm5hbFByb3h5KCdjb2Rlci5qb3Nlcm4uY29tJywgJy9hcGkvdjIvYXBwbGljYXRpb25zL2F1dGgtcmVkaXJlY3QnKVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGV4dGVybmFsUHJveHkoaG9zdDogc3RyaW5nLCB0YXJnZXQ6IHN0cmluZywgb3B0czogRmV0Y2hPcHRpb25zID0ge30pIHtcbiAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICBwYXJhbXMuc2V0KCdob3N0JywgaG9zdCk7XG4gIHBhcmFtcy5zZXQoJ3RhcmdldCcsIHRhcmdldCk7XG4gIGNvbnN0IHBhdGggPSBgL2V4dGVybmFsLXByb3h5PyR7cGFyYW1zLnRvU3RyaW5nKCl9YDtcbiAgcmV0dXJuIHJlcXVlc3QocGF0aCwgeyBtZXRob2Q6IG9wdHMubWV0aG9kIHx8ICdHRVQnLCBib2R5OiBvcHRzLmJvZHksIGhlYWRlcnM6IG9wdHMuaGVhZGVycyB9KTtcbn1cblxuLy8gUHJvamVjdHNcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRQcm9qZWN0cygpIHtcbiAgcmV0dXJuIHJlcXVlc3QoJy9wcm9qZWN0cycsIHsgbWV0aG9kOiAnR0VUJyB9KVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UHJvamVjdChwcm9qZWN0SWQ6IHN0cmluZykge1xuICByZXR1cm4gcmVxdWVzdChgL3Byb2plY3RzLyR7cHJvamVjdElkfWAsIHsgbWV0aG9kOiAnR0VUJyB9KVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlUHJvamVjdChib2R5OiBhbnkpIHtcbiAgcmV0dXJuIHJlcXVlc3QoJy9wcm9qZWN0cycsIHsgbWV0aG9kOiAnUE9TVCcsIGJvZHkgfSlcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZVByb2plY3RBcGkocHJvamVjdElkOiBzdHJpbmcsIGJvZHk6IGFueSkge1xuICByZXR1cm4gcmVxdWVzdChgL3Byb2plY3RzLyR7cHJvamVjdElkfWAsIHsgbWV0aG9kOiAnUFVUJywgYm9keSB9KVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGVsZXRlUHJvamVjdEFwaShwcm9qZWN0SWQ6IHN0cmluZykge1xuICByZXR1cm4gcmVxdWVzdChgL3Byb2plY3RzLyR7cHJvamVjdElkfWAsIHsgbWV0aG9kOiAnREVMRVRFJyB9KVxufVxuXG4vLyBQcm9qZWN0IE1lbWJlcnNcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhZGRQcm9qZWN0TWVtYmVyKHByb2plY3RJZDogc3RyaW5nLCB1c2VySWQ6IHN0cmluZywgcm9sZTogc3RyaW5nKSB7XG4gIHJldHVybiByZXF1ZXN0KGAvcHJvamVjdHMvJHtwcm9qZWN0SWR9L21lbWJlcnNgLCB7IG1ldGhvZDogJ1BPU1QnLCBib2R5OiB7IHVzZXJJZCwgcm9sZSB9IH0pXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB1cGRhdGVQcm9qZWN0TWVtYmVyUm9sZShwcm9qZWN0SWQ6IHN0cmluZywgdXNlcklkOiBzdHJpbmcsIHJvbGU6IHN0cmluZykge1xuICByZXR1cm4gcmVxdWVzdChgL3Byb2plY3RzLyR7cHJvamVjdElkfS9tZW1iZXJzLyR7dXNlcklkfWAsIHsgbWV0aG9kOiAnUFVUJywgYm9keTogeyByb2xlIH0gfSlcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlbW92ZVByb2plY3RNZW1iZXIocHJvamVjdElkOiBzdHJpbmcsIHVzZXJJZDogc3RyaW5nKSB7XG4gIHJldHVybiByZXF1ZXN0KGAvcHJvamVjdHMvJHtwcm9qZWN0SWR9L21lbWJlcnMvJHt1c2VySWR9YCwgeyBtZXRob2Q6ICdERUxFVEUnIH0pXG59XG5cbi8vIFVzZXJzXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0VXNlcnMoKSB7XG4gIHJldHVybiByZXF1ZXN0KCcvdXNlcnMnLCB7IG1ldGhvZDogJ0dFVCcgfSlcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZVVzZXJBcGkodXNlcklkOiBzdHJpbmcsIGJvZHk6IHsgbmFtZT86IHN0cmluZzsgZW1haWw/OiBzdHJpbmcgfSkge1xuICByZXR1cm4gcmVxdWVzdChgL3VzZXJzLyR7dXNlcklkfWAsIHsgbWV0aG9kOiAnUFVUJywgYm9keSB9KTtcbn1cblxuLy8gVGFza3NcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRUYXNrc0J5UHJvamVjdElkcyhwcm9qZWN0SWRzOiBzdHJpbmdbXSkge1xuICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gIHByb2plY3RJZHMuZm9yRWFjaChpZCA9PiBwYXJhbXMuYXBwZW5kKCdwcm9qZWN0SWQnLCBpZCkpO1xuICByZXR1cm4gcmVxdWVzdChgL3Rhc2tzPyR7cGFyYW1zLnRvU3RyaW5nKCl9YCwgeyBtZXRob2Q6ICdHRVQnIH0pXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVUYXNrQXBpKGJvZHk6IGFueSkge1xuICByZXR1cm4gcmVxdWVzdCgnL3Rhc2tzJywgeyBtZXRob2Q6ICdQT1NUJywgYm9keSB9KVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBkYXRlVGFza0FwaSh0YXNrSWQ6IHN0cmluZywgYm9keTogYW55KSB7XG4gIHJldHVybiByZXF1ZXN0KGAvdGFza3MvJHt0YXNrSWR9YCwgeyBtZXRob2Q6ICdQVVQnLCBib2R5IH0pXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZWxldGVUYXNrQXBpKHRhc2tJZDogc3RyaW5nKSB7XG4gIHJldHVybiByZXF1ZXN0KGAvdGFza3MvJHt0YXNrSWR9YCwgeyBtZXRob2Q6ICdERUxFVEUnIH0pXG59XG5cbi8vIFRhc2sgQ29tbWVudHNcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRUYXNrQ29tbWVudHModGFza0lkOiBzdHJpbmcpIHtcbiAgcmV0dXJuIHJlcXVlc3QoYC90YXNrcy8ke3Rhc2tJZH0vY29tbWVudHNgLCB7IG1ldGhvZDogJ0dFVCcgfSk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVUYXNrQ29tbWVudCh0YXNrSWQ6IHN0cmluZywgY29udGVudDogc3RyaW5nKSB7XG4gIHJldHVybiByZXF1ZXN0KGAvdGFza3MvJHt0YXNrSWR9L2NvbW1lbnRzYCwgeyBtZXRob2Q6ICdQT1NUJywgYm9keTogeyBjb250ZW50IH0gfSk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB1cGRhdGVUYXNrQ29tbWVudCh0YXNrSWQ6IHN0cmluZywgY29tbWVudElkOiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZykge1xuICByZXR1cm4gcmVxdWVzdChgL3Rhc2tzLyR7dGFza0lkfS9jb21tZW50cy8ke2NvbW1lbnRJZH1gLCB7IG1ldGhvZDogJ1BVVCcsIGJvZHk6IHsgY29udGVudCB9IH0pO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGVsZXRlVGFza0NvbW1lbnQodGFza0lkOiBzdHJpbmcsIGNvbW1lbnRJZDogc3RyaW5nKSB7XG4gIHJldHVybiByZXF1ZXN0KGAvdGFza3MvJHt0YXNrSWR9L2NvbW1lbnRzLyR7Y29tbWVudElkfWAsIHsgbWV0aG9kOiAnREVMRVRFJyB9KTtcbn1cblxuLy8gU3RhdHVzZXMgKHRhc2tfc3RhdHVzZXMpXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UHJvamVjdFN0YXR1c2VzKHByb2plY3RJZDogc3RyaW5nKSB7XG4gIHJldHVybiByZXF1ZXN0KGAvcHJvamVjdHMvJHtwcm9qZWN0SWR9L3N0YXR1c2VzYCwgeyBtZXRob2Q6ICdHRVQnIH0pO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlUHJvamVjdFN0YXR1cyhwcm9qZWN0SWQ6IHN0cmluZywgYm9keTogeyBsYWJlbDogc3RyaW5nOyBvcmRlcj86IG51bWJlcjsgY29sb3I/OiBzdHJpbmcgfCBudWxsOyBzaG93U3RyaWtlVGhyb3VnaD86IGJvb2xlYW47IGhpZGRlbj86IGJvb2xlYW47IHJlcXVpcmVzQ29tbWVudD86IGJvb2xlYW47IGFsbG93c0NvbW1lbnQ/OiBib29sZWFuIH0pIHtcbiAgcmV0dXJuIHJlcXVlc3QoYC9wcm9qZWN0cy8ke3Byb2plY3RJZH0vc3RhdHVzZXNgLCB7IG1ldGhvZDogJ1BPU1QnLCBib2R5IH0pO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBkYXRlUHJvamVjdFN0YXR1cyhwcm9qZWN0SWQ6IHN0cmluZywgc3RhdHVzSWQ6IHN0cmluZywgYm9keTogeyBsYWJlbD86IHN0cmluZzsgb3JkZXI/OiBudW1iZXI7IGNvbG9yPzogc3RyaW5nIHwgbnVsbDsgc2hvd1N0cmlrZVRocm91Z2g/OiBib29sZWFuOyBoaWRkZW4/OiBib29sZWFuOyByZXF1aXJlc0NvbW1lbnQ/OiBib29sZWFuOyBhbGxvd3NDb21tZW50PzogYm9vbGVhbiB9KSB7XG4gIHJldHVybiByZXF1ZXN0KGAvcHJvamVjdHMvJHtwcm9qZWN0SWR9L3N0YXR1c2VzLyR7c3RhdHVzSWR9YCwgeyBtZXRob2Q6ICdQVVQnLCBib2R5IH0pO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGVsZXRlUHJvamVjdFN0YXR1cyhwcm9qZWN0SWQ6IHN0cmluZywgc3RhdHVzSWQ6IHN0cmluZykge1xuICByZXR1cm4gcmVxdWVzdChgL3Byb2plY3RzLyR7cHJvamVjdElkfS9zdGF0dXNlcy8ke3N0YXR1c0lkfWAsIHsgbWV0aG9kOiAnREVMRVRFJyB9KTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZVByb2plY3RTdGF0dXNlc09yZGVyKHByb2plY3RJZDogc3RyaW5nLCBzdGF0dXNlczogeyBpZDogc3RyaW5nOyBvcmRlcjogbnVtYmVyIH1bXSkge1xuICByZXR1cm4gcmVxdWVzdChgL3Byb2plY3RzLyR7cHJvamVjdElkfS9zdGF0dXNlcy9vcmRlcmAsIHsgbWV0aG9kOiAnUEFUQ0gnLCBib2R5OiB7IHN0YXR1c2VzIH0gfSk7XG59XG5cbi8vIEdlbmVyaWMgQVBJIHV0aWxpdHkgZm9yIGFkbWluIGFuZCBvdGhlciBjdXN0b20gZW5kcG9pbnRzXG5leHBvcnQgY29uc3QgYXBpID0ge1xuICBnZXQ6IChwYXRoOiBzdHJpbmcsIG9wdHM6IE9taXQ8RmV0Y2hPcHRpb25zLCAnbWV0aG9kJz4gPSB7fSkgPT4gXG4gICAgcmVxdWVzdChwYXRoLCB7IC4uLm9wdHMsIG1ldGhvZDogJ0dFVCcgfSksXG4gIHBvc3Q6IChwYXRoOiBzdHJpbmcsIGJvZHk/OiBhbnksIG9wdHM6IE9taXQ8RmV0Y2hPcHRpb25zLCAnbWV0aG9kJyB8ICdib2R5Jz4gPSB7fSkgPT4gXG4gICAgcmVxdWVzdChwYXRoLCB7IC4uLm9wdHMsIG1ldGhvZDogJ1BPU1QnLCBib2R5IH0pLFxuICBwdXQ6IChwYXRoOiBzdHJpbmcsIGJvZHk/OiBhbnksIG9wdHM6IE9taXQ8RmV0Y2hPcHRpb25zLCAnbWV0aG9kJyB8ICdib2R5Jz4gPSB7fSkgPT4gXG4gICAgcmVxdWVzdChwYXRoLCB7IC4uLm9wdHMsIG1ldGhvZDogJ1BVVCcsIGJvZHkgfSksXG4gIGRlbGV0ZTogKHBhdGg6IHN0cmluZywgb3B0czogT21pdDxGZXRjaE9wdGlvbnMsICdtZXRob2QnPiA9IHt9KSA9PiBcbiAgICByZXF1ZXN0KHBhdGgsIHsgLi4ub3B0cywgbWV0aG9kOiAnREVMRVRFJyB9KSxcbiAgcGF0Y2g6IChwYXRoOiBzdHJpbmcsIGJvZHk/OiBhbnksIG9wdHM6IE9taXQ8RmV0Y2hPcHRpb25zLCAnbWV0aG9kJyB8ICdib2R5Jz4gPSB7fSkgPT4gXG4gICAgcmVxdWVzdChwYXRoLCB7IC4uLm9wdHMsIG1ldGhvZDogJ1BBVENIJywgYm9keSB9KVxufTtcblxuLy8gVGFzayBtb3ZlIHdpdGggY29tbWVudCByZXF1aXJlbWVudHNcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBtb3ZlVGFza1RvU3RhdHVzKHRhc2tJZDogc3RyaW5nLCBzdGF0dXNJZDogc3RyaW5nLCBjb21tZW50Pzogc3RyaW5nKSB7XG4gIHJldHVybiByZXF1ZXN0KGAvdGFza3MvJHt0YXNrSWR9L21vdmVgLCB7IG1ldGhvZDogJ1BPU1QnLCBib2R5OiB7IHN0YXR1c0lkLCBjb21tZW50IH0gfSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHsgYXV0aExvZ2luLCBhdXRoU2lnbnVwLCBhdXRoTG9nb3V0LCBhdXRoTWUsIGF1dGhDaGFuZ2VQYXNzd29yZCwgZ2V0UHJvamVjdHMsIGdldFByb2plY3QsIGNyZWF0ZVByb2plY3QsIHVwZGF0ZVByb2plY3RBcGksIGRlbGV0ZVByb2plY3RBcGksIGFkZFByb2plY3RNZW1iZXIsIHVwZGF0ZVByb2plY3RNZW1iZXJSb2xlLCByZW1vdmVQcm9qZWN0TWVtYmVyLCBnZXRVc2VycywgdXBkYXRlVXNlckFwaSwgZ2V0VGFza3NCeVByb2plY3RJZHMsIGNyZWF0ZVRhc2tBcGksIHVwZGF0ZVRhc2tBcGksIGRlbGV0ZVRhc2tBcGksIGdldFRhc2tDb21tZW50cywgY3JlYXRlVGFza0NvbW1lbnQsIHVwZGF0ZVRhc2tDb21tZW50LCBkZWxldGVUYXNrQ29tbWVudCwgZ2V0UHJvamVjdFN0YXR1c2VzLCBjcmVhdGVQcm9qZWN0U3RhdHVzLCB1cGRhdGVQcm9qZWN0U3RhdHVzLCBkZWxldGVQcm9qZWN0U3RhdHVzLCB1cGRhdGVQcm9qZWN0U3RhdHVzZXNPcmRlciB9XG5cbi8vIGVhcmxpZXIgZGVmYXVsdCByZW1vdmVkOyBjb25zb2xpZGF0ZWQgYXQgZW5kXG4iXSwibmFtZXMiOlsiYWRkQ3NyZkhlYWRlcnMiLCJnZXRBcGlCYXNlIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0FQSV9CQVNFIiwiaG9zdG5hbWUiLCJ3aW5kb3ciLCJsb2NhdGlvbiIsInByb3RvY29sIiwiaXNDb2RlckVudiIsImluY2x1ZGVzIiwiYmFja2VuZFByb3RvY29sIiwiYmFja2VuZEhvc3RuYW1lIiwicmVwbGFjZSIsImFwaUJhc2UiLCJBUElfQkFTRSIsImF1dGhUb2tlbiIsInNldEF1dGhUb2tlbiIsInRva2VuIiwibG9jYWxTdG9yYWdlIiwicmVtb3ZlSXRlbSIsImUiLCJjcmVhdGVFeHBlY3RlZEVycm9yIiwibWVzc2FnZSIsInN0YXR1cyIsImJvZHkiLCJlcnJvciIsIkVycm9yIiwiaXNFeHBlY3RlZCIsInJlcXVlc3QiLCJwYXRoIiwib3B0cyIsImhlYWRlcnMiLCJtZXRob2QiLCJ0b1VwcGVyQ2FzZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJ1cmwiLCJyZXMiLCJmZXRjaCIsImNyZWRlbnRpYWxzIiwidGV4dCIsImRhdGEiLCJ1bmRlZmluZWQiLCJwYXJzZSIsInNhZmVCb2R5Iiwib2siLCJtc2ciLCJzdGF0dXNUZXh0IiwiaXNBdXRoRW5kcG9pbnQiLCJpczQwMCIsImlzNDAxIiwiaXM0MDQiLCJpczQwOSIsImlzRXhwZWN0ZWRBdXRoIiwiZXJyIiwibmFtZSIsImNvZGUiLCJjbGVhckNzcmZUb2tlbiIsIl9jc3JmUmV0cnkiLCJpc1N0YWxlQXV0aCIsImNvbnNvbGUiLCJTdHJpbmciLCJzdGFjayIsImZ1bGxFcnJvciIsImVycm9yVHlwZSIsImVycm9yQ29uc3RydWN0b3IiLCJpc05ldHdvcmtFcnJvciIsInRpbWVzdGFtcCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsImVycm9yS2V5cyIsIk9iamVjdCIsImtleXMiLCJlcnJvckpzb24iLCJoYXNFcnJvck1lc3NhZ2UiLCJoYXNFcnJvclN0YXR1cyIsImhhc0Vycm9yQm9keSIsImV4cGVjdGVkQXV0aEZsYWdzIiwid2FybiIsImF1dGhMb2dpbiIsImVtYWlsIiwicGFzc3dvcmQiLCJyZXNwIiwic3VjY2VzcyIsImF1dGhTaWdudXAiLCJhdXRoTG9nb3V0IiwiYXV0aE1lIiwiYXV0aENoYW5nZVBhc3N3b3JkIiwiY3VycmVudFBhc3N3b3JkIiwibmV3UGFzc3dvcmQiLCJleHRlcm5hbFByb3h5IiwiaG9zdCIsInRhcmdldCIsInBhcmFtcyIsIlVSTFNlYXJjaFBhcmFtcyIsInNldCIsInRvU3RyaW5nIiwiZ2V0UHJvamVjdHMiLCJnZXRQcm9qZWN0IiwicHJvamVjdElkIiwiY3JlYXRlUHJvamVjdCIsInVwZGF0ZVByb2plY3RBcGkiLCJkZWxldGVQcm9qZWN0QXBpIiwiYWRkUHJvamVjdE1lbWJlciIsInVzZXJJZCIsInJvbGUiLCJ1cGRhdGVQcm9qZWN0TWVtYmVyUm9sZSIsInJlbW92ZVByb2plY3RNZW1iZXIiLCJnZXRVc2VycyIsInVwZGF0ZVVzZXJBcGkiLCJnZXRUYXNrc0J5UHJvamVjdElkcyIsInByb2plY3RJZHMiLCJmb3JFYWNoIiwiaWQiLCJhcHBlbmQiLCJjcmVhdGVUYXNrQXBpIiwidXBkYXRlVGFza0FwaSIsInRhc2tJZCIsImRlbGV0ZVRhc2tBcGkiLCJnZXRUYXNrQ29tbWVudHMiLCJjcmVhdGVUYXNrQ29tbWVudCIsImNvbnRlbnQiLCJ1cGRhdGVUYXNrQ29tbWVudCIsImNvbW1lbnRJZCIsImRlbGV0ZVRhc2tDb21tZW50IiwiZ2V0UHJvamVjdFN0YXR1c2VzIiwiY3JlYXRlUHJvamVjdFN0YXR1cyIsInVwZGF0ZVByb2plY3RTdGF0dXMiLCJzdGF0dXNJZCIsImRlbGV0ZVByb2plY3RTdGF0dXMiLCJ1cGRhdGVQcm9qZWN0U3RhdHVzZXNPcmRlciIsInN0YXR1c2VzIiwiYXBpIiwiZ2V0IiwicG9zdCIsInB1dCIsImRlbGV0ZSIsInBhdGNoIiwibW92ZVRhc2tUb1N0YXR1cyIsImNvbW1lbnQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/api.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/lib/cache.ts":
/*!**************************!*\
  !*** ./src/lib/cache.ts ***!
  \**************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BatchCacheOperation: () => (/* binding */ BatchCacheOperation),\n/* harmony export */   CacheKeys: () => (/* binding */ CacheKeys),\n/* harmony export */   CacheTTL: () => (/* binding */ CacheTTL),\n/* harmony export */   batchCache: () => (/* binding */ batchCache),\n/* harmony export */   cacheManager: () => (/* binding */ cacheManager),\n/* harmony export */   cachedFetch: () => (/* binding */ cachedFetch)\n/* harmony export */ });\n/**\n * Advanced caching system for OrchePlan\n * Implements in-memory caching with TTL, versioning, and smart invalidation\n */ class CacheManager {\n    /**\n   * Get item from cache\n   */ get(key) {\n        const entry = this.cache.get(key);\n        if (!entry) {\n            this.stats.misses++;\n            return null;\n        }\n        // Check if expired\n        if (Date.now() > entry.expiresAt) {\n            this.cache.delete(key);\n            this.stats.misses++;\n            return null;\n        }\n        // Check version\n        if (entry.version !== this.currentVersion) {\n            this.cache.delete(key);\n            this.stats.misses++;\n            return null;\n        }\n        this.stats.hits++;\n        return entry.data;\n    }\n    /**\n   * Check if cache has valid entry\n   */ has(key) {\n        const entry = this.cache.get(key);\n        if (!entry) return false;\n        if (Date.now() > entry.expiresAt || entry.version !== this.currentVersion) {\n            this.cache.delete(key);\n            return false;\n        }\n        return true;\n    }\n    /**\n   * Check if entry is stale but still exists\n   */ isStale(key) {\n        const entry = this.cache.get(key);\n        if (!entry) return false;\n        return Date.now() > entry.expiresAt;\n    }\n    /**\n   * Set item in cache\n   */ set(key, data) {\n        let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        // Enforce max size with LRU eviction\n        if (this.cache.size >= this.maxSize) {\n            const firstKey = this.cache.keys().next().value;\n            if (firstKey) this.cache.delete(firstKey);\n        }\n        var _options_ttl;\n        const ttl = (_options_ttl = options.ttl) !== null && _options_ttl !== void 0 ? _options_ttl : this.defaultTTL;\n        var _options_version;\n        const version = (_options_version = options.version) !== null && _options_version !== void 0 ? _options_version : this.currentVersion;\n        const entry = {\n            data,\n            timestamp: Date.now(),\n            version,\n            expiresAt: Date.now() + ttl\n        };\n        this.cache.set(key, entry);\n    }\n    /**\n   * Invalidate specific cache key\n   */ invalidate(key) {\n        this.cache.delete(key);\n    }\n    /**\n   * Invalidate all keys matching a pattern\n   */ invalidatePattern(pattern) {\n        const regex = typeof pattern === 'string' ? new RegExp(pattern) : pattern;\n        for (const key of this.cache.keys()){\n            if (regex.test(key)) {\n                this.cache.delete(key);\n            }\n        }\n    }\n    /**\n   * Invalidate all cache entries\n   */ invalidateAll() {\n        this.cache.clear();\n        this.currentVersion++;\n    }\n    /**\n   * Remove expired entries\n   */ cleanup() {\n        const now = Date.now();\n        const expiredKeys = [];\n        for (const [key, entry] of this.cache.entries()){\n            if (now > entry.expiresAt || entry.version !== this.currentVersion) {\n                expiredKeys.push(key);\n            }\n        }\n        expiredKeys.forEach((key)=>this.cache.delete(key));\n        if (expiredKeys.length > 0) {}\n    }\n    /**\n   * Get cache statistics\n   */ getStats() {\n        const total = this.stats.hits + this.stats.misses;\n        return {\n            hits: this.stats.hits,\n            misses: this.stats.misses,\n            size: this.cache.size,\n            hitRate: total > 0 ? this.stats.hits / total : 0\n        };\n    }\n    /**\n   * Reset statistics\n   */ resetStats() {\n        this.stats = {\n            hits: 0,\n            misses: 0\n        };\n    }\n    /**\n   * Clear all cache and stats\n   */ clear() {\n        this.cache.clear();\n        this.stats = {\n            hits: 0,\n            misses: 0\n        };\n    }\n    /**\n   * Get cache size\n   */ get size() {\n        return this.cache.size;\n    }\n    constructor(defaultTTL = 5 * 60 * 1000, maxSize = 1000){\n        this.cache = new Map();\n        this.stats = {\n            hits: 0,\n            misses: 0\n        };\n        this.defaultTTL = defaultTTL; // 5 minutes default\n        this.maxSize = maxSize;\n        this.currentVersion = 1;\n        // Periodic cleanup of expired entries\n        if (true) {\n            setInterval(()=>this.cleanup(), 60 * 1000); // Every minute\n        }\n    }\n}\n// Singleton instance\nconst cacheManager = new CacheManager();\n// Cache key builders for consistency\nconst CacheKeys = {\n    projects: ()=>'projects:all',\n    project: (id)=>\"project:\".concat(id),\n    projectTasks: (projectId)=>\"tasks:project:\".concat(projectId),\n    projectsByIds: (ids)=>\"projects:ids:\".concat(ids.sort().join(',')),\n    tasks: (projectIds)=>\"tasks:projects:\".concat(projectIds.sort().join(',')),\n    tasksByIds: (ids)=>\"tasks:ids:\".concat(ids.sort().join(',')),\n    users: ()=>'users:all',\n    user: (id)=>\"user:\".concat(id),\n    projectStatuses: (projectId)=>\"statuses:project:\".concat(projectId)\n};\n// Cache TTL presets (in milliseconds)\nconst CacheTTL = {\n    short: 30 * 1000,\n    medium: 5 * 60 * 1000,\n    long: 15 * 60 * 1000,\n    veryLong: 60 * 60 * 1000\n};\n/**\n * Cached fetch wrapper with stale-while-revalidate support\n */ async function cachedFetch(key, fetcher) {\n    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    const cached = cacheManager.get(key);\n    // Fresh cache hit\n    if (cached !== null && !cacheManager.isStale(key)) {\n        return cached;\n    }\n    // Stale-while-revalidate: return stale data and fetch in background\n    if (options.staleWhileRevalidate && cached !== null) {\n        // Return stale data immediately\n        const staleData = cached;\n        // Fetch fresh data in background\n        fetcher().then((freshData)=>{\n            cacheManager.set(key, freshData, options);\n        }).catch((err)=>{\n            console.warn('[Cache] Background revalidation failed:', err);\n        });\n        return staleData;\n    }\n    // Cache miss or expired: fetch fresh data\n    try {\n        const data = await fetcher();\n        cacheManager.set(key, data, options);\n        return data;\n    } catch (error) {\n        // If fetch fails but we have stale data, return it as fallback\n        if (cached !== null) {\n            console.warn('[Cache] Fetch failed, returning stale data:', error);\n            return cached;\n        }\n        throw error;\n    }\n}\n/**\n * Batch cache operations\n */ class BatchCacheOperation {\n    invalidate(key) {\n        this.operations.push(()=>cacheManager.invalidate(key));\n        return this;\n    }\n    invalidatePattern(pattern) {\n        this.operations.push(()=>cacheManager.invalidatePattern(pattern));\n        return this;\n    }\n    set(key, data, options) {\n        this.operations.push(()=>cacheManager.set(key, data, options));\n        return this;\n    }\n    execute() {\n        this.operations.forEach((op)=>op());\n        this.operations = [];\n    }\n    constructor(){\n        this.operations = [];\n    }\n}\nfunction batchCache() {\n    return new BatchCacheOperation();\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFJLENBQUMsK0NBQStDQztZQUM1RCxPQUFPVDtRQUNUO1FBQ0EsTUFBTVM7SUFDUjtBQUNGO0FBRUE7O0NBRUMsR0FDTSxNQUFNQztJQUdYdEQsV0FBVzFCLEdBQVcsRUFBUTtRQUM1QixJQUFJLENBQUNpRixVQUFVLENBQUM1QyxJQUFJLENBQUMsSUFBTVMsYUFBYXBCLFVBQVUsQ0FBQzFCO1FBQ25ELE9BQU8sSUFBSTtJQUNiO0lBRUEyQixrQkFBa0JDLE9BQXdCLEVBQVE7UUFDaEQsSUFBSSxDQUFDcUQsVUFBVSxDQUFDNUMsSUFBSSxDQUFDLElBQU1TLGFBQWFuQixpQkFBaUIsQ0FBQ0M7UUFDMUQsT0FBTyxJQUFJO0lBQ2I7SUFFQWIsSUFBT2YsR0FBVyxFQUFFWSxJQUFPLEVBQUVJLE9BQXNCLEVBQVE7UUFDekQsSUFBSSxDQUFDaUUsVUFBVSxDQUFDNUMsSUFBSSxDQUFDLElBQU1TLGFBQWEvQixHQUFHLENBQUNmLEtBQUtZLE1BQU1JO1FBQ3ZELE9BQU8sSUFBSTtJQUNiO0lBRUFrRSxVQUFnQjtRQUNkLElBQUksQ0FBQ0QsVUFBVSxDQUFDM0MsT0FBTyxDQUFDNkMsQ0FBQUEsS0FBTUE7UUFDOUIsSUFBSSxDQUFDRixVQUFVLEdBQUcsRUFBRTtJQUN0Qjs7YUFwQlFBLGFBQWdDLEVBQUU7O0FBcUI1QztBQUVPLFNBQVNHO0lBQ2QsT0FBTyxJQUFJSjtBQUNiIiwic291cmNlcyI6WyIvaG9tZS9jb2Rlci9PcmNoZVBsYW4vZnJvbnRlbmQvc3JjL2xpYi9jYWNoZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEFkdmFuY2VkIGNhY2hpbmcgc3lzdGVtIGZvciBPcmNoZVBsYW5cbiAqIEltcGxlbWVudHMgaW4tbWVtb3J5IGNhY2hpbmcgd2l0aCBUVEwsIHZlcnNpb25pbmcsIGFuZCBzbWFydCBpbnZhbGlkYXRpb25cbiAqL1xuXG5leHBvcnQgaW50ZXJmYWNlIENhY2hlRW50cnk8VD4ge1xuICBkYXRhOiBUO1xuICB0aW1lc3RhbXA6IG51bWJlcjtcbiAgdmVyc2lvbjogbnVtYmVyO1xuICBleHBpcmVzQXQ6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDYWNoZU9wdGlvbnMge1xuICB0dGw/OiBudW1iZXI7IC8vIFRpbWUgdG8gbGl2ZSBpbiBtaWxsaXNlY29uZHNcbiAgdmVyc2lvbj86IG51bWJlcjsgLy8gQ2FjaGUgdmVyc2lvbiBmb3IgaW52YWxpZGF0aW9uXG4gIHN0YWxlV2hpbGVSZXZhbGlkYXRlPzogYm9vbGVhbjsgLy8gUmV0dXJuIHN0YWxlIGRhdGEgd2hpbGUgZmV0Y2hpbmcgZnJlc2hcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDYWNoZVN0YXRzIHtcbiAgaGl0czogbnVtYmVyO1xuICBtaXNzZXM6IG51bWJlcjtcbiAgc2l6ZTogbnVtYmVyO1xuICBoaXRSYXRlOiBudW1iZXI7XG59XG5cbmNsYXNzIENhY2hlTWFuYWdlciB7XG4gIHByaXZhdGUgY2FjaGU6IE1hcDxzdHJpbmcsIENhY2hlRW50cnk8YW55Pj47XG4gIHByaXZhdGUgc3RhdHM6IHsgaGl0czogbnVtYmVyOyBtaXNzZXM6IG51bWJlciB9O1xuICBwcml2YXRlIGRlZmF1bHRUVEw6IG51bWJlcjtcbiAgcHJpdmF0ZSBtYXhTaXplOiBudW1iZXI7XG4gIHByaXZhdGUgY3VycmVudFZlcnNpb246IG51bWJlcjtcblxuICBjb25zdHJ1Y3RvcihkZWZhdWx0VFRMOiBudW1iZXIgPSA1ICogNjAgKiAxMDAwLCBtYXhTaXplOiBudW1iZXIgPSAxMDAwKSB7XG4gICAgdGhpcy5jYWNoZSA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnN0YXRzID0geyBoaXRzOiAwLCBtaXNzZXM6IDAgfTtcbiAgICB0aGlzLmRlZmF1bHRUVEwgPSBkZWZhdWx0VFRMOyAvLyA1IG1pbnV0ZXMgZGVmYXVsdFxuICAgIHRoaXMubWF4U2l6ZSA9IG1heFNpemU7XG4gICAgdGhpcy5jdXJyZW50VmVyc2lvbiA9IDE7XG5cbiAgICAvLyBQZXJpb2RpYyBjbGVhbnVwIG9mIGV4cGlyZWQgZW50cmllc1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgc2V0SW50ZXJ2YWwoKCkgPT4gdGhpcy5jbGVhbnVwKCksIDYwICogMTAwMCk7IC8vIEV2ZXJ5IG1pbnV0ZVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgaXRlbSBmcm9tIGNhY2hlXG4gICAqL1xuICBnZXQ8VD4oa2V5OiBzdHJpbmcpOiBUIHwgbnVsbCB7XG4gICAgY29uc3QgZW50cnkgPSB0aGlzLmNhY2hlLmdldChrZXkpO1xuXG4gICAgaWYgKCFlbnRyeSkge1xuICAgICAgdGhpcy5zdGF0cy5taXNzZXMrKztcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIGV4cGlyZWRcbiAgICBpZiAoRGF0ZS5ub3coKSA+IGVudHJ5LmV4cGlyZXNBdCkge1xuICAgICAgdGhpcy5jYWNoZS5kZWxldGUoa2V5KTtcbiAgICAgIHRoaXMuc3RhdHMubWlzc2VzKys7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBDaGVjayB2ZXJzaW9uXG4gICAgaWYgKGVudHJ5LnZlcnNpb24gIT09IHRoaXMuY3VycmVudFZlcnNpb24pIHtcbiAgICAgIHRoaXMuY2FjaGUuZGVsZXRlKGtleSk7XG4gICAgICB0aGlzLnN0YXRzLm1pc3NlcysrO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy5zdGF0cy5oaXRzKys7XG4gICAgcmV0dXJuIGVudHJ5LmRhdGEgYXMgVDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBjYWNoZSBoYXMgdmFsaWQgZW50cnlcbiAgICovXG4gIGhhcyhrZXk6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5jYWNoZS5nZXQoa2V5KTtcbiAgICBpZiAoIWVudHJ5KSByZXR1cm4gZmFsc2U7XG4gICAgXG4gICAgaWYgKERhdGUubm93KCkgPiBlbnRyeS5leHBpcmVzQXQgfHwgZW50cnkudmVyc2lvbiAhPT0gdGhpcy5jdXJyZW50VmVyc2lvbikge1xuICAgICAgdGhpcy5jYWNoZS5kZWxldGUoa2V5KTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgZW50cnkgaXMgc3RhbGUgYnV0IHN0aWxsIGV4aXN0c1xuICAgKi9cbiAgaXNTdGFsZShrZXk6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5jYWNoZS5nZXQoa2V5KTtcbiAgICBpZiAoIWVudHJ5KSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIERhdGUubm93KCkgPiBlbnRyeS5leHBpcmVzQXQ7XG4gIH1cblxuICAvKipcbiAgICogU2V0IGl0ZW0gaW4gY2FjaGVcbiAgICovXG4gIHNldDxUPihrZXk6IHN0cmluZywgZGF0YTogVCwgb3B0aW9uczogQ2FjaGVPcHRpb25zID0ge30pOiB2b2lkIHtcbiAgICAvLyBFbmZvcmNlIG1heCBzaXplIHdpdGggTFJVIGV2aWN0aW9uXG4gICAgaWYgKHRoaXMuY2FjaGUuc2l6ZSA+PSB0aGlzLm1heFNpemUpIHtcbiAgICAgIGNvbnN0IGZpcnN0S2V5ID0gdGhpcy5jYWNoZS5rZXlzKCkubmV4dCgpLnZhbHVlO1xuICAgICAgaWYgKGZpcnN0S2V5KSB0aGlzLmNhY2hlLmRlbGV0ZShmaXJzdEtleSk7XG4gICAgfVxuXG4gICAgY29uc3QgdHRsID0gb3B0aW9ucy50dGwgPz8gdGhpcy5kZWZhdWx0VFRMO1xuICAgIGNvbnN0IHZlcnNpb24gPSBvcHRpb25zLnZlcnNpb24gPz8gdGhpcy5jdXJyZW50VmVyc2lvbjtcblxuICAgIGNvbnN0IGVudHJ5OiBDYWNoZUVudHJ5PFQ+ID0ge1xuICAgICAgZGF0YSxcbiAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgIHZlcnNpb24sXG4gICAgICBleHBpcmVzQXQ6IERhdGUubm93KCkgKyB0dGwsXG4gICAgfTtcblxuICAgIHRoaXMuY2FjaGUuc2V0KGtleSwgZW50cnkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEludmFsaWRhdGUgc3BlY2lmaWMgY2FjaGUga2V5XG4gICAqL1xuICBpbnZhbGlkYXRlKGtleTogc3RyaW5nKTogdm9pZCB7XG4gICAgdGhpcy5jYWNoZS5kZWxldGUoa2V5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZhbGlkYXRlIGFsbCBrZXlzIG1hdGNoaW5nIGEgcGF0dGVyblxuICAgKi9cbiAgaW52YWxpZGF0ZVBhdHRlcm4ocGF0dGVybjogc3RyaW5nIHwgUmVnRXhwKTogdm9pZCB7XG4gICAgY29uc3QgcmVnZXggPSB0eXBlb2YgcGF0dGVybiA9PT0gJ3N0cmluZycgPyBuZXcgUmVnRXhwKHBhdHRlcm4pIDogcGF0dGVybjtcbiAgICBcbiAgICBmb3IgKGNvbnN0IGtleSBvZiB0aGlzLmNhY2hlLmtleXMoKSkge1xuICAgICAgaWYgKHJlZ2V4LnRlc3Qoa2V5KSkge1xuICAgICAgICB0aGlzLmNhY2hlLmRlbGV0ZShrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZhbGlkYXRlIGFsbCBjYWNoZSBlbnRyaWVzXG4gICAqL1xuICBpbnZhbGlkYXRlQWxsKCk6IHZvaWQge1xuICAgIHRoaXMuY2FjaGUuY2xlYXIoKTtcbiAgICB0aGlzLmN1cnJlbnRWZXJzaW9uKys7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGV4cGlyZWQgZW50cmllc1xuICAgKi9cbiAgY2xlYW51cCgpOiB2b2lkIHtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IGV4cGlyZWRLZXlzOiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBba2V5LCBlbnRyeV0gb2YgdGhpcy5jYWNoZS5lbnRyaWVzKCkpIHtcbiAgICAgIGlmIChub3cgPiBlbnRyeS5leHBpcmVzQXQgfHwgZW50cnkudmVyc2lvbiAhPT0gdGhpcy5jdXJyZW50VmVyc2lvbikge1xuICAgICAgICBleHBpcmVkS2V5cy5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZXhwaXJlZEtleXMuZm9yRWFjaChrZXkgPT4gdGhpcy5jYWNoZS5kZWxldGUoa2V5KSk7XG5cbiAgICBpZiAoZXhwaXJlZEtleXMubGVuZ3RoID4gMCkge1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgY2FjaGUgc3RhdGlzdGljc1xuICAgKi9cbiAgZ2V0U3RhdHMoKTogQ2FjaGVTdGF0cyB7XG4gICAgY29uc3QgdG90YWwgPSB0aGlzLnN0YXRzLmhpdHMgKyB0aGlzLnN0YXRzLm1pc3NlcztcbiAgICByZXR1cm4ge1xuICAgICAgaGl0czogdGhpcy5zdGF0cy5oaXRzLFxuICAgICAgbWlzc2VzOiB0aGlzLnN0YXRzLm1pc3NlcyxcbiAgICAgIHNpemU6IHRoaXMuY2FjaGUuc2l6ZSxcbiAgICAgIGhpdFJhdGU6IHRvdGFsID4gMCA/IHRoaXMuc3RhdHMuaGl0cyAvIHRvdGFsIDogMCxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0IHN0YXRpc3RpY3NcbiAgICovXG4gIHJlc2V0U3RhdHMoKTogdm9pZCB7XG4gICAgdGhpcy5zdGF0cyA9IHsgaGl0czogMCwgbWlzc2VzOiAwIH07XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXIgYWxsIGNhY2hlIGFuZCBzdGF0c1xuICAgKi9cbiAgY2xlYXIoKTogdm9pZCB7XG4gICAgdGhpcy5jYWNoZS5jbGVhcigpO1xuICAgIHRoaXMuc3RhdHMgPSB7IGhpdHM6IDAsIG1pc3NlczogMCB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBjYWNoZSBzaXplXG4gICAqL1xuICBnZXQgc2l6ZSgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmNhY2hlLnNpemU7XG4gIH1cbn1cblxuLy8gU2luZ2xldG9uIGluc3RhbmNlXG5leHBvcnQgY29uc3QgY2FjaGVNYW5hZ2VyID0gbmV3IENhY2hlTWFuYWdlcigpO1xuXG4vLyBDYWNoZSBrZXkgYnVpbGRlcnMgZm9yIGNvbnNpc3RlbmN5XG5leHBvcnQgY29uc3QgQ2FjaGVLZXlzID0ge1xuICBwcm9qZWN0czogKCkgPT4gJ3Byb2plY3RzOmFsbCcsXG4gIHByb2plY3Q6IChpZDogc3RyaW5nKSA9PiBgcHJvamVjdDoke2lkfWAsXG4gIHByb2plY3RUYXNrczogKHByb2plY3RJZDogc3RyaW5nKSA9PiBgdGFza3M6cHJvamVjdDoke3Byb2plY3RJZH1gLFxuICBwcm9qZWN0c0J5SWRzOiAoaWRzOiBzdHJpbmdbXSkgPT4gYHByb2plY3RzOmlkczoke2lkcy5zb3J0KCkuam9pbignLCcpfWAsXG4gIHRhc2tzOiAocHJvamVjdElkczogc3RyaW5nW10pID0+IGB0YXNrczpwcm9qZWN0czoke3Byb2plY3RJZHMuc29ydCgpLmpvaW4oJywnKX1gLFxuICB0YXNrc0J5SWRzOiAoaWRzOiBzdHJpbmdbXSkgPT4gYHRhc2tzOmlkczoke2lkcy5zb3J0KCkuam9pbignLCcpfWAsXG4gIHVzZXJzOiAoKSA9PiAndXNlcnM6YWxsJyxcbiAgdXNlcjogKGlkOiBzdHJpbmcpID0+IGB1c2VyOiR7aWR9YCxcbiAgcHJvamVjdFN0YXR1c2VzOiAocHJvamVjdElkOiBzdHJpbmcpID0+IGBzdGF0dXNlczpwcm9qZWN0OiR7cHJvamVjdElkfWAsXG59O1xuXG4vLyBDYWNoZSBUVEwgcHJlc2V0cyAoaW4gbWlsbGlzZWNvbmRzKVxuZXhwb3J0IGNvbnN0IENhY2hlVFRMID0ge1xuICBzaG9ydDogMzAgKiAxMDAwLCAvLyAzMCBzZWNvbmRzIC0gZm9yIGZyZXF1ZW50bHkgY2hhbmdpbmcgZGF0YVxuICBtZWRpdW06IDUgKiA2MCAqIDEwMDAsIC8vIDUgbWludXRlcyAtIGRlZmF1bHQgZm9yIG1vc3QgZGF0YVxuICBsb25nOiAxNSAqIDYwICogMTAwMCwgLy8gMTUgbWludXRlcyAtIGZvciByZWxhdGl2ZWx5IHN0YWJsZSBkYXRhXG4gIHZlcnlMb25nOiA2MCAqIDYwICogMTAwMCwgLy8gMSBob3VyIC0gZm9yIHZlcnkgc3RhYmxlIGRhdGFcbn07XG5cbi8qKlxuICogQ2FjaGVkIGZldGNoIHdyYXBwZXIgd2l0aCBzdGFsZS13aGlsZS1yZXZhbGlkYXRlIHN1cHBvcnRcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNhY2hlZEZldGNoPFQ+KFxuICBrZXk6IHN0cmluZyxcbiAgZmV0Y2hlcjogKCkgPT4gUHJvbWlzZTxUPixcbiAgb3B0aW9uczogQ2FjaGVPcHRpb25zID0ge31cbik6IFByb21pc2U8VD4ge1xuICBjb25zdCBjYWNoZWQgPSBjYWNoZU1hbmFnZXIuZ2V0PFQ+KGtleSk7XG5cbiAgLy8gRnJlc2ggY2FjaGUgaGl0XG4gIGlmIChjYWNoZWQgIT09IG51bGwgJiYgIWNhY2hlTWFuYWdlci5pc1N0YWxlKGtleSkpIHtcbiAgICByZXR1cm4gY2FjaGVkO1xuICB9XG5cbiAgLy8gU3RhbGUtd2hpbGUtcmV2YWxpZGF0ZTogcmV0dXJuIHN0YWxlIGRhdGEgYW5kIGZldGNoIGluIGJhY2tncm91bmRcbiAgaWYgKG9wdGlvbnMuc3RhbGVXaGlsZVJldmFsaWRhdGUgJiYgY2FjaGVkICE9PSBudWxsKSB7XG4gICAgLy8gUmV0dXJuIHN0YWxlIGRhdGEgaW1tZWRpYXRlbHlcbiAgICBjb25zdCBzdGFsZURhdGEgPSBjYWNoZWQ7XG4gICAgXG4gICAgLy8gRmV0Y2ggZnJlc2ggZGF0YSBpbiBiYWNrZ3JvdW5kXG4gICAgZmV0Y2hlcigpXG4gICAgICAudGhlbihmcmVzaERhdGEgPT4ge1xuICAgICAgICBjYWNoZU1hbmFnZXIuc2V0KGtleSwgZnJlc2hEYXRhLCBvcHRpb25zKTtcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgY29uc29sZS53YXJuKCdbQ2FjaGVdIEJhY2tncm91bmQgcmV2YWxpZGF0aW9uIGZhaWxlZDonLCBlcnIpO1xuICAgICAgfSk7XG5cbiAgICByZXR1cm4gc3RhbGVEYXRhO1xuICB9XG5cbiAgLy8gQ2FjaGUgbWlzcyBvciBleHBpcmVkOiBmZXRjaCBmcmVzaCBkYXRhXG4gIHRyeSB7XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IGZldGNoZXIoKTtcbiAgICBjYWNoZU1hbmFnZXIuc2V0KGtleSwgZGF0YSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgLy8gSWYgZmV0Y2ggZmFpbHMgYnV0IHdlIGhhdmUgc3RhbGUgZGF0YSwgcmV0dXJuIGl0IGFzIGZhbGxiYWNrXG4gICAgaWYgKGNhY2hlZCAhPT0gbnVsbCkge1xuICAgICAgY29uc29sZS53YXJuKCdbQ2FjaGVdIEZldGNoIGZhaWxlZCwgcmV0dXJuaW5nIHN0YWxlIGRhdGE6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICB9XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuLyoqXG4gKiBCYXRjaCBjYWNoZSBvcGVyYXRpb25zXG4gKi9cbmV4cG9ydCBjbGFzcyBCYXRjaENhY2hlT3BlcmF0aW9uIHtcbiAgcHJpdmF0ZSBvcGVyYXRpb25zOiBBcnJheTwoKSA9PiB2b2lkPiA9IFtdO1xuXG4gIGludmFsaWRhdGUoa2V5OiBzdHJpbmcpOiB0aGlzIHtcbiAgICB0aGlzLm9wZXJhdGlvbnMucHVzaCgoKSA9PiBjYWNoZU1hbmFnZXIuaW52YWxpZGF0ZShrZXkpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGludmFsaWRhdGVQYXR0ZXJuKHBhdHRlcm46IHN0cmluZyB8IFJlZ0V4cCk6IHRoaXMge1xuICAgIHRoaXMub3BlcmF0aW9ucy5wdXNoKCgpID0+IGNhY2hlTWFuYWdlci5pbnZhbGlkYXRlUGF0dGVybihwYXR0ZXJuKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzZXQ8VD4oa2V5OiBzdHJpbmcsIGRhdGE6IFQsIG9wdGlvbnM/OiBDYWNoZU9wdGlvbnMpOiB0aGlzIHtcbiAgICB0aGlzLm9wZXJhdGlvbnMucHVzaCgoKSA9PiBjYWNoZU1hbmFnZXIuc2V0KGtleSwgZGF0YSwgb3B0aW9ucykpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZXhlY3V0ZSgpOiB2b2lkIHtcbiAgICB0aGlzLm9wZXJhdGlvbnMuZm9yRWFjaChvcCA9PiBvcCgpKTtcbiAgICB0aGlzLm9wZXJhdGlvbnMgPSBbXTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYmF0Y2hDYWNoZSgpOiBCYXRjaENhY2hlT3BlcmF0aW9uIHtcbiAgcmV0dXJuIG5ldyBCYXRjaENhY2hlT3BlcmF0aW9uKCk7XG59XG4iXSwibmFtZXMiOlsiQ2FjaGVNYW5hZ2VyIiwiZ2V0Iiwia2V5IiwiZW50cnkiLCJjYWNoZSIsInN0YXRzIiwibWlzc2VzIiwiRGF0ZSIsIm5vdyIsImV4cGlyZXNBdCIsImRlbGV0ZSIsInZlcnNpb24iLCJjdXJyZW50VmVyc2lvbiIsImhpdHMiLCJkYXRhIiwiaGFzIiwiaXNTdGFsZSIsInNldCIsIm9wdGlvbnMiLCJzaXplIiwibWF4U2l6ZSIsImZpcnN0S2V5Iiwia2V5cyIsIm5leHQiLCJ2YWx1ZSIsInR0bCIsImRlZmF1bHRUVEwiLCJ0aW1lc3RhbXAiLCJpbnZhbGlkYXRlIiwiaW52YWxpZGF0ZVBhdHRlcm4iLCJwYXR0ZXJuIiwicmVnZXgiLCJSZWdFeHAiLCJ0ZXN0IiwiaW52YWxpZGF0ZUFsbCIsImNsZWFyIiwiY2xlYW51cCIsImV4cGlyZWRLZXlzIiwiZW50cmllcyIsInB1c2giLCJmb3JFYWNoIiwibGVuZ3RoIiwiZ2V0U3RhdHMiLCJ0b3RhbCIsImhpdFJhdGUiLCJyZXNldFN0YXRzIiwiTWFwIiwic2V0SW50ZXJ2YWwiLCJjYWNoZU1hbmFnZXIiLCJDYWNoZUtleXMiLCJwcm9qZWN0cyIsInByb2plY3QiLCJpZCIsInByb2plY3RUYXNrcyIsInByb2plY3RJZCIsInByb2plY3RzQnlJZHMiLCJpZHMiLCJzb3J0Iiwiam9pbiIsInRhc2tzIiwicHJvamVjdElkcyIsInRhc2tzQnlJZHMiLCJ1c2VycyIsInVzZXIiLCJwcm9qZWN0U3RhdHVzZXMiLCJDYWNoZVRUTCIsInNob3J0IiwibWVkaXVtIiwibG9uZyIsInZlcnlMb25nIiwiY2FjaGVkRmV0Y2giLCJmZXRjaGVyIiwiY2FjaGVkIiwic3RhbGVXaGlsZVJldmFsaWRhdGUiLCJzdGFsZURhdGEiLCJ0aGVuIiwiZnJlc2hEYXRhIiwiY2F0Y2giLCJlcnIiLCJjb25zb2xlIiwid2FybiIsImVycm9yIiwiQmF0Y2hDYWNoZU9wZXJhdGlvbiIsIm9wZXJhdGlvbnMiLCJleGVjdXRlIiwib3AiLCJiYXRjaENhY2hlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/cache.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/lib/cached-api.ts":
/*!*******************************!*\
  !*** ./src/lib/cached-api.ts ***!
  \*******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clearAllCaches: () => (/* binding */ clearAllCaches),\n/* harmony export */   getCacheStats: () => (/* binding */ getCacheStats),\n/* harmony export */   getCachedProject: () => (/* binding */ getCachedProject),\n/* harmony export */   getCachedProjectStatuses: () => (/* binding */ getCachedProjectStatuses),\n/* harmony export */   getCachedProjects: () => (/* binding */ getCachedProjects),\n/* harmony export */   getCachedTasksByProjectIds: () => (/* binding */ getCachedTasksByProjectIds),\n/* harmony export */   getCachedUsers: () => (/* binding */ getCachedUsers),\n/* harmony export */   invalidateAllProjectCaches: () => (/* binding */ invalidateAllProjectCaches),\n/* harmony export */   invalidateProjectCaches: () => (/* binding */ invalidateProjectCaches),\n/* harmony export */   invalidateTaskCaches: () => (/* binding */ invalidateTaskCaches),\n/* harmony export */   optimisticUpdateProject: () => (/* binding */ optimisticUpdateProject),\n/* harmony export */   optimisticUpdateTask: () => (/* binding */ optimisticUpdateTask),\n/* harmony export */   prefetchProjectData: () => (/* binding */ prefetchProjectData)\n/* harmony export */ });\n/* harmony import */ var _api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./api */ \"(app-pages-browser)/./src/lib/api.ts\");\n/* harmony import */ var _cache__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cache */ \"(app-pages-browser)/./src/lib/cache.ts\");\n/**\n * Cached API layer for OrchePlan\n * Wraps API calls with intelligent caching strategies\n */ \n\n/**\n * Get all projects with caching\n */ async function getCachedProjects() {\n    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    const key = _cache__WEBPACK_IMPORTED_MODULE_1__.CacheKeys.projects();\n    if (options.forceRefresh) {\n        _cache__WEBPACK_IMPORTED_MODULE_1__.cacheManager.invalidate(key);\n    }\n    var _options_staleWhileRevalidate;\n    return (0,_cache__WEBPACK_IMPORTED_MODULE_1__.cachedFetch)(key, ()=>(0,_api__WEBPACK_IMPORTED_MODULE_0__.getProjects)(), {\n        ttl: _cache__WEBPACK_IMPORTED_MODULE_1__.CacheTTL.medium,\n        staleWhileRevalidate: (_options_staleWhileRevalidate = options.staleWhileRevalidate) !== null && _options_staleWhileRevalidate !== void 0 ? _options_staleWhileRevalidate : true\n    });\n}\n/**\n * Get single project with caching\n */ async function getCachedProject(projectId) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const key = _cache__WEBPACK_IMPORTED_MODULE_1__.CacheKeys.project(projectId);\n    if (options.forceRefresh) {\n        _cache__WEBPACK_IMPORTED_MODULE_1__.cacheManager.invalidate(key);\n    }\n    var _options_staleWhileRevalidate;\n    return (0,_cache__WEBPACK_IMPORTED_MODULE_1__.cachedFetch)(key, ()=>(0,_api__WEBPACK_IMPORTED_MODULE_0__.getProject)(projectId), {\n        ttl: _cache__WEBPACK_IMPORTED_MODULE_1__.CacheTTL.medium,\n        staleWhileRevalidate: (_options_staleWhileRevalidate = options.staleWhileRevalidate) !== null && _options_staleWhileRevalidate !== void 0 ? _options_staleWhileRevalidate : true\n    });\n}\n/**\n * Get users with caching\n */ async function getCachedUsers() {\n    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    const key = _cache__WEBPACK_IMPORTED_MODULE_1__.CacheKeys.users();\n    if (options.forceRefresh) {\n        _cache__WEBPACK_IMPORTED_MODULE_1__.cacheManager.invalidate(key);\n    }\n    var _options_staleWhileRevalidate;\n    return (0,_cache__WEBPACK_IMPORTED_MODULE_1__.cachedFetch)(key, ()=>(0,_api__WEBPACK_IMPORTED_MODULE_0__.getUsers)(), {\n        ttl: _cache__WEBPACK_IMPORTED_MODULE_1__.CacheTTL.long,\n        staleWhileRevalidate: (_options_staleWhileRevalidate = options.staleWhileRevalidate) !== null && _options_staleWhileRevalidate !== void 0 ? _options_staleWhileRevalidate : true\n    });\n}\n/**\n * Get tasks by project IDs with caching\n */ async function getCachedTasksByProjectIds(projectIds) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const key = _cache__WEBPACK_IMPORTED_MODULE_1__.CacheKeys.tasks(projectIds);\n    if (options.forceRefresh) {\n        _cache__WEBPACK_IMPORTED_MODULE_1__.cacheManager.invalidate(key);\n    }\n    var _options_staleWhileRevalidate;\n    return (0,_cache__WEBPACK_IMPORTED_MODULE_1__.cachedFetch)(key, ()=>(0,_api__WEBPACK_IMPORTED_MODULE_0__.getTasksByProjectIds)(projectIds), {\n        ttl: _cache__WEBPACK_IMPORTED_MODULE_1__.CacheTTL.short,\n        staleWhileRevalidate: (_options_staleWhileRevalidate = options.staleWhileRevalidate) !== null && _options_staleWhileRevalidate !== void 0 ? _options_staleWhileRevalidate : true\n    });\n}\n/**\n * Get project statuses with caching\n */ async function getCachedProjectStatuses(projectId) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const key = _cache__WEBPACK_IMPORTED_MODULE_1__.CacheKeys.projectStatuses(projectId);\n    if (options.forceRefresh) {\n        _cache__WEBPACK_IMPORTED_MODULE_1__.cacheManager.invalidate(key);\n    }\n    return (0,_cache__WEBPACK_IMPORTED_MODULE_1__.cachedFetch)(key, ()=>(0,_api__WEBPACK_IMPORTED_MODULE_0__.getProjectStatuses)(projectId), {\n        ttl: _cache__WEBPACK_IMPORTED_MODULE_1__.CacheTTL.long\n    });\n}\n/**\n * Invalidate caches related to a project\n */ function invalidateProjectCaches(projectId) {\n    (0,_cache__WEBPACK_IMPORTED_MODULE_1__.batchCache)().invalidate(_cache__WEBPACK_IMPORTED_MODULE_1__.CacheKeys.project(projectId)).invalidate(_cache__WEBPACK_IMPORTED_MODULE_1__.CacheKeys.projectStatuses(projectId)).invalidatePattern(new RegExp(\"^tasks:project:\".concat(projectId, \"$\"))).invalidatePattern(new RegExp(\"^tasks:projects:.*\".concat(projectId, \".*\"))).invalidate(_cache__WEBPACK_IMPORTED_MODULE_1__.CacheKeys.projects()) // Projects list might include this project\n    .execute();\n}\n/**\n * Invalidate caches related to a task\n */ function invalidateTaskCaches(task) {\n    (0,_cache__WEBPACK_IMPORTED_MODULE_1__.batchCache)().invalidatePattern(new RegExp(\"^tasks:project:\".concat(task.projectId, \"$\"))).invalidatePattern(new RegExp(\"^tasks:projects:.*\".concat(task.projectId, \".*\"))).execute();\n}\n/**\n * Invalidate all project-related caches\n */ function invalidateAllProjectCaches() {\n    (0,_cache__WEBPACK_IMPORTED_MODULE_1__.batchCache)().invalidatePattern(/^project:/).invalidatePattern(/^projects:/).invalidatePattern(/^tasks:/).invalidatePattern(/^statuses:/).execute();\n}\n/**\n * Optimistic cache update for task\n * Updates cache immediately before server confirmation\n */ function optimisticUpdateTask(updatedTask) {\n    // Update any cached task lists that contain this task\n    const projectId = updatedTask.projectId;\n    // Try to update cached task lists\n    const patterns = [\n        _cache__WEBPACK_IMPORTED_MODULE_1__.CacheKeys.projectTasks(projectId),\n        new RegExp(\"^tasks:projects:.*\".concat(projectId, \".*\"))\n    ];\n    patterns.forEach((pattern)=>{\n        if (typeof pattern === 'string') {\n            const cached = _cache__WEBPACK_IMPORTED_MODULE_1__.cacheManager.get(pattern);\n            if (cached) {\n                const updated = cached.map((t)=>t.id === updatedTask.id ? updatedTask : t);\n                _cache__WEBPACK_IMPORTED_MODULE_1__.cacheManager.set(pattern, updated, {\n                    ttl: _cache__WEBPACK_IMPORTED_MODULE_1__.CacheTTL.short\n                });\n            }\n        } else {\n            // For regex patterns, we need to iterate through cache keys\n            // This is less efficient but necessary for pattern matching\n            const cacheKeys = Array.from(_cache__WEBPACK_IMPORTED_MODULE_1__.cacheManager.cache.keys());\n            for (const key of cacheKeys){\n                if (pattern.test(key)) {\n                    const cached = _cache__WEBPACK_IMPORTED_MODULE_1__.cacheManager.get(key);\n                    if (cached) {\n                        const updated = cached.map((t)=>t.id === updatedTask.id ? updatedTask : t);\n                        _cache__WEBPACK_IMPORTED_MODULE_1__.cacheManager.set(key, updated, {\n                            ttl: _cache__WEBPACK_IMPORTED_MODULE_1__.CacheTTL.short\n                        });\n                    }\n                }\n            }\n        }\n    });\n}\n/**\n * Optimistic cache update for project\n */ function optimisticUpdateProject(updatedProject) {\n    // Update single project cache\n    const key = _cache__WEBPACK_IMPORTED_MODULE_1__.CacheKeys.project(updatedProject.id);\n    _cache__WEBPACK_IMPORTED_MODULE_1__.cacheManager.set(key, updatedProject, {\n        ttl: _cache__WEBPACK_IMPORTED_MODULE_1__.CacheTTL.medium\n    });\n    // Update projects list cache if it exists\n    const projectsKey = _cache__WEBPACK_IMPORTED_MODULE_1__.CacheKeys.projects();\n    const cachedProjects = _cache__WEBPACK_IMPORTED_MODULE_1__.cacheManager.get(projectsKey);\n    if (cachedProjects) {\n        const updateProjectInList = (projects)=>{\n            return projects.map((p)=>{\n                if (p.id === updatedProject.id) {\n                    return {\n                        ...updatedProject,\n                        subProjects: p.subProjects\n                    };\n                }\n                if (p.subProjects && p.subProjects.length > 0) {\n                    return {\n                        ...p,\n                        subProjects: updateProjectInList(p.subProjects)\n                    };\n                }\n                return p;\n            });\n        };\n        const updated = updateProjectInList(cachedProjects);\n        _cache__WEBPACK_IMPORTED_MODULE_1__.cacheManager.set(projectsKey, updated, {\n            ttl: _cache__WEBPACK_IMPORTED_MODULE_1__.CacheTTL.medium\n        });\n    }\n}\n/**\n * Prefetch data for better UX\n */ async function prefetchProjectData(projectId) {\n    // Prefetch in parallel without blocking\n    Promise.all([\n        getCachedProject(projectId, {\n            staleWhileRevalidate: true\n        }),\n        getCachedProjectStatuses(projectId)\n    ]).catch((err)=>{\n        console.warn('[Cache] Prefetch failed:', err);\n    });\n}\n/**\n * Get cache statistics for debugging\n */ function getCacheStats() {\n    return _cache__WEBPACK_IMPORTED_MODULE_1__.cacheManager.getStats();\n}\n/**\n * Clear all caches (useful for logout or manual refresh)\n */ function clearAllCaches() {\n    _cache__WEBPACK_IMPORTED_MODULE_1__.cacheManager.clear();\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvY2FjaGVkLWFwaS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7O0NBR0MsR0FRYztBQU9FO0FBR2pCOztDQUVDLEdBQ00sZUFBZWU7UUFBa0JDLFVBQUFBLGlFQUdwQyxDQUFDO0lBQ0gsTUFBTUMsTUFBTU4sNkNBQVNBLENBQUNPLFFBQVE7SUFFOUIsSUFBSUYsUUFBUUcsWUFBWSxFQUFFO1FBQ3hCVCxnREFBWUEsQ0FBQ1UsVUFBVSxDQUFDSDtJQUMxQjtRQU8wQkQ7SUFMMUIsT0FBT0gsbURBQVdBLENBQ2hCSSxLQUNBLElBQU1oQixpREFBY0EsSUFDcEI7UUFDRW9CLEtBQUtULDRDQUFRQSxDQUFDVSxNQUFNO1FBQ3BCQyxzQkFBc0JQLENBQUFBLGdDQUFBQSxRQUFRTyxvQkFBb0IsY0FBNUJQLDJDQUFBQSxnQ0FBZ0M7SUFDeEQ7QUFFSjtBQUVBOztDQUVDLEdBQ00sZUFBZVEsaUJBQ3BCQyxTQUFpQjtRQUNqQlQsVUFBQUEsaUVBQXNFLENBQUM7SUFFdkUsTUFBTUMsTUFBTU4sNkNBQVNBLENBQUNlLE9BQU8sQ0FBQ0Q7SUFFOUIsSUFBSVQsUUFBUUcsWUFBWSxFQUFFO1FBQ3hCVCxnREFBWUEsQ0FBQ1UsVUFBVSxDQUFDSDtJQUMxQjtRQU8wQkQ7SUFMMUIsT0FBT0gsbURBQVdBLENBQ2hCSSxLQUNBLElBQU1kLGdEQUFhQSxDQUFDc0IsWUFDcEI7UUFDRUosS0FBS1QsNENBQVFBLENBQUNVLE1BQU07UUFDcEJDLHNCQUFzQlAsQ0FBQUEsZ0NBQUFBLFFBQVFPLG9CQUFvQixjQUE1QlAsMkNBQUFBLGdDQUFnQztJQUN4RDtBQUVKO0FBRUE7O0NBRUMsR0FDTSxlQUFlVztRQUFlWCxVQUFBQSxpRUFHakMsQ0FBQztJQUNILE1BQU1DLE1BQU1OLDZDQUFTQSxDQUFDaUIsS0FBSztJQUUzQixJQUFJWixRQUFRRyxZQUFZLEVBQUU7UUFDeEJULGdEQUFZQSxDQUFDVSxVQUFVLENB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UyxlQUFlVCxFQUFFLEVBQUU7b0JBQzlCLE9BQU87d0JBQUUsR0FBR1MsY0FBYzt3QkFBRUssYUFBYUQsRUFBRUMsV0FBVztvQkFBQztnQkFDekQ7Z0JBQ0EsSUFBSUQsRUFBRUMsV0FBVyxJQUFJRCxFQUFFQyxXQUFXLENBQUNDLE1BQU0sR0FBRyxHQUFHO29CQUM3QyxPQUFPO3dCQUFFLEdBQUdGLENBQUM7d0JBQUVDLGFBQWFGLG9CQUFvQkMsRUFBRUMsV0FBVztvQkFBRTtnQkFDakU7Z0JBQ0EsT0FBT0Q7WUFDVDtRQUNGO1FBRUEsTUFBTWhCLFVBQVVlLG9CQUFvQkQ7UUFDcEN2RCxnREFBWUEsQ0FBQzZDLEdBQUcsQ0FBQ1MsYUFBYWIsU0FBUztZQUFFOUIsS0FBS1QsNENBQVFBLENBQUNVLE1BQU07UUFBQztJQUNoRTtBQUNGO0FBRUE7O0NBRUMsR0FDTSxlQUFlZ0Qsb0JBQW9CN0MsU0FBaUI7SUFDekQsd0NBQXdDO0lBQ3hDOEMsUUFBUUMsR0FBRyxDQUFDO1FBQ1ZoRCxpQkFBaUJDLFdBQVc7WUFBRUYsc0JBQXNCO1FBQUs7UUFDekRXLHlCQUF5QlQ7S0FDMUIsRUFBRWdELEtBQUssQ0FBQ0MsQ0FBQUE7UUFDUEMsUUFBUUMsSUFBSSxDQUFDLDRCQUE0QkY7SUFDM0M7QUFDRjtBQUVBOztDQUVDLEdBQ00sU0FBU0c7SUFDZCxPQUFPbkUsZ0RBQVlBLENBQUNvRSxRQUFRO0FBQzlCO0FBRUE7O0NBRUMsR0FDTSxTQUFTQztJQUNkckUsZ0RBQVlBLENBQUNzRSxLQUFLO0FBQ3BCIiwic291cmNlcyI6WyIvaG9tZS9jb2Rlci9PcmNoZVBsYW4vZnJvbnRlbmQvc3JjL2xpYi9jYWNoZWQtYXBpLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ2FjaGVkIEFQSSBsYXllciBmb3IgT3JjaGVQbGFuXG4gKiBXcmFwcyBBUEkgY2FsbHMgd2l0aCBpbnRlbGxpZ2VudCBjYWNoaW5nIHN0cmF0ZWdpZXNcbiAqL1xuXG5pbXBvcnQge1xuICBnZXRQcm9qZWN0cyBhcyBhcGlHZXRQcm9qZWN0cyxcbiAgZ2V0UHJvamVjdCBhcyBhcGlHZXRQcm9qZWN0LFxuICBnZXRVc2VycyBhcyBhcGlHZXRVc2VycyxcbiAgZ2V0VGFza3NCeVByb2plY3RJZHMgYXMgYXBpR2V0VGFza3NCeVByb2plY3RJZHMsXG4gIGdldFByb2plY3RTdGF0dXNlcyBhcyBhcGlHZXRQcm9qZWN0U3RhdHVzZXMsXG59IGZyb20gJy4vYXBpJztcbmltcG9ydCB7XG4gIGNhY2hlTWFuYWdlcixcbiAgQ2FjaGVLZXlzLFxuICBDYWNoZVRUTCxcbiAgY2FjaGVkRmV0Y2gsXG4gIGJhdGNoQ2FjaGUsXG59IGZyb20gJy4vY2FjaGUnO1xuaW1wb3J0IHR5cGUgeyBQcm9qZWN0LCBVc2VyLCBUYXNrLCBUYXNrU3RhdHVzT3B0aW9uIH0gZnJvbSAnLi90eXBlcyc7XG5cbi8qKlxuICogR2V0IGFsbCBwcm9qZWN0cyB3aXRoIGNhY2hpbmdcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldENhY2hlZFByb2plY3RzKG9wdGlvbnM6IHtcbiAgZm9yY2VSZWZyZXNoPzogYm9vbGVhbjtcbiAgc3RhbGVXaGlsZVJldmFsaWRhdGU/OiBib29sZWFuO1xufSA9IHt9KTogUHJvbWlzZTxQcm9qZWN0W10+IHtcbiAgY29uc3Qga2V5ID0gQ2FjaGVLZXlzLnByb2plY3RzKCk7XG5cbiAgaWYgKG9wdGlvbnMuZm9yY2VSZWZyZXNoKSB7XG4gICAgY2FjaGVNYW5hZ2VyLmludmFsaWRhdGUoa2V5KTtcbiAgfVxuXG4gIHJldHVybiBjYWNoZWRGZXRjaChcbiAgICBrZXksXG4gICAgKCkgPT4gYXBpR2V0UHJvamVjdHMoKSxcbiAgICB7XG4gICAgICB0dGw6IENhY2hlVFRMLm1lZGl1bSxcbiAgICAgIHN0YWxlV2hpbGVSZXZhbGlkYXRlOiBvcHRpb25zLnN0YWxlV2hpbGVSZXZhbGlkYXRlID8/IHRydWUsXG4gICAgfVxuICApO1xufVxuXG4vKipcbiAqIEdldCBzaW5nbGUgcHJvamVjdCB3aXRoIGNhY2hpbmdcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldENhY2hlZFByb2plY3QoXG4gIHByb2plY3RJZDogc3RyaW5nLFxuICBvcHRpb25zOiB7IGZvcmNlUmVmcmVzaD86IGJvb2xlYW47IHN0YWxlV2hpbGVSZXZhbGlkYXRlPzogYm9vbGVhbiB9ID0ge31cbik6IFByb21pc2U8UHJvamVjdCB8IG51bGw+IHtcbiAgY29uc3Qga2V5ID0gQ2FjaGVLZXlzLnByb2plY3QocHJvamVjdElkKTtcblxuICBpZiAob3B0aW9ucy5mb3JjZVJlZnJlc2gpIHtcbiAgICBjYWNoZU1hbmFnZXIuaW52YWxpZGF0ZShrZXkpO1xuICB9XG5cbiAgcmV0dXJuIGNhY2hlZEZldGNoKFxuICAgIGtleSxcbiAgICAoKSA9PiBhcGlHZXRQcm9qZWN0KHByb2plY3RJZCksXG4gICAge1xuICAgICAgdHRsOiBDYWNoZVRUTC5tZWRpdW0sXG4gICAgICBzdGFsZVdoaWxlUmV2YWxpZGF0ZTogb3B0aW9ucy5zdGFsZVdoaWxlUmV2YWxpZGF0ZSA/PyB0cnVlLFxuICAgIH1cbiAgKTtcbn1cblxuLyoqXG4gKiBHZXQgdXNlcnMgd2l0aCBjYWNoaW5nXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDYWNoZWRVc2VycyhvcHRpb25zOiB7XG4gIGZvcmNlUmVmcmVzaD86IGJvb2xlYW47XG4gIHN0YWxlV2hpbGVSZXZhbGlkYXRlPzogYm9vbGVhbjtcbn0gPSB7fSk6IFByb21pc2U8VXNlcltdPiB7XG4gIGNvbnN0IGtleSA9IENhY2hlS2V5cy51c2VycygpO1xuXG4gIGlmIChvcHRpb25zLmZvcmNlUmVmcmVzaCkge1xuICAgIGNhY2hlTWFuYWdlci5pbnZhbGlkYXRlKGtleSk7XG4gIH1cblxuICByZXR1cm4gY2FjaGVkRmV0Y2goXG4gICAga2V5LFxuICAgICgpID0+IGFwaUdldFVzZXJzKCksXG4gICAge1xuICAgICAgdHRsOiBDYWNoZVRUTC5sb25nLCAvLyBVc2VycyBjaGFuZ2UgbGVzcyBmcmVxdWVudGx5XG4gICAgICBzdGFsZVdoaWxlUmV2YWxpZGF0ZTogb3B0aW9ucy5zdGFsZVdoaWxlUmV2YWxpZGF0ZSA/PyB0cnVlLFxuICAgIH1cbiAgKTtcbn1cblxuLyoqXG4gKiBHZXQgdGFza3MgYnkgcHJvamVjdCBJRHMgd2l0aCBjYWNoaW5nXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDYWNoZWRUYXNrc0J5UHJvamVjdElkcyhcbiAgcHJvamVjdElkczogc3RyaW5nW10sXG4gIG9wdGlvbnM6IHsgZm9yY2VSZWZyZXNoPzogYm9vbGVhbjsgc3RhbGVXaGlsZVJldmFsaWRhdGU/OiBib29sZWFuIH0gPSB7fVxuKTogUHJvbWlzZTxUYXNrW10+IHtcbiAgY29uc3Qga2V5ID0gQ2FjaGVLZXlzLnRhc2tzKHByb2plY3RJZHMpO1xuXG4gIGlmIChvcHRpb25zLmZvcmNlUmVmcmVzaCkge1xuICAgIGNhY2hlTWFuYWdlci5pbnZhbGlkYXRlKGtleSk7XG4gIH1cblxuICByZXR1cm4gY2FjaGVkRmV0Y2goXG4gICAga2V5LFxuICAgICgpID0+IGFwaUdldFRhc2tzQnlQcm9qZWN0SWRzKHByb2plY3RJZHMpLFxuICAgIHtcbiAgICAgIHR0bDogQ2FjaGVUVEwuc2hvcnQsIC8vIFRhc2tzIGNoYW5nZSBmcmVxdWVudGx5XG4gICAgICBzdGFsZVdoaWxlUmV2YWxpZGF0ZTogb3B0aW9ucy5zdGFsZVdoaWxlUmV2YWxpZGF0ZSA/PyB0cnVlLFxuICAgIH1cbiAgKTtcbn1cblxuLyoqXG4gKiBHZXQgcHJvamVjdCBzdGF0dXNlcyB3aXRoIGNhY2hpbmdcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldENhY2hlZFByb2plY3RTdGF0dXNlcyhcbiAgcHJvamVjdElkOiBzdHJpbmcsXG4gIG9wdGlvbnM6IHsgZm9yY2VSZWZyZXNoPzogYm9vbGVhbiB9ID0ge31cbik6IFByb21pc2U8VGFza1N0YXR1c09wdGlvbltdPiB7XG4gIGNvbnN0IGtleSA9IENhY2hlS2V5cy5wcm9qZWN0U3RhdHVzZXMocHJvamVjdElkKTtcblxuICBpZiAob3B0aW9ucy5mb3JjZVJlZnJlc2gpIHtcbiAgICBjYWNoZU1hbmFnZXIuaW52YWxpZGF0ZShrZXkpO1xuICB9XG5cbiAgcmV0dXJuIGNhY2hlZEZldGNoKFxuICAgIGtleSxcbiAgICAoKSA9PiBhcGlHZXRQcm9qZWN0U3RhdHVzZXMocHJvamVjdElkKSxcbiAgICB7XG4gICAgICB0dGw6IENhY2hlVFRMLmxvbmcsIC8vIFN0YXR1c2VzIGNoYW5nZSBpbmZyZXF1ZW50bHlcbiAgICB9XG4gICk7XG59XG5cbi8qKlxuICogSW52YWxpZGF0ZSBjYWNoZXMgcmVsYXRlZCB0byBhIHByb2plY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludmFsaWRhdGVQcm9qZWN0Q2FjaGVzKHByb2plY3RJZDogc3RyaW5nKTogdm9pZCB7XG4gIGJhdGNoQ2FjaGUoKVxuICAgIC5pbnZhbGlkYXRlKENhY2hlS2V5cy5wcm9qZWN0KHByb2plY3RJZCkpXG4gICAgLmludmFsaWRhdGUoQ2FjaGVLZXlzLnByb2plY3RTdGF0dXNlcyhwcm9qZWN0SWQpKVxuICAgIC5pbnZhbGlkYXRlUGF0dGVybihuZXcgUmVnRXhwKGBedGFza3M6cHJvamVjdDoke3Byb2plY3RJZH0kYCkpXG4gICAgLmludmFsaWRhdGVQYXR0ZXJuKG5ldyBSZWdFeHAoYF50YXNrczpwcm9qZWN0czouKiR7cHJvamVjdElkfS4qYCkpXG4gICAgLmludmFsaWRhdGUoQ2FjaGVLZXlzLnByb2plY3RzKCkpIC8vIFByb2plY3RzIGxpc3QgbWlnaHQgaW5jbHVkZSB0aGlzIHByb2plY3RcbiAgICAuZXhlY3V0ZSgpO1xufVxuXG4vKipcbiAqIEludmFsaWRhdGUgY2FjaGVzIHJlbGF0ZWQgdG8gYSB0YXNrXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZhbGlkYXRlVGFza0NhY2hlcyh0YXNrOiBUYXNrKTogdm9pZCB7XG4gIGJhdGNoQ2FjaGUoKVxuICAgIC5pbnZhbGlkYXRlUGF0dGVybihuZXcgUmVnRXhwKGBedGFza3M6cHJvamVjdDoke3Rhc2sucHJvamVjdElkfSRgKSlcbiAgICAuaW52YWxpZGF0ZVBhdHRlcm4obmV3IFJlZ0V4cChgXnRhc2tzOnByb2plY3RzOi4qJHt0YXNrLnByb2plY3RJZH0uKmApKVxuICAgIC5leGVjdXRlKCk7XG59XG5cbi8qKlxuICogSW52YWxpZGF0ZSBhbGwgcHJvamVjdC1yZWxhdGVkIGNhY2hlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gaW52YWxpZGF0ZUFsbFByb2plY3RDYWNoZXMoKTogdm9pZCB7XG4gIGJhdGNoQ2FjaGUoKVxuICAgIC5pbnZhbGlkYXRlUGF0dGVybigvXnByb2plY3Q6LylcbiAgICAuaW52YWxpZGF0ZVBhdHRlcm4oL15wcm9qZWN0czovKVxuICAgIC5pbnZhbGlkYXRlUGF0dGVybigvXnRhc2tzOi8pXG4gICAgLmludmFsaWRhdGVQYXR0ZXJuKC9ec3RhdHVzZXM6LylcbiAgICAuZXhlY3V0ZSgpO1xufVxuXG4vKipcbiAqIE9wdGltaXN0aWMgY2FjaGUgdXBkYXRlIGZvciB0YXNrXG4gKiBVcGRhdGVzIGNhY2hlIGltbWVkaWF0ZWx5IGJlZm9yZSBzZXJ2ZXIgY29uZmlybWF0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvcHRpbWlzdGljVXBkYXRlVGFzayh1cGRhdGVkVGFzazogVGFzayk6IHZvaWQge1xuICAvLyBVcGRhdGUgYW55IGNhY2hlZCB0YXNrIGxpc3RzIHRoYXQgY29udGFpbiB0aGlzIHRhc2tcbiAgY29uc3QgcHJvamVjdElkID0gdXBkYXRlZFRhc2sucHJvamVjdElkO1xuICBcbiAgLy8gVHJ5IHRvIHVwZGF0ZSBjYWNoZWQgdGFzayBsaXN0c1xuICBjb25zdCBwYXR0ZXJucyA9IFtcbiAgICBDYWNoZUtleXMucHJvamVjdFRhc2tzKHByb2plY3RJZCksXG4gICAgbmV3IFJlZ0V4cChgXnRhc2tzOnByb2plY3RzOi4qJHtwcm9qZWN0SWR9LipgKSxcbiAgXTtcblxuICBwYXR0ZXJucy5mb3JFYWNoKHBhdHRlcm4gPT4ge1xuICAgIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlTWFuYWdlci5nZXQ8VGFza1tdPihwYXR0ZXJuKTtcbiAgICAgIGlmIChjYWNoZWQpIHtcbiAgICAgICAgY29uc3QgdXBkYXRlZCA9IGNhY2hlZC5tYXAodCA9PiB0LmlkID09PSB1cGRhdGVkVGFzay5pZCA/IHVwZGF0ZWRUYXNrIDogdCk7XG4gICAgICAgIGNhY2hlTWFuYWdlci5zZXQocGF0dGVybiwgdXBkYXRlZCwgeyB0dGw6IENhY2hlVFRMLnNob3J0IH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGb3IgcmVnZXggcGF0dGVybnMsIHdlIG5lZWQgdG8gaXRlcmF0ZSB0aHJvdWdoIGNhY2hlIGtleXNcbiAgICAgIC8vIFRoaXMgaXMgbGVzcyBlZmZpY2llbnQgYnV0IG5lY2Vzc2FyeSBmb3IgcGF0dGVybiBtYXRjaGluZ1xuICAgICAgY29uc3QgY2FjaGVLZXlzID0gQXJyYXkuZnJvbSgoY2FjaGVNYW5hZ2VyIGFzIGFueSkuY2FjaGUua2V5cygpKSBhcyBzdHJpbmdbXTtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIGNhY2hlS2V5cykge1xuICAgICAgICBpZiAocGF0dGVybi50ZXN0KGtleSkpIHtcbiAgICAgICAgICBjb25zdCBjYWNoZWQgPSBjYWNoZU1hbmFnZXIuZ2V0PFRhc2tbXT4oa2V5KTtcbiAgICAgICAgICBpZiAoY2FjaGVkKSB7XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkID0gY2FjaGVkLm1hcCh0ID0+IHQuaWQgPT09IHVwZGF0ZWRUYXNrLmlkID8gdXBkYXRlZFRhc2sgOiB0KTtcbiAgICAgICAgICAgIGNhY2hlTWFuYWdlci5zZXQoa2V5LCB1cGRhdGVkLCB7IHR0bDogQ2FjaGVUVEwuc2hvcnQgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBPcHRpbWlzdGljIGNhY2hlIHVwZGF0ZSBmb3IgcHJvamVjdFxuICovXG5leHBvcnQgZnVuY3Rpb24gb3B0aW1pc3RpY1VwZGF0ZVByb2plY3QodXBkYXRlZFByb2plY3Q6IFByb2plY3QpOiB2b2lkIHtcbiAgLy8gVXBkYXRlIHNpbmdsZSBwcm9qZWN0IGNhY2hlXG4gIGNvbnN0IGtleSA9IENhY2hlS2V5cy5wcm9qZWN0KHVwZGF0ZWRQcm9qZWN0LmlkKTtcbiAgY2FjaGVNYW5hZ2VyLnNldChrZXksIHVwZGF0ZWRQcm9qZWN0LCB7IHR0bDogQ2FjaGVUVEwubWVkaXVtIH0pO1xuXG4gIC8vIFVwZGF0ZSBwcm9qZWN0cyBsaXN0IGNhY2hlIGlmIGl0IGV4aXN0c1xuICBjb25zdCBwcm9qZWN0c0tleSA9IENhY2hlS2V5cy5wcm9qZWN0cygpO1xuICBjb25zdCBjYWNoZWRQcm9qZWN0cyA9IGNhY2hlTWFuYWdlci5nZXQ8UHJvamVjdFtdPihwcm9qZWN0c0tleSk7XG4gIGlmIChjYWNoZWRQcm9qZWN0cykge1xuICAgIGNvbnN0IHVwZGF0ZVByb2plY3RJbkxpc3QgPSAocHJvamVjdHM6IFByb2plY3RbXSk6IFByb2plY3RbXSA9PiB7XG4gICAgICByZXR1cm4gcHJvamVjdHMubWFwKHAgPT4ge1xuICAgICAgICBpZiAocC5pZCA9PT0gdXBkYXRlZFByb2plY3QuaWQpIHtcbiAgICAgICAgICByZXR1cm4geyAuLi51cGRhdGVkUHJvamVjdCwgc3ViUHJvamVjdHM6IHAuc3ViUHJvamVjdHMgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocC5zdWJQcm9qZWN0cyAmJiBwLnN1YlByb2plY3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICByZXR1cm4geyAuLi5wLCBzdWJQcm9qZWN0czogdXBkYXRlUHJvamVjdEluTGlzdChwLnN1YlByb2plY3RzKSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGNvbnN0IHVwZGF0ZWQgPSB1cGRhdGVQcm9qZWN0SW5MaXN0KGNhY2hlZFByb2plY3RzKTtcbiAgICBjYWNoZU1hbmFnZXIuc2V0KHByb2plY3RzS2V5LCB1cGRhdGVkLCB7IHR0bDogQ2FjaGVUVEwubWVkaXVtIH0pO1xuICB9XG59XG5cbi8qKlxuICogUHJlZmV0Y2ggZGF0YSBmb3IgYmV0dGVyIFVYXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcmVmZXRjaFByb2plY3REYXRhKHByb2plY3RJZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gIC8vIFByZWZldGNoIGluIHBhcmFsbGVsIHdpdGhvdXQgYmxvY2tpbmdcbiAgUHJvbWlzZS5hbGwoW1xuICAgIGdldENhY2hlZFByb2plY3QocHJvamVjdElkLCB7IHN0YWxlV2hpbGVSZXZhbGlkYXRlOiB0cnVlIH0pLFxuICAgIGdldENhY2hlZFByb2plY3RTdGF0dXNlcyhwcm9qZWN0SWQpLFxuICBdKS5jYXRjaChlcnIgPT4ge1xuICAgIGNvbnNvbGUud2FybignW0NhY2hlXSBQcmVmZXRjaCBmYWlsZWQ6JywgZXJyKTtcbiAgfSk7XG59XG5cbi8qKlxuICogR2V0IGNhY2hlIHN0YXRpc3RpY3MgZm9yIGRlYnVnZ2luZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2FjaGVTdGF0cygpIHtcbiAgcmV0dXJuIGNhY2hlTWFuYWdlci5nZXRTdGF0cygpO1xufVxuXG4vKipcbiAqIENsZWFyIGFsbCBjYWNoZXMgKHVzZWZ1bCBmb3IgbG9nb3V0IG9yIG1hbnVhbCByZWZyZXNoKVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xlYXJBbGxDYWNoZXMoKTogdm9pZCB7XG4gIGNhY2hlTWFuYWdlci5jbGVhcigpO1xufVxuIl0sIm5hbWVzIjpbImdldFByb2plY3RzIiwiYXBpR2V0UHJvamVjdHMiLCJnZXRQcm9qZWN0IiwiYXBpR2V0UHJvamVjdCIsImdldFVzZXJzIiwiYXBpR2V0VXNlcnMiLCJnZXRUYXNrc0J5UHJvamVjdElkcyIsImFwaUdldFRhc2tzQnlQcm9qZWN0SWRzIiwiZ2V0UHJvamVjdFN0YXR1c2VzIiwiYXBpR2V0UHJvamVjdFN0YXR1c2VzIiwiY2FjaGVNYW5hZ2VyIiwiQ2FjaGVLZXlzIiwiQ2FjaGVUVEwiLCJjYWNoZWRGZXRjaCIsImJhdGNoQ2FjaGUiLCJnZXRDYWNoZWRQcm9qZWN0cyIsIm9wdGlvbnMiLCJrZXkiLCJwcm9qZWN0cyIsImZvcmNlUmVmcmVzaCIsImludmFsaWRhdGUiLCJ0dGwiLCJtZWRpdW0iLCJzdGFsZVdoaWxlUmV2YWxpZGF0ZSIsImdldENhY2hlZFByb2plY3QiLCJwcm9qZWN0SWQiLCJwcm9qZWN0IiwiZ2V0Q2FjaGVkVXNlcnMiLCJ1c2VycyIsImxvbmciLCJnZXRDYWNoZWRUYXNrc0J5UHJvamVjdElkcyIsInByb2plY3RJZHMiLCJ0YXNrcyIsInNob3J0IiwiZ2V0Q2FjaGVkUHJvamVjdFN0YXR1c2VzIiwicHJvamVjdFN0YXR1c2VzIiwiaW52YWxpZGF0ZVByb2plY3RDYWNoZXMiLCJpbnZhbGlkYXRlUGF0dGVybiIsIlJlZ0V4cCIsImV4ZWN1dGUiLCJpbnZhbGlkYXRlVGFza0NhY2hlcyIsInRhc2siLCJpbnZhbGlkYXRlQWxsUHJvamVjdENhY2hlcyIsIm9wdGltaXN0aWNVcGRhdGVUYXNrIiwidXBkYXRlZFRhc2siLCJwYXR0ZXJucyIsInByb2plY3RUYXNrcyIsImZvckVhY2giLCJwYXR0ZXJuIiwiY2FjaGVkIiwiZ2V0IiwidXBkYXRlZCIsIm1hcCIsInQiLCJpZCIsInNldCIsImNhY2hlS2V5cyIsIkFycmF5IiwiZnJvbSIsImNhY2hlIiwia2V5cyIsInRlc3QiLCJvcHRpbWlzdGljVXBkYXRlUHJvamVjdCIsInVwZGF0ZWRQcm9qZWN0IiwicHJvamVjdHNLZXkiLCJjYWNoZWRQcm9qZWN0cyIsInVwZGF0ZVByb2plY3RJbkxpc3QiLCJwIiwic3ViUHJvamVjdHMiLCJsZW5ndGgiLCJwcmVmZXRjaFByb2plY3REYXRhIiwiUHJvbWlzZSIsImFsbCIsImNhdGNoIiwiZXJyIiwiY29uc29sZSIsIndhcm4iLCJnZXRDYWNoZVN0YXRzIiwiZ2V0U3RhdHMiLCJjbGVhckFsbENhY2hlcyIsImNsZWFyIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/cached-api.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/lib/csrf.ts":
/*!*************************!*\
  !*** ./src/lib/csrf.ts ***!
  \*************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addCsrfHeaders: () => (/* binding */ addCsrfHeaders),\n/* harmony export */   clearCsrfToken: () => (/* binding */ clearCsrfToken),\n/* harmony export */   getCsrfToken: () => (/* binding */ getCsrfToken)\n/* harmony export */ });\n/* __next_internal_client_entry_do_not_use__ getCsrfToken,clearCsrfToken,addCsrfHeaders auto */ // CSRF token management for frontend\nlet cachedToken = null;\nlet tokenPromise = null;\nasync function getCsrfToken() {\n    // If we already have a cached token, return it\n    if (cachedToken) {\n        return cachedToken;\n    }\n    // If a request is already in progress, wait for it\n    if (tokenPromise) {\n        return tokenPromise;\n    }\n    // Start a new request for the token\n    tokenPromise = fetchCsrfToken();\n    try {\n        cachedToken = await tokenPromise;\n        return cachedToken;\n    } finally{\n        tokenPromise = null;\n    }\n}\nasync function fetchCsrfToken() {\n    // Import API_BASE dynamically to avoid circular dependencies\n    const { getApiBase } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./api */ \"(app-pages-browser)/./src/lib/api.ts\"));\n    const API_BASE = getApiBase();\n    const response = await fetch(\"\".concat(API_BASE, \"/csrf-token\"), {\n        method: 'GET',\n        credentials: 'include'\n    });\n    if (!response.ok) {\n        throw new Error('Failed to fetch CSRF token');\n    }\n    const data = await response.json();\n    return data.csrfToken;\n}\nfunction clearCsrfToken() {\n    cachedToken = null;\n    tokenPromise = null;\n}\n// Utility to add CSRF token to request headers\nasync function addCsrfHeaders() {\n    let headers = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    // Always add CSRF token for critical operations (backend requires it even in development)\n    try {\n        const token = await getCsrfToken();\n        headers['X-CSRF-Token'] = token;\n    } catch (error) {\n        console.warn('Failed to get CSRF token:', error);\n        // In production, this should fail the request\n        if (false) {}\n    }\n    return headers;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvY3NyZi50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Z0dBRUEscUNBQXFDO0FBQ3JDLElBQUlBLGNBQTZCO0FBQ2pDLElBQUlDLGVBQXVDO0FBRXBDLGVBQWVDO0lBQ3BCLCtDQUErQztJQUMvQyxJQUFJRixhQUFhO1FBQ2YsT0FBT0E7SUFDVDtJQUVBLG1EQUFtRDtJQUNuRCxJQUFJQyxjQUFjO1FBQ2hCLE9BQU9BO0lBQ1Q7SUFFQSxvQ0FBb0M7SUFDcENBLGVBQWVFO0lBRWYsSUFBSTtRQUNGSCxjQUFjLE1BQU1DO1FBQ3BCLE9BQU9EO0lBQ1QsU0FBVTtRQUNSQyxlQUFlO0lBQ2pCO0FBQ0Y7QUFFQSxlQUFlRTtJQUNiLDZEQUE2RDtJQUM3RCxNQUFNLEVBQUVDLFVBQVUsRUFBRSxHQUFHLE1BQU0seUlBQWU7SUFDNUMsTUFBTUMsV0FBV0Q7SUFHakIsTUFBTUUsV0FBVyxNQUFNQyxNQUFNLEdBQVksT0FBVEYsVUFBUyxnQkFBYztRQUNyREcsUUFBUTtRQUNSQyxhQUFhO0lBQ2Y7SUFFQSxJQUFJLENBQUNILFNBQVNJLEVBQUUsRUFBRTtRQUNoQixNQUFNLElBQUlDLE1BQU07SUFDbEI7SUFFQSxNQUFNQyxPQUFPLE1BQU1OLFNBQVNPLElBQUk7SUFDaEMsT0FBT0QsS0FBS0UsU0FBUztBQUN2QjtBQUVPLFNBQVNDO0lBQ2RmLGNBQWM7SUFDZEMsZUFBZTtBQUNqQjtBQUVBLCtDQUErQztBQUN4QyxlQUFlZTtRQUFlQyxVQUFBQSxpRUFBa0MsQ0FBQztJQUN0RSwwRkFBMEY7SUFDMUYsSUFBSTtRQUNGLE1BQU1DLFFBQVEsTUFBTWhCO1FBQ3BCZSxPQUFPLENBQUMsZUFBZSxHQUFHQztJQUM1QixFQUFFLE9BQU9DLE9BQU87UUFDZEMsUUFBUUMsSUFBSSxDQUFDLDZCQUE2QkY7UUFDMUMsOENBQThDO1FBQzlDLElBQUlHLEtBQXFDLEVBQUUsRUFFMUM7SUFDSDtJQUVBLE9BQU9MO0FBQ1QiLCJzb3VyY2VzIjpbIi9ob21lL2NvZGVyL09yY2hlUGxhbi9mcm9udGVuZC9zcmMvbGliL2NzcmYudHMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCJcblxuLy8gQ1NSRiB0b2tlbiBtYW5hZ2VtZW50IGZvciBmcm9udGVuZFxubGV0IGNhY2hlZFRva2VuOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcbmxldCB0b2tlblByb21pc2U6IFByb21pc2U8c3RyaW5nPiB8IG51bGwgPSBudWxsO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q3NyZlRva2VuKCk6IFByb21pc2U8c3RyaW5nPiB7XG4gIC8vIElmIHdlIGFscmVhZHkgaGF2ZSBhIGNhY2hlZCB0b2tlbiwgcmV0dXJuIGl0XG4gIGlmIChjYWNoZWRUb2tlbikge1xuICAgIHJldHVybiBjYWNoZWRUb2tlbjtcbiAgfVxuXG4gIC8vIElmIGEgcmVxdWVzdCBpcyBhbHJlYWR5IGluIHByb2dyZXNzLCB3YWl0IGZvciBpdFxuICBpZiAodG9rZW5Qcm9taXNlKSB7XG4gICAgcmV0dXJuIHRva2VuUHJvbWlzZTtcbiAgfVxuXG4gIC8vIFN0YXJ0IGEgbmV3IHJlcXVlc3QgZm9yIHRoZSB0b2tlblxuICB0b2tlblByb21pc2UgPSBmZXRjaENzcmZUb2tlbigpO1xuICBcbiAgdHJ5IHtcbiAgICBjYWNoZWRUb2tlbiA9IGF3YWl0IHRva2VuUHJvbWlzZTtcbiAgICByZXR1cm4gY2FjaGVkVG9rZW47XG4gIH0gZmluYWxseSB7XG4gICAgdG9rZW5Qcm9taXNlID0gbnVsbDtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBmZXRjaENzcmZUb2tlbigpOiBQcm9taXNlPHN0cmluZz4ge1xuICAvLyBJbXBvcnQgQVBJX0JBU0UgZHluYW1pY2FsbHkgdG8gYXZvaWQgY2lyY3VsYXIgZGVwZW5kZW5jaWVzXG4gIGNvbnN0IHsgZ2V0QXBpQmFzZSB9ID0gYXdhaXQgaW1wb3J0KCcuL2FwaScpO1xuICBjb25zdCBBUElfQkFTRSA9IGdldEFwaUJhc2UoKTtcbiAgXG4gIFxuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFfS9jc3JmLXRva2VuYCwge1xuICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgY3JlZGVudGlhbHM6ICdpbmNsdWRlJywgLy8gSW5jbHVkZSBjb29raWVzXG4gIH0pO1xuXG4gIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBmZXRjaCBDU1JGIHRva2VuJyk7XG4gIH1cblxuICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICByZXR1cm4gZGF0YS5jc3JmVG9rZW47XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjbGVhckNzcmZUb2tlbigpOiB2b2lkIHtcbiAgY2FjaGVkVG9rZW4gPSBudWxsO1xuICB0b2tlblByb21pc2UgPSBudWxsO1xufVxuXG4vLyBVdGlsaXR5IHRvIGFkZCBDU1JGIHRva2VuIHRvIHJlcXVlc3QgaGVhZGVyc1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFkZENzcmZIZWFkZXJzKGhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fSk6IFByb21pc2U8UmVjb3JkPHN0cmluZywgc3RyaW5nPj4ge1xuICAvLyBBbHdheXMgYWRkIENTUkYgdG9rZW4gZm9yIGNyaXRpY2FsIG9wZXJhdGlvbnMgKGJhY2tlbmQgcmVxdWlyZXMgaXQgZXZlbiBpbiBkZXZlbG9wbWVudClcbiAgdHJ5IHtcbiAgICBjb25zdCB0b2tlbiA9IGF3YWl0IGdldENzcmZUb2tlbigpO1xuICAgIGhlYWRlcnNbJ1gtQ1NSRi1Ub2tlbiddID0gdG9rZW47XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gZ2V0IENTUkYgdG9rZW46JywgZXJyb3IpO1xuICAgIC8vIEluIHByb2R1Y3Rpb24sIHRoaXMgc2hvdWxkIGZhaWwgdGhlIHJlcXVlc3RcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIFxuICByZXR1cm4gaGVhZGVycztcbn0iXSwibmFtZXMiOlsiY2FjaGVkVG9rZW4iLCJ0b2tlblByb21pc2UiLCJnZXRDc3JmVG9rZW4iLCJmZXRjaENzcmZUb2tlbiIsImdldEFwaUJhc2UiLCJBUElfQkFTRSIsInJlc3BvbnNlIiwiZmV0Y2giLCJtZXRob2QiLCJjcmVkZW50aWFscyIsIm9rIiwiRXJyb3IiLCJkYXRhIiwianNvbiIsImNzcmZUb2tlbiIsImNsZWFyQ3NyZlRva2VuIiwiYWRkQ3NyZkhlYWRlcnMiLCJoZWFkZXJzIiwidG9rZW4iLCJlcnJvciIsImNvbnNvbGUiLCJ3YXJuIiwicHJvY2VzcyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/csrf.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/lib/logger.ts":
/*!***************************!*\
  !*** ./src/lib/logger.ts ***!
  \***************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createComponentLogger: () => (/* binding */ createComponentLogger),\n/* harmony export */   generateCorrelationId: () => (/* binding */ generateCorrelationId),\n/* harmony export */   logger: () => (/* binding */ logger),\n/* harmony export */   measureTime: () => (/* binding */ measureTime),\n/* harmony export */   measureTimeAsync: () => (/* binding */ measureTimeAsync)\n/* harmony export */ });\n// Centralized logging utility for frontend\nclass EnhancedLogger {\n    formatMessage(level, message, context) {\n        const timestamp = new Date().toISOString();\n        const mergedContext = {\n            ...this.globalContext,\n            ...this.parentContext,\n            ...context\n        };\n        let prefix = \"[\".concat(level.toUpperCase(), \"] \").concat(timestamp);\n        // Add context information to prefix\n        if (mergedContext.component) {\n            prefix += \" [\".concat(mergedContext.component, \"]\");\n        }\n        if (mergedContext.userId) {\n            prefix += \" [User:\".concat(mergedContext.userId, \"]\");\n        }\n        if (mergedContext.projectId) {\n            prefix += \" [Project:\".concat(mergedContext.projectId, \"]\");\n        }\n        if (mergedContext.action) {\n            prefix += \" [\".concat(mergedContext.action, \"]\");\n        }\n        if (mergedContext.correlationId) {\n            prefix += \" [ID:\".concat(mergedContext.correlationId, \"]\");\n        }\n        return \"\".concat(prefix, \" \").concat(message);\n    }\n    log(level, message, context) {\n        for(var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++){\n            args[_key - 3] = arguments[_key];\n        }\n        const timestamp = new Date().toISOString();\n        // In production, only log warnings and errors\n        if (false) {}\n        // Safely merge context objects\n        const safeGlobalContext = this.globalContext || {};\n        const safeParentContext = this.parentContext || {};\n        const safeContext = context || {};\n        const mergedContext = {\n            ...safeGlobalContext,\n            ...safeParentContext,\n            ...safeContext\n        };\n        // Filter out undefined, null, and empty string values from context\n        const filteredContext = Object.fromEntries(Object.entries(mergedContext).filter((param)=>{\n            let [key, value] = param;\n            return value !== undefined && value !== null && value !== '';\n        }));\n        // Create log entry for buffer\n        const logEntry = {\n            level,\n            message,\n            timestamp,\n            context: filteredContext,\n            args: args.length > 0 ? args : undefined\n        };\n        // Add error details if present\n        if (args.length > 0 && args[0] instanceof Error) {\n            logEntry.error = {\n                name: args[0].name,\n                message: args[0].message,\n                stack: args[0].stack\n            };\n        }\n        // Add to buffer\n        this.addToBuffer(logEntry);\n        // Format message for console\n        const formattedMessage = this.formatMessage(level, message, filteredContext);\n        // Helper to check if context has meaningful content\n        const hasContext = Object.keys(filteredContext).length > 0;\n        // Console output based on level and environment\n        switch(level){\n            case 'debug':\n                if (this.isDevelopment) {\n                    if (hasContext) {}\n                }\n                break;\n            case 'info':\n                if (this.isDevelopment) {\n                    console.info(formattedMessage, ...args);\n                    if (hasContext) {\n                        console.info('Context:', filteredContext);\n                    }\n                }\n                break;\n            case 'warn':\n                console.warn(formattedMessage, ...args);\n                if (hasContext) {\n                    console.warn('Context:', filteredContext);\n                }\n                break;\n            case 'error':\n                console.error(formattedMessage, ...args);\n                if (hasContext) {\n                    console.error('Context:', filteredContext);\n                } else if (this.isDevelopment) {\n                // In development, show when context was intentionally omitted vs empty\n                }\n                // In development, also show stack trace for unexpected errors only\n                if (this.isDevelopment && args.length > 0) {\n                    args.forEach((arg)=>{\n                        if (arg instanceof Error && arg.stack && !arg.isExpected) {\n                            console.error('Stack trace:', arg.stack);\n                        }\n                    });\n                }\n                break;\n        }\n        // Send to external logging service in production\n        if (!this.isDevelopment && level === 'error') {\n            this.sendToExternalLogging(logEntry);\n        }\n    }\n    addToBuffer(entry) {\n        this.logBuffer.push(entry);\n        if (this.logBuffer.length > this.maxBufferSize) {\n            this.logBuffer.shift(); // Remove oldest entry\n        }\n    }\n    async sendToExternalLogging(entry) {\n        // This would integrate with external logging services like LogRocket, Sentry, etc.\n        // For now, just store in localStorage for debugging\n        try {\n            const existingLogs = JSON.parse(localStorage.getItem('orcheplan_error_logs') || '[]');\n            existingLogs.push(entry);\n            // Keep only last 50 error logs\n            if (existingLogs.length > 50) {\n                existingLogs.splice(0, existingLogs.length - 50);\n            }\n            localStorage.setItem('orcheplan_error_logs', JSON.stringify(existingLogs));\n        } catch (e) {\n        // Ignore localStorage errors\n        }\n    }\n    debug(message, context) {\n        for(var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++){\n            args[_key - 2] = arguments[_key];\n        }\n        this.log('debug', message, context, ...args);\n    }\n    info(message, context) {\n        for(var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++){\n            args[_key - 2] = arguments[_key];\n        }\n        this.log('info', message, context, ...args);\n    }\n    warn(message, context) {\n        for(var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++){\n            args[_key - 2] = arguments[_key];\n        }\n        this.log('warn', message, context, ...args);\n    }\n    error(message, context) {\n        for(var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++){\n            args[_key - 2] = arguments[_key];\n        }\n        this.log('error', message, context, ...args);\n    }\n    setContext(context) {\n        this.globalContext = {\n            ...this.globalContext,\n            ...context\n        };\n        return this;\n    }\n    withContext(context) {\n        return new EnhancedLogger({\n            ...this.parentContext,\n            ...context\n        });\n    }\n    // Get recent logs for debugging\n    getRecentLogs() {\n        return [\n            ...this.logBuffer\n        ];\n    }\n    // Clear log buffer\n    clearLogs() {\n        this.logBuffer = [];\n    }\n    // Export logs for debugging\n    exportLogs() {\n        return JSON.stringify(this.logBuffer, null, 2);\n    }\n    constructor(parentContext = {}){\n        this.parentContext = parentContext;\n        this.isDevelopment = \"development\" === 'development';\n        this.globalContext = {};\n        this.logBuffer = [];\n        this.maxBufferSize = 100;\n    }\n}\n// Create singleton logger instance\nconst logger = new EnhancedLogger();\n// Helper function to generate correlation IDs\nfunction generateCorrelationId() {\n    return \"\".concat(Date.now(), \"-\").concat(Math.random().toString(36).substr(2, 9));\n}\n// Helper function to create component-specific loggers\nfunction createComponentLogger(componentName) {\n    return logger.withContext({\n        component: componentName\n    });\n}\n// Helper function to measure execution time\nfunction measureTime(operation, fn, context) {\n    const start = performance.now();\n    const correlationId = generateCorrelationId();\n    const componentLogger = logger.withContext({\n        ...context,\n        correlationId\n    });\n    componentLogger.debug(\"Starting \".concat(operation));\n    try {\n        const result = fn();\n        const duration = performance.now() - start;\n        componentLogger.info(\"Completed \".concat(operation), {\n            duration: \"\".concat(duration.toFixed(2), \"ms\")\n        });\n        return result;\n    } catch (error) {\n        const duration = performance.now() - start;\n        componentLogger.error(\"Failed \".concat(operation), {\n            duration: \"\".concat(duration.toFixed(2), \"ms\")\n        }, error);\n        throw error;\n    }\n}\n// Helper function to measure async execution time\nasync function measureTimeAsync(operation, fn, context) {\n    const start = performance.now();\n    const correlationId = generateCorrelationId();\n    const componentLogger = logger.withContext({\n        ...context,\n        correlationId\n    });\n    componentLogger.debug(\"Starting \".concat(operation));\n    try {\n        const result = await fn();\n        const duration = performance.now() - start;\n        componentLogger.info(\"Completed \".concat(operation), {\n            duration: \"\".concat(duration.toFixed(2), \"ms\")\n        });\n        return result;\n    } catch (error) {\n        const duration = performance.now() - start;\n        componentLogger.error(\"Failed \".concat(operation), {\n            duration: \"\".concat(duration.toFixed(2), \"ms\")\n        }, error);\n        throw error;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUk7UUFDdEYsT0FBT0Y7SUFDVCxFQUFFLE9BQU9sRCxPQUFPO1FBQ2QsTUFBTW1ELFdBQVdILFlBQVlWLEdBQUcsS0FBS1M7UUFDckNFLGdCQUFnQmpELEtBQUssQ0FBQyxVQUFvQixPQUFWNkMsWUFBYTtZQUFFTSxVQUFVLEdBQXVCLE9BQXBCQSxTQUFTQyxPQUFPLENBQUMsSUFBRztRQUFJLEdBQUdwRDtRQUN2RixNQUFNQTtJQUNSO0FBQ0YiLCJzb3VyY2VzIjpbIi9ob21lL2NvZGVyL09yY2hlUGxhbi9mcm9udGVuZC9zcmMvbGliL2xvZ2dlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDZW50cmFsaXplZCBsb2dnaW5nIHV0aWxpdHkgZm9yIGZyb250ZW5kXG50eXBlIExvZ0xldmVsID0gJ2RlYnVnJyB8ICdpbmZvJyB8ICd3YXJuJyB8ICdlcnJvcic7XG5cbmludGVyZmFjZSBMb2dDb250ZXh0IHtcbiAgdXNlcklkPzogc3RyaW5nO1xuICBwcm9qZWN0SWQ/OiBzdHJpbmc7XG4gIHRhc2tJZD86IHN0cmluZztcbiAgY29tcG9uZW50Pzogc3RyaW5nO1xuICBhY3Rpb24/OiBzdHJpbmc7XG4gIGNvcnJlbGF0aW9uSWQ/OiBzdHJpbmc7XG4gIHRpbWVzdGFtcD86IHN0cmluZztcbiAgW2tleTogc3RyaW5nXTogYW55O1xufVxuXG5pbnRlcmZhY2UgTG9nRW50cnkge1xuICBsZXZlbDogTG9nTGV2ZWw7XG4gIG1lc3NhZ2U6IHN0cmluZztcbiAgdGltZXN0YW1wOiBzdHJpbmc7XG4gIGNvbnRleHQ/OiBMb2dDb250ZXh0O1xuICBhcmdzPzogYW55W107XG4gIGVycm9yPzoge1xuICAgIG5hbWU6IHN0cmluZztcbiAgICBtZXNzYWdlOiBzdHJpbmc7XG4gICAgc3RhY2s/OiBzdHJpbmc7XG4gIH07XG59XG5cbmludGVyZmFjZSBMb2dnZXIge1xuICBkZWJ1ZzogKG1lc3NhZ2U6IHN0cmluZywgY29udGV4dD86IExvZ0NvbnRleHQsIC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkO1xuICBpbmZvOiAobWVzc2FnZTogc3RyaW5nLCBjb250ZXh0PzogTG9nQ29udGV4dCwgLi4uYXJnczogYW55W10pID0+IHZvaWQ7XG4gIHdhcm46IChtZXNzYWdlOiBzdHJpbmcsIGNvbnRleHQ/OiBMb2dDb250ZXh0LCAuLi5hcmdzOiBhbnlbXSkgPT4gdm9pZDtcbiAgZXJyb3I6IChtZXNzYWdlOiBzdHJpbmcsIGNvbnRleHQ/OiBMb2dDb250ZXh0LCAuLi5hcmdzOiBhbnlbXSkgPT4gdm9pZDtcbiAgc2V0Q29udGV4dDogKGNvbnRleHQ6IExvZ0NvbnRleHQpID0+IExvZ2dlcjtcbiAgd2l0aENvbnRleHQ6IChjb250ZXh0OiBMb2dDb250ZXh0KSA9PiBMb2dnZXI7XG59XG5cbmNsYXNzIEVuaGFuY2VkTG9nZ2VyIGltcGxlbWVudHMgTG9nZ2VyIHtcbiAgcHJpdmF0ZSBpc0RldmVsb3BtZW50ID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCc7XG4gIHByaXZhdGUgZ2xvYmFsQ29udGV4dDogTG9nQ29udGV4dCA9IHt9O1xuICBwcml2YXRlIGxvZ0J1ZmZlcjogTG9nRW50cnlbXSA9IFtdO1xuICBwcml2YXRlIG1heEJ1ZmZlclNpemUgPSAxMDA7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBwYXJlbnRDb250ZXh0OiBMb2dDb250ZXh0ID0ge30pIHt9XG5cbiAgcHJpdmF0ZSBmb3JtYXRNZXNzYWdlKGxldmVsOiBMb2dMZXZlbCwgbWVzc2FnZTogc3RyaW5nLCBjb250ZXh0PzogTG9nQ29udGV4dCk6IHN0cmluZyB7XG4gICAgY29uc3QgdGltZXN0YW1wID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgIGNvbnN0IG1lcmdlZENvbnRleHQgPSB7IC4uLnRoaXMuZ2xvYmFsQ29udGV4dCwgLi4udGhpcy5wYXJlbnRDb250ZXh0LCAuLi5jb250ZXh0IH07XG4gICAgXG4gICAgbGV0IHByZWZpeCA9IGBbJHtsZXZlbC50b1VwcGVyQ2FzZSgpfV0gJHt0aW1lc3RhbXB9YDtcbiAgICBcbiAgICAvLyBBZGQgY29udGV4dCBpbmZvcm1hdGlvbiB0byBwcmVmaXhcbiAgICBpZiAobWVyZ2VkQ29udGV4dC5jb21wb25lbnQpIHtcbiAgICAgIHByZWZpeCArPSBgIFske21lcmdlZENvbnRleHQuY29tcG9uZW50fV1gO1xuICAgIH1cbiAgICBpZiAobWVyZ2VkQ29udGV4dC51c2VySWQpIHtcbiAgICAgIHByZWZpeCArPSBgIFtVc2VyOiR7bWVyZ2VkQ29udGV4dC51c2VySWR9XWA7XG4gICAgfVxuICAgIGlmIChtZXJnZWRDb250ZXh0LnByb2plY3RJZCkge1xuICAgICAgcHJlZml4ICs9IGAgW1Byb2plY3Q6JHttZXJnZWRDb250ZXh0LnByb2plY3RJZH1dYDtcbiAgICB9XG4gICAgaWYgKG1lcmdlZENvbnRleHQuYWN0aW9uKSB7XG4gICAgICBwcmVmaXggKz0gYCBbJHttZXJnZWRDb250ZXh0LmFjdGlvbn1dYDtcbiAgICB9XG4gICAgaWYgKG1lcmdlZENvbnRleHQuY29ycmVsYXRpb25JZCkge1xuICAgICAgcHJlZml4ICs9IGAgW0lEOiR7bWVyZ2VkQ29udGV4dC5jb3JyZWxhdGlvbklkfV1gO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gYCR7cHJlZml4fSAke21lc3NhZ2V9YDtcbiAgfVxuXG4gIHByaXZhdGUgbG9nKGxldmVsOiBMb2dMZXZlbCwgbWVzc2FnZTogc3RyaW5nLCBjb250ZXh0PzogTG9nQ29udGV4dCwgLi4uYXJnczogYW55W10pIHtcbiAgICBjb25zdCB0aW1lc3RhbXAgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgXG4gICAgLy8gSW4gcHJvZHVjdGlvbiwgb25seSBsb2cgd2FybmluZ3MgYW5kIGVycm9yc1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nICYmIGxldmVsICE9PSAnd2FybicgJiYgbGV2ZWwgIT09ICdlcnJvcicpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgLy8gU2FmZWx5IG1lcmdlIGNvbnRleHQgb2JqZWN0c1xuICAgIGNvbnN0IHNhZmVHbG9iYWxDb250ZXh0ID0gdGhpcy5nbG9iYWxDb250ZXh0IHx8IHt9O1xuICAgIGNvbnN0IHNhZmVQYXJlbnRDb250ZXh0ID0gdGhpcy5wYXJlbnRDb250ZXh0IHx8IHt9O1xuICAgIGNvbnN0IHNhZmVDb250ZXh0ID0gY29udGV4dCB8fCB7fTtcbiAgICBcbiAgICBjb25zdCBtZXJnZWRDb250ZXh0ID0geyAuLi5zYWZlR2xvYmFsQ29udGV4dCwgLi4uc2FmZVBhcmVudENvbnRleHQsIC4uLnNhZmVDb250ZXh0IH07XG4gICAgXG4gICAgLy8gRmlsdGVyIG91dCB1bmRlZmluZWQsIG51bGwsIGFuZCBlbXB0eSBzdHJpbmcgdmFsdWVzIGZyb20gY29udGV4dFxuICAgIGNvbnN0IGZpbHRlcmVkQ29udGV4dCA9IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgIE9iamVjdC5lbnRyaWVzKG1lcmdlZENvbnRleHQpLmZpbHRlcigoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSAnJztcbiAgICAgIH0pXG4gICAgKTtcbiAgICBcbiAgICAvLyBDcmVhdGUgbG9nIGVudHJ5IGZvciBidWZmZXJcbiAgICBjb25zdCBsb2dFbnRyeTogTG9nRW50cnkgPSB7XG4gICAgICBsZXZlbCxcbiAgICAgIG1lc3NhZ2UsXG4gICAgICB0aW1lc3RhbXAsXG4gICAgICBjb250ZXh0OiBmaWx0ZXJlZENvbnRleHQsXG4gICAgICBhcmdzOiBhcmdzLmxlbmd0aCA+IDAgPyBhcmdzIDogdW5kZWZpbmVkLFxuICAgIH07XG5cbiAgICAvLyBBZGQgZXJyb3IgZGV0YWlscyBpZiBwcmVzZW50XG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gMCAmJiBhcmdzWzBdIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIGxvZ0VudHJ5LmVycm9yID0ge1xuICAgICAgICBuYW1lOiBhcmdzWzBdLm5hbWUsXG4gICAgICAgIG1lc3NhZ2U6IGFyZ3NbMF0ubWVzc2FnZSxcbiAgICAgICAgc3RhY2s6IGFyZ3NbMF0uc3RhY2ssXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIEFkZCB0byBidWZmZXJcbiAgICB0aGlzLmFkZFRvQnVmZmVyKGxvZ0VudHJ5KTtcblxuICAgIC8vIEZvcm1hdCBtZXNzYWdlIGZvciBjb25zb2xlXG4gICAgY29uc3QgZm9ybWF0dGVkTWVzc2FnZSA9IHRoaXMuZm9ybWF0TWVzc2FnZShsZXZlbCwgbWVzc2FnZSwgZmlsdGVyZWRDb250ZXh0KTtcblxuICAgIC8vIEhlbHBlciB0byBjaGVjayBpZiBjb250ZXh0IGhhcyBtZWFuaW5nZnVsIGNvbnRlbnRcbiAgICBjb25zdCBoYXNDb250ZXh0ID0gT2JqZWN0LmtleXMoZmlsdGVyZWRDb250ZXh0KS5sZW5ndGggPiAwO1xuICAgIFxuICAgIC8vIENvbnNvbGUgb3V0cHV0IGJhc2VkIG9uIGxldmVsIGFuZCBlbnZpcm9ubWVudFxuICAgIHN3aXRjaCAobGV2ZWwpIHtcbiAgICAgIGNhc2UgJ2RlYnVnJzpcbiAgICAgICAgaWYgKHRoaXMuaXNEZXZlbG9wbWVudCkge1xuICAgICAgICAgIGlmIChoYXNDb250ZXh0KSB7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnaW5mbyc6XG4gICAgICAgIGlmICh0aGlzLmlzRGV2ZWxvcG1lbnQpIHtcbiAgICAgICAgICBjb25zb2xlLmluZm8oZm9ybWF0dGVkTWVzc2FnZSwgLi4uYXJncyk7XG4gICAgICAgICAgaWYgKGhhc0NvbnRleHQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbygnQ29udGV4dDonLCBmaWx0ZXJlZENvbnRleHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3dhcm4nOlxuICAgICAgICBjb25zb2xlLndhcm4oZm9ybWF0dGVkTWVzc2FnZSwgLi4uYXJncyk7XG4gICAgICAgIGlmIChoYXNDb250ZXh0KSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdDb250ZXh0OicsIGZpbHRlcmVkQ29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZm9ybWF0dGVkTWVzc2FnZSwgLi4uYXJncyk7XG4gICAgICAgIGlmIChoYXNDb250ZXh0KSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignQ29udGV4dDonLCBmaWx0ZXJlZENvbnRleHQpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNEZXZlbG9wbWVudCkge1xuICAgICAgICAgIC8vIEluIGRldmVsb3BtZW50LCBzaG93IHdoZW4gY29udGV4dCB3YXMgaW50ZW50aW9uYWxseSBvbWl0dGVkIHZzIGVtcHR5XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW4gZGV2ZWxvcG1lbnQsIGFsc28gc2hvdyBzdGFjayB0cmFjZSBmb3IgdW5leHBlY3RlZCBlcnJvcnMgb25seVxuICAgICAgICBpZiAodGhpcy5pc0RldmVsb3BtZW50ICYmIGFyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGFyZ3MuZm9yRWFjaChhcmcgPT4ge1xuICAgICAgICAgICAgaWYgKGFyZyBpbnN0YW5jZW9mIEVycm9yICYmIGFyZy5zdGFjayAmJiAhKGFyZyBhcyBhbnkpLmlzRXhwZWN0ZWQpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignU3RhY2sgdHJhY2U6JywgYXJnLnN0YWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBTZW5kIHRvIGV4dGVybmFsIGxvZ2dpbmcgc2VydmljZSBpbiBwcm9kdWN0aW9uXG4gICAgaWYgKCF0aGlzLmlzRGV2ZWxvcG1lbnQgJiYgbGV2ZWwgPT09ICdlcnJvcicpIHtcbiAgICAgIHRoaXMuc2VuZFRvRXh0ZXJuYWxMb2dnaW5nKGxvZ0VudHJ5KTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFkZFRvQnVmZmVyKGVudHJ5OiBMb2dFbnRyeSkge1xuICAgIHRoaXMubG9nQnVmZmVyLnB1c2goZW50cnkpO1xuICAgIGlmICh0aGlzLmxvZ0J1ZmZlci5sZW5ndGggPiB0aGlzLm1heEJ1ZmZlclNpemUpIHtcbiAgICAgIHRoaXMubG9nQnVmZmVyLnNoaWZ0KCk7IC8vIFJlbW92ZSBvbGRlc3QgZW50cnlcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHNlbmRUb0V4dGVybmFsTG9nZ2luZyhlbnRyeTogTG9nRW50cnkpIHtcbiAgICAvLyBUaGlzIHdvdWxkIGludGVncmF0ZSB3aXRoIGV4dGVybmFsIGxvZ2dpbmcgc2VydmljZXMgbGlrZSBMb2dSb2NrZXQsIFNlbnRyeSwgZXRjLlxuICAgIC8vIEZvciBub3csIGp1c3Qgc3RvcmUgaW4gbG9jYWxTdG9yYWdlIGZvciBkZWJ1Z2dpbmdcbiAgICB0cnkge1xuICAgICAgY29uc3QgZXhpc3RpbmdMb2dzID0gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnb3JjaGVwbGFuX2Vycm9yX2xvZ3MnKSB8fCAnW10nKTtcbiAgICAgIGV4aXN0aW5nTG9ncy5wdXNoKGVudHJ5KTtcbiAgICAgIC8vIEtlZXAgb25seSBsYXN0IDUwIGVycm9yIGxvZ3NcbiAgICAgIGlmIChleGlzdGluZ0xvZ3MubGVuZ3RoID4gNTApIHtcbiAgICAgICAgZXhpc3RpbmdMb2dzLnNwbGljZSgwLCBleGlzdGluZ0xvZ3MubGVuZ3RoIC0gNTApO1xuICAgICAgfVxuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ29yY2hlcGxhbl9lcnJvcl9sb2dzJywgSlNPTi5zdHJpbmdpZnkoZXhpc3RpbmdMb2dzKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gSWdub3JlIGxvY2FsU3RvcmFnZSBlcnJvcnNcbiAgICB9XG4gIH1cblxuICBkZWJ1ZyhtZXNzYWdlOiBzdHJpbmcsIGNvbnRleHQ/OiBMb2dDb250ZXh0LCAuLi5hcmdzOiBhbnlbXSkge1xuICAgIHRoaXMubG9nKCdkZWJ1ZycsIG1lc3NhZ2UsIGNvbnRleHQsIC4uLmFyZ3MpO1xuICB9XG5cbiAgaW5mbyhtZXNzYWdlOiBzdHJpbmcsIGNvbnRleHQ/OiBMb2dDb250ZXh0LCAuLi5hcmdzOiBhbnlbXSkge1xuICAgIHRoaXMubG9nKCdpbmZvJywgbWVzc2FnZSwgY29udGV4dCwgLi4uYXJncyk7XG4gIH1cblxuICB3YXJuKG1lc3NhZ2U6IHN0cmluZywgY29udGV4dD86IExvZ0NvbnRleHQsIC4uLmFyZ3M6IGFueVtdKSB7XG4gICAgdGhpcy5sb2coJ3dhcm4nLCBtZXNzYWdlLCBjb250ZXh0LCAuLi5hcmdzKTtcbiAgfVxuXG4gIGVycm9yKG1lc3NhZ2U6IHN0cmluZywgY29udGV4dD86IExvZ0NvbnRleHQsIC4uLmFyZ3M6IGFueVtdKSB7XG4gICAgdGhpcy5sb2coJ2Vycm9yJywgbWVzc2FnZSwgY29udGV4dCwgLi4uYXJncyk7XG4gIH1cblxuICBzZXRDb250ZXh0KGNvbnRleHQ6IExvZ0NvbnRleHQpOiBMb2dnZXIge1xuICAgIHRoaXMuZ2xvYmFsQ29udGV4dCA9IHsgLi4udGhpcy5nbG9iYWxDb250ZXh0LCAuLi5jb250ZXh0IH07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB3aXRoQ29udGV4dChjb250ZXh0OiBMb2dDb250ZXh0KTogTG9nZ2VyIHtcbiAgICByZXR1cm4gbmV3IEVuaGFuY2VkTG9nZ2VyKHsgLi4udGhpcy5wYXJlbnRDb250ZXh0LCAuLi5jb250ZXh0IH0pO1xuICB9XG5cbiAgLy8gR2V0IHJlY2VudCBsb2dzIGZvciBkZWJ1Z2dpbmdcbiAgZ2V0UmVjZW50TG9ncygpOiBMb2dFbnRyeVtdIHtcbiAgICByZXR1cm4gWy4uLnRoaXMubG9nQnVmZmVyXTtcbiAgfVxuXG4gIC8vIENsZWFyIGxvZyBidWZmZXJcbiAgY2xlYXJMb2dzKCkge1xuICAgIHRoaXMubG9nQnVmZmVyID0gW107XG4gIH1cblxuICAvLyBFeHBvcnQgbG9ncyBmb3IgZGVidWdnaW5nXG4gIGV4cG9ydExvZ3MoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy5sb2dCdWZmZXIsIG51bGwsIDIpO1xuICB9XG59XG5cbi8vIENyZWF0ZSBzaW5nbGV0b24gbG9nZ2VyIGluc3RhbmNlXG5leHBvcnQgY29uc3QgbG9nZ2VyID0gbmV3IEVuaGFuY2VkTG9nZ2VyKCk7XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBnZW5lcmF0ZSBjb3JyZWxhdGlvbiBJRHNcbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZUNvcnJlbGF0aW9uSWQoKTogc3RyaW5nIHtcbiAgcmV0dXJuIGAke0RhdGUubm93KCl9LSR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDkpfWA7XG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgY29tcG9uZW50LXNwZWNpZmljIGxvZ2dlcnNcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDb21wb25lbnRMb2dnZXIoY29tcG9uZW50TmFtZTogc3RyaW5nKTogTG9nZ2VyIHtcbiAgcmV0dXJuIGxvZ2dlci53aXRoQ29udGV4dCh7IGNvbXBvbmVudDogY29tcG9uZW50TmFtZSB9KTtcbn1cblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIG1lYXN1cmUgZXhlY3V0aW9uIHRpbWVcbmV4cG9ydCBmdW5jdGlvbiBtZWFzdXJlVGltZTxUPihcbiAgb3BlcmF0aW9uOiBzdHJpbmcsXG4gIGZuOiAoKSA9PiBULFxuICBjb250ZXh0PzogTG9nQ29udGV4dFxuKTogVCB7XG4gIGNvbnN0IHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gIGNvbnN0IGNvcnJlbGF0aW9uSWQgPSBnZW5lcmF0ZUNvcnJlbGF0aW9uSWQoKTtcbiAgY29uc3QgY29tcG9uZW50TG9nZ2VyID0gbG9nZ2VyLndpdGhDb250ZXh0KHsgLi4uY29udGV4dCwgY29ycmVsYXRpb25JZCB9KTtcbiAgXG4gIGNvbXBvbmVudExvZ2dlci5kZWJ1ZyhgU3RhcnRpbmcgJHtvcGVyYXRpb259YCk7XG4gIFxuICB0cnkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGZuKCk7XG4gICAgY29uc3QgZHVyYXRpb24gPSBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0O1xuICAgIGNvbXBvbmVudExvZ2dlci5pbmZvKGBDb21wbGV0ZWQgJHtvcGVyYXRpb259YCwgeyBkdXJhdGlvbjogYCR7ZHVyYXRpb24udG9GaXhlZCgyKX1tc2AgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zdCBkdXJhdGlvbiA9IHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnQ7XG4gICAgY29tcG9uZW50TG9nZ2VyLmVycm9yKGBGYWlsZWQgJHtvcGVyYXRpb259YCwgeyBkdXJhdGlvbjogYCR7ZHVyYXRpb24udG9GaXhlZCgyKX1tc2AgfSwgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBtZWFzdXJlIGFzeW5jIGV4ZWN1dGlvbiB0aW1lXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbWVhc3VyZVRpbWVBc3luYzxUPihcbiAgb3BlcmF0aW9uOiBzdHJpbmcsXG4gIGZuOiAoKSA9PiBQcm9taXNlPFQ+LFxuICBjb250ZXh0PzogTG9nQ29udGV4dFxuKTogUHJvbWlzZTxUPiB7XG4gIGNvbnN0IHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gIGNvbnN0IGNvcnJlbGF0aW9uSWQgPSBnZW5lcmF0ZUNvcnJlbGF0aW9uSWQoKTtcbiAgY29uc3QgY29tcG9uZW50TG9nZ2VyID0gbG9nZ2VyLndpdGhDb250ZXh0KHsgLi4uY29udGV4dCwgY29ycmVsYXRpb25JZCB9KTtcbiAgXG4gIGNvbXBvbmVudExvZ2dlci5kZWJ1ZyhgU3RhcnRpbmcgJHtvcGVyYXRpb259YCk7XG4gIFxuICB0cnkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGZuKCk7XG4gICAgY29uc3QgZHVyYXRpb24gPSBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0O1xuICAgIGNvbXBvbmVudExvZ2dlci5pbmZvKGBDb21wbGV0ZWQgJHtvcGVyYXRpb259YCwgeyBkdXJhdGlvbjogYCR7ZHVyYXRpb24udG9GaXhlZCgyKX1tc2AgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zdCBkdXJhdGlvbiA9IHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnQ7XG4gICAgY29tcG9uZW50TG9nZ2VyLmVycm9yKGBGYWlsZWQgJHtvcGVyYXRpb259YCwgeyBkdXJhdGlvbjogYCR7ZHVyYXRpb24udG9GaXhlZCgyKX1tc2AgfSwgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59Il0sIm5hbWVzIjpbIkVuaGFuY2VkTG9nZ2VyIiwiZm9ybWF0TWVzc2FnZSIsImxldmVsIiwibWVzc2FnZSIsImNvbnRleHQiLCJ0aW1lc3RhbXAiLCJEYXRlIiwidG9JU09TdHJpbmciLCJtZXJnZWRDb250ZXh0IiwiZ2xvYmFsQ29udGV4dCIsInBhcmVudENvbnRleHQiLCJwcmVmaXgiLCJ0b1VwcGVyQ2FzZSIsImNvbXBvbmVudCIsInVzZXJJZCIsInByb2plY3RJZCIsImFjdGlvbiIsImNvcnJlbGF0aW9uSWQiLCJsb2ciLCJhcmdzIiwicHJvY2VzcyIsInNhZmVHbG9iYWxDb250ZXh0Iiwic2FmZVBhcmVudENvbnRleHQiLCJzYWZlQ29udGV4dCIsImZpbHRlcmVkQ29udGV4dCIsIk9iamVjdCIsImZyb21FbnRyaWVzIiwiZW50cmllcyIsImZpbHRlciIsImtleSIsInZhbHVlIiwidW5kZWZpbmVkIiwibG9nRW50cnkiLCJsZW5ndGgiLCJFcnJvciIsImVycm9yIiwibmFtZSIsInN0YWNrIiwiYWRkVG9CdWZmZXIiLCJmb3JtYXR0ZWRNZXNzYWdlIiwiaGFzQ29udGV4dCIsImtleXMiLCJpc0RldmVsb3BtZW50IiwiY29uc29sZSIsImluZm8iLCJ3YXJuIiwiZm9yRWFjaCIsImFyZyIsImlzRXhwZWN0ZWQiLCJzZW5kVG9FeHRlcm5hbExvZ2dpbmciLCJlbnRyeSIsImxvZ0J1ZmZlciIsInB1c2giLCJtYXhCdWZmZXJTaXplIiwic2hpZnQiLCJleGlzdGluZ0xvZ3MiLCJKU09OIiwicGFyc2UiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwic3BsaWNlIiwic2V0SXRlbSIsInN0cmluZ2lmeSIsImUiLCJkZWJ1ZyIsInNldENvbnRleHQiLCJ3aXRoQ29udGV4dCIsImdldFJlY2VudExvZ3MiLCJjbGVhckxvZ3MiLCJleHBvcnRMb2dzIiwibG9nZ2VyIiwiZ2VuZXJhdGVDb3JyZWxhdGlvbklkIiwiTWF0aCIsIm5vdyIsInJhbmRvbSIsInRvU3RyaW5nIiwic3Vic3RyIiwiY3JlYXRlQ29tcG9uZW50TG9nZ2VyIiwiY29tcG9uZW50TmFtZSIsIm1lYXN1cmVUaW1lIiwib3BlcmF0aW9uIiwiZm4iLCJzdGFydCIsInBlcmZvcm1hbmNlIiwiY29tcG9uZW50TG9nZ2VyIiwicmVzdWx0IiwiZHVyYXRpb24iLCJ0b0ZpeGVkIiwibWVhc3VyZVRpbWVBc3luYyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/logger.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/lib/realtime.ts":
/*!*****************************!*\
  !*** ./src/lib/realtime.ts ***!
  \*****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n// Frontend SSE client for real-time updates\nclass RealtimeClient {\n    // Connect to SSE endpoint\n    connect() {\n        // If connection has failed before, don't try again\n        if (this.connectionFailed) {\n            return;\n        }\n        if (this.eventSource) {\n            this.disconnect();\n        }\n        try {\n            const url = \"\".concat(this.baseUrl, \"/realtime/events\");\n            // Try fetch-based approach first for better error handling\n            this.connectWithFetch(url);\n        } catch (error) {\n            console.warn('[SSE] Error creating EventSource - SSE not available:', error);\n            this.connectionFailed = true;\n            this.emit('connection_failed', {\n                reason: 'creation_error'\n            });\n        }\n    }\n    // Alternative SSE connection using fetch for better compatibility\n    async connectWithFetch(url) {\n        try {\n            const response = await fetch(url, {\n                credentials: 'include',\n                headers: {\n                    'Accept': 'text/event-stream',\n                    'Cache-Control': 'no-cache'\n                }\n            });\n            if (!response.ok) {\n                throw new Error(\"SSE connection failed: \".concat(response.status, \" \").concat(response.statusText));\n            }\n            if (!response.body) {\n                throw new Error('No response body for SSE stream');\n            }\n            this.isConnected = true;\n            this.reconnectAttempts = 0;\n            this.connectionFailed = false;\n            // Use ReadableStream to process SSE data\n            const reader = response.body.getReader();\n            const decoder = new TextDecoder();\n            let buffer = '';\n            const processStream = async ()=>{\n                try {\n                    while(true){\n                        const { done, value } = await reader.read();\n                        if (done) {\n                            this.handleDisconnect();\n                            break;\n                        }\n                        buffer += decoder.decode(value, {\n                            stream: true\n                        });\n                        // Process complete messages\n                        const lines = buffer.split('\\n');\n                        buffer = lines.pop() || ''; // Keep incomplete line in buffer\n                        for (const line of lines){\n                            if (line.startsWith('data: ')) {\n                                try {\n                                    const data = JSON.parse(line.slice(6));\n                                    this.handleMessage(data);\n                                } catch (error) {\n                                    console.error('[SSE] Error parsing message:', error);\n                                }\n                            }\n                        }\n                    }\n                } catch (error) {\n                    console.error('[SSE] Stream processing error:', error);\n                    this.handleDisconnect();\n                }\n            };\n            processStream();\n        } catch (error) {\n            console.warn('[SSE] Fetch-based connection failed, trying EventSource...', error);\n            this.connectWithEventSource(url);\n        }\n    }\n    // Fallback to standard EventSource\n    connectWithEventSource(url) {\n        try {\n            this.eventSource = new EventSource(url, {\n                withCredentials: true\n            });\n            this.eventSource.onopen = ()=>{\n                this.isConnected = true;\n                this.reconnectAttempts = 0;\n                this.reconnectDelay = 1000;\n                this.connectionFailed = false;\n            };\n            this.eventSource.onmessage = (event)=>{\n                try {\n                    const data = JSON.parse(event.data);\n                    this.handleMessage(data);\n                } catch (error) {\n                    console.error('[SSE] Error parsing EventSource message:', error);\n                }\n            };\n            this.eventSource.onerror = (error)=>{\n                console.warn('[SSE] EventSource error:', error);\n                this.handleDisconnect();\n            };\n        } catch (error) {\n            console.error('[SSE] EventSource creation failed:', error);\n            this.connectionFailed = true;\n            this.emit('connection_failed', {\n                reason: 'eventsource_error'\n            });\n        }\n    }\n    // Handle disconnection and reconnection logic\n    handleDisconnect() {\n        console.warn('[SSE] Connection lost');\n        this.isConnected = false;\n        if (this.reconnectAttempts < this.maxReconnectAttempts) {\n            setTimeout(()=>{\n                this.reconnectAttempts++;\n                this.reconnectDelay *= 2;\n                this.connect();\n            }, this.reconnectDelay);\n        } else {\n            this.connectionFailed = true;\n            this.disconnect();\n            this.emit('connection_failed', {\n                reason: 'max_attempts_reached'\n            });\n        }\n    }\n    // Disconnect from SSE\n    disconnect() {\n        if (this.eventSource) {\n            this.eventSource.close();\n            this.eventSource = null;\n            this.isConnected = false;\n        }\n    }\n    // Handle incoming messages\n    handleMessage(data) {\n        switch(data.type){\n            case 'connected':\n                break;\n            case 'heartbeat':\n                break;\n            case 'task_update':\n                this.emit('task_update', data);\n                break;\n            case 'project_update':\n                this.emit('project_update', data);\n                break;\n            case 'status_update':\n                this.emit('status_update', data);\n                break;\n            default:\n        }\n    }\n    // Add event listener\n    on(event, callback) {\n        if (!this.listeners.has(event)) {\n            this.listeners.set(event, new Set());\n        }\n        this.listeners.get(event).add(callback);\n    }\n    // Remove event listener\n    off(event, callback) {\n        const eventListeners = this.listeners.get(event);\n        if (eventListeners) {\n            eventListeners.delete(callback);\n        }\n    }\n    // Emit event to listeners\n    emit(event, data) {\n        const eventListeners = this.listeners.get(event);\n        if (eventListeners) {\n            eventListeners.forEach((callback)=>{\n                try {\n                    callback(data);\n                } catch (error) {\n                    console.error(\"[SSE] Error in event listener for \".concat(event, \":\"), error);\n                }\n            });\n        }\n    }\n    // Check if connected\n    getConnectionStatus() {\n        return this.isConnected;\n    }\n    // Check if connection has permanently failed\n    hasConnectionFailed() {\n        return this.connectionFailed;\n    }\n    constructor(baseUrl){\n        this.baseUrl = baseUrl;\n        this.eventSource = null;\n        this.reconnectAttempts = 0;\n        this.maxReconnectAttempts = 3; // Reduced from 5 to fail faster\n        this.reconnectDelay = 1000; // Start with 1 second\n        this.isConnected = false;\n        this.listeners = new Map();\n        this.connectionFailed = false;\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RealtimeClient);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvcmVhbHRpbWUudHMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLDRDQUE0QztBQUM1QyxNQUFNQTtJQVdKLDBCQUEwQjtJQUMxQkMsVUFBVTtRQUNSLG1EQUFtRDtRQUNuRCxJQUFJLElBQUksQ0FBQ0MsZ0JBQWdCLEVBQUU7WUFDekI7UUFDRjtRQUVBLElBQUksSUFBSSxDQUFDQyxXQUFXLEVBQUU7WUFDcEIsSUFBSSxDQUFDQyxVQUFVO1FBQ2pCO1FBRUEsSUFBSTtZQUNGLE1BQU1DLE1BQU0sR0FBZ0IsT0FBYixJQUFJLENBQUNDLE9BQU8sRUFBQztZQUU1QiwyREFBMkQ7WUFDM0QsSUFBSSxDQUFDQyxnQkFBZ0IsQ0FBQ0Y7UUFFeEIsRUFBRSxPQUFPRyxPQUFPO1lBQ2RDLFFBQVFDLElBQUksQ0FBQyx5REFBeURGO1lBQ3RFLElBQUksQ0FBQ04sZ0JBQWdCLEdBQUc7WUFDeEIsSUFBSSxDQUFDUyxJQUFJLENBQUMscUJBQXFCO2dCQUFFQyxRQUFRO1lBQWlCO1FBQzVEO0lBQ0Y7SUFFQSxrRUFBa0U7SUFDbEUsTUFBY0wsaUJBQWlCRixHQUFXLEVBQUU7UUFDMUMsSUFBSTtZQUVGLE1BQU1RLFdBQVcsTUFBTUMsTUFBTVQsS0FBSztnQkFDaENVLGFBQWE7Z0JBQ2JDLFNBQVM7b0JBQ1AsVUFBVTtvQkFDVixpQkFBaUI7Z0JBQ25CO1lBQ0Y7WUFFQSxJQUFJLENBQUNILFNBQVNJLEVBQUUsRUFBRTtnQkFDaEIsTUFBTSxJQUFJQyxNQUFNLDBCQUE2Q0wsT0FBbkJBLFNBQVNNLE1BQU0sRUFBQyxLQUF1QixPQUFwQk4sU0FBU08sVUFBVTtZQUNsRjtZQUVBLElBQUksQ0FBQ1AsU0FBU1EsSUFBSSxFQUFFO2dCQUNsQixNQUFNLElBQUlILE1BQU07WUFDbEI7WUFFQSxJQUFJLENBQUNJLFdBQVcsR0FBRztZQUNuQixJQUFJLENBQUNDLGlCQUFpQixHQUFHO1lBQ3pCLElBQUksQ0FBQ3JCLGdCQUFnQixHQUFHO1lB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QUFlQyxNQUFNLENBQUNUO1FBQ3hCO0lBQ0Y7SUFFQSwwQkFBMEI7SUFDbEJoRCxLQUFLeUMsS0FBYSxFQUFFWCxJQUFTLEVBQUU7UUFDckMsTUFBTTBCLGlCQUFpQixJQUFJLENBQUNQLFNBQVMsQ0FBQ0ksR0FBRyxDQUFDWjtRQUMxQyxJQUFJZSxnQkFBZ0I7WUFDbEJBLGVBQWVFLE9BQU8sQ0FBQ1YsQ0FBQUE7Z0JBQ3JCLElBQUk7b0JBQ0ZBLFNBQVNsQjtnQkFDWCxFQUFFLE9BQU9qQyxPQUFPO29CQUNkQyxRQUFRRCxLQUFLLENBQUMscUNBQTJDLE9BQU40QyxPQUFNLE1BQUk1QztnQkFDL0Q7WUFDRjtRQUNGO0lBQ0Y7SUFFQSxxQkFBcUI7SUFDckI4RCxzQkFBc0I7UUFDcEIsT0FBTyxJQUFJLENBQUNoRCxXQUFXO0lBQ3pCO0lBRUEsNkNBQTZDO0lBQzdDaUQsc0JBQXNCO1FBQ3BCLE9BQU8sSUFBSSxDQUFDckUsZ0JBQWdCO0lBQzlCO0lBMU5BLFlBQVksT0FBdUIsQ0FBRTthQUFqQkksVUFBQUE7YUFSWkgsY0FBa0M7YUFDbENvQixvQkFBb0I7YUFDcEIrQix1QkFBdUIsR0FBRyxnQ0FBZ0M7YUFDMURKLGlCQUFpQixNQUFNLHNCQUFzQjthQUM3QzVCLGNBQWM7YUFDZHNDLFlBQW1ELElBQUlZO2FBQ3ZEdEUsbUJBQW1CO0lBRVc7QUEyTnhDO0FBRUEsaUVBQWVGLGNBQWNBLEVBQUMiLCJzb3VyY2VzIjpbIi9ob21lL2NvZGVyL09yY2hlUGxhbi9mcm9udGVuZC9zcmMvbGliL3JlYWx0aW1lLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEZyb250ZW5kIFNTRSBjbGllbnQgZm9yIHJlYWwtdGltZSB1cGRhdGVzXG5jbGFzcyBSZWFsdGltZUNsaWVudCB7XG4gIHByaXZhdGUgZXZlbnRTb3VyY2U6IEV2ZW50U291cmNlIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgcmVjb25uZWN0QXR0ZW1wdHMgPSAwO1xuICBwcml2YXRlIG1heFJlY29ubmVjdEF0dGVtcHRzID0gMzsgLy8gUmVkdWNlZCBmcm9tIDUgdG8gZmFpbCBmYXN0ZXJcbiAgcHJpdmF0ZSByZWNvbm5lY3REZWxheSA9IDEwMDA7IC8vIFN0YXJ0IHdpdGggMSBzZWNvbmRcbiAgcHJpdmF0ZSBpc0Nvbm5lY3RlZCA9IGZhbHNlO1xuICBwcml2YXRlIGxpc3RlbmVyczogTWFwPHN0cmluZywgU2V0PChkYXRhOiBhbnkpID0+IHZvaWQ+PiA9IG5ldyBNYXAoKTtcbiAgcHJpdmF0ZSBjb25uZWN0aW9uRmFpbGVkID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBiYXNlVXJsOiBzdHJpbmcpIHt9XG5cbiAgLy8gQ29ubmVjdCB0byBTU0UgZW5kcG9pbnRcbiAgY29ubmVjdCgpIHtcbiAgICAvLyBJZiBjb25uZWN0aW9uIGhhcyBmYWlsZWQgYmVmb3JlLCBkb24ndCB0cnkgYWdhaW5cbiAgICBpZiAodGhpcy5jb25uZWN0aW9uRmFpbGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZXZlbnRTb3VyY2UpIHtcbiAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCB1cmwgPSBgJHt0aGlzLmJhc2VVcmx9L3JlYWx0aW1lL2V2ZW50c2A7XG4gICAgICBcbiAgICAgIC8vIFRyeSBmZXRjaC1iYXNlZCBhcHByb2FjaCBmaXJzdCBmb3IgYmV0dGVyIGVycm9yIGhhbmRsaW5nXG4gICAgICB0aGlzLmNvbm5lY3RXaXRoRmV0Y2godXJsKTtcbiAgICAgIFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1tTU0VdIEVycm9yIGNyZWF0aW5nIEV2ZW50U291cmNlIC0gU1NFIG5vdCBhdmFpbGFibGU6JywgZXJyb3IpO1xuICAgICAgdGhpcy5jb25uZWN0aW9uRmFpbGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuZW1pdCgnY29ubmVjdGlvbl9mYWlsZWQnLCB7IHJlYXNvbjogJ2NyZWF0aW9uX2Vycm9yJyB9KTtcbiAgICB9XG4gIH1cblxuICAvLyBBbHRlcm5hdGl2ZSBTU0UgY29ubmVjdGlvbiB1c2luZyBmZXRjaCBmb3IgYmV0dGVyIGNvbXBhdGliaWxpdHlcbiAgcHJpdmF0ZSBhc3luYyBjb25uZWN0V2l0aEZldGNoKHVybDogc3RyaW5nKSB7XG4gICAgdHJ5IHtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgY3JlZGVudGlhbHM6ICdpbmNsdWRlJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdBY2NlcHQnOiAndGV4dC9ldmVudC1zdHJlYW0nLFxuICAgICAgICAgICdDYWNoZS1Db250cm9sJzogJ25vLWNhY2hlJ1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNTRSBjb25uZWN0aW9uIGZhaWxlZDogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFyZXNwb25zZS5ib2R5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gcmVzcG9uc2UgYm9keSBmb3IgU1NFIHN0cmVhbScpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmlzQ29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMucmVjb25uZWN0QXR0ZW1wdHMgPSAwO1xuICAgICAgdGhpcy5jb25uZWN0aW9uRmFpbGVkID0gZmFsc2U7XG5cbiAgICAgIC8vIFVzZSBSZWFkYWJsZVN0cmVhbSB0byBwcm9jZXNzIFNTRSBkYXRhXG4gICAgICBjb25zdCByZWFkZXIgPSByZXNwb25zZS5ib2R5LmdldFJlYWRlcigpO1xuICAgICAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICAgICAgbGV0IGJ1ZmZlciA9ICcnO1xuXG4gICAgICBjb25zdCBwcm9jZXNzU3RyZWFtID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJ1ZmZlciArPSBkZWNvZGVyLmRlY29kZSh2YWx1ZSwgeyBzdHJlYW06IHRydWUgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFByb2Nlc3MgY29tcGxldGUgbWVzc2FnZXNcbiAgICAgICAgICAgIGNvbnN0IGxpbmVzID0gYnVmZmVyLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgIGJ1ZmZlciA9IGxpbmVzLnBvcCgpIHx8ICcnOyAvLyBLZWVwIGluY29tcGxldGUgbGluZSBpbiBidWZmZXJcblxuICAgICAgICAgICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgICAgICAgICAgIGlmIChsaW5lLnN0YXJ0c1dpdGgoJ2RhdGE6ICcpKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKGxpbmUuc2xpY2UoNikpO1xuICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVNZXNzYWdlKGRhdGEpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdbU1NFXSBFcnJvciBwYXJzaW5nIG1lc3NhZ2U6JywgZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdbU1NFXSBTdHJlYW0gcHJvY2Vzc2luZyBlcnJvcjonLCBlcnJvcik7XG4gICAgICAgICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHByb2Nlc3NTdHJlYW0oKTtcblxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1tTU0VdIEZldGNoLWJhc2VkIGNvbm5lY3Rpb24gZmFpbGVkLCB0cnlpbmcgRXZlbnRTb3VyY2UuLi4nLCBlcnJvcik7XG4gICAgICB0aGlzLmNvbm5lY3RXaXRoRXZlbnRTb3VyY2UodXJsKTtcbiAgICB9XG4gIH1cblxuICAvLyBGYWxsYmFjayB0byBzdGFuZGFyZCBFdmVudFNvdXJjZVxuICBwcml2YXRlIGNvbm5lY3RXaXRoRXZlbnRTb3VyY2UodXJsOiBzdHJpbmcpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5ldmVudFNvdXJjZSA9IG5ldyBFdmVudFNvdXJjZSh1cmwsIHtcbiAgICAgICAgd2l0aENyZWRlbnRpYWxzOiB0cnVlXG4gICAgICB9KTtcblxuICAgICAgdGhpcy5ldmVudFNvdXJjZS5vbm9wZW4gPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuaXNDb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnJlY29ubmVjdEF0dGVtcHRzID0gMDtcbiAgICAgICAgdGhpcy5yZWNvbm5lY3REZWxheSA9IDEwMDA7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbkZhaWxlZCA9IGZhbHNlO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5ldmVudFNvdXJjZS5vbm1lc3NhZ2UgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShldmVudC5kYXRhKTtcbiAgICAgICAgICB0aGlzLmhhbmRsZU1lc3NhZ2UoZGF0YSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignW1NTRV0gRXJyb3IgcGFyc2luZyBFdmVudFNvdXJjZSBtZXNzYWdlOicsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdGhpcy5ldmVudFNvdXJjZS5vbmVycm9yID0gKGVycm9yKSA9PiB7XG4gICAgICAgIGNvbnNvbGUud2FybignW1NTRV0gRXZlbnRTb3VyY2UgZXJyb3I6JywgZXJyb3IpO1xuICAgICAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3QoKTtcbiAgICAgIH07XG5cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignW1NTRV0gRXZlbnRTb3VyY2UgY3JlYXRpb24gZmFpbGVkOicsIGVycm9yKTtcbiAgICAgIHRoaXMuY29ubmVjdGlvbkZhaWxlZCA9IHRydWU7XG4gICAgICB0aGlzLmVtaXQoJ2Nvbm5lY3Rpb25fZmFpbGVkJywgeyByZWFzb246ICdldmVudHNvdXJjZV9lcnJvcicgfSk7XG4gICAgfVxuICB9XG5cbiAgLy8gSGFuZGxlIGRpc2Nvbm5lY3Rpb24gYW5kIHJlY29ubmVjdGlvbiBsb2dpY1xuICBwcml2YXRlIGhhbmRsZURpc2Nvbm5lY3QoKSB7XG4gICAgY29uc29sZS53YXJuKCdbU1NFXSBDb25uZWN0aW9uIGxvc3QnKTtcbiAgICB0aGlzLmlzQ29ubmVjdGVkID0gZmFsc2U7XG4gICAgXG4gICAgaWYgKHRoaXMucmVjb25uZWN0QXR0ZW1wdHMgPCB0aGlzLm1heFJlY29ubmVjdEF0dGVtcHRzKSB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5yZWNvbm5lY3RBdHRlbXB0cysrO1xuICAgICAgICB0aGlzLnJlY29ubmVjdERlbGF5ICo9IDI7XG4gICAgICAgIHRoaXMuY29ubmVjdCgpO1xuICAgICAgfSwgdGhpcy5yZWNvbm5lY3REZWxheSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29ubmVjdGlvbkZhaWxlZCA9IHRydWU7XG4gICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgIHRoaXMuZW1pdCgnY29ubmVjdGlvbl9mYWlsZWQnLCB7IHJlYXNvbjogJ21heF9hdHRlbXB0c19yZWFjaGVkJyB9KTtcbiAgICB9XG4gIH1cblxuICAvLyBEaXNjb25uZWN0IGZyb20gU1NFXG4gIGRpc2Nvbm5lY3QoKSB7XG4gICAgaWYgKHRoaXMuZXZlbnRTb3VyY2UpIHtcbiAgICAgIHRoaXMuZXZlbnRTb3VyY2UuY2xvc2UoKTtcbiAgICAgIHRoaXMuZXZlbnRTb3VyY2UgPSBudWxsO1xuICAgICAgdGhpcy5pc0Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8vIEhhbmRsZSBpbmNvbWluZyBtZXNzYWdlc1xuICBwcml2YXRlIGhhbmRsZU1lc3NhZ2UoZGF0YTogYW55KSB7XG4gICAgXG4gICAgc3dpdGNoIChkYXRhLnR5cGUpIHtcbiAgICAgIGNhc2UgJ2Nvbm5lY3RlZCc6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnaGVhcnRiZWF0JzpcbiAgICAgICAgLy8gU2lsZW50IGhlYXJ0YmVhdCB0byBrZWVwIGNvbm5lY3Rpb24gYWxpdmVcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0YXNrX3VwZGF0ZSc6XG4gICAgICAgIHRoaXMuZW1pdCgndGFza191cGRhdGUnLCBkYXRhKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdwcm9qZWN0X3VwZGF0ZSc6XG4gICAgICAgIHRoaXMuZW1pdCgncHJvamVjdF91cGRhdGUnLCBkYXRhKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzdGF0dXNfdXBkYXRlJzpcbiAgICAgICAgdGhpcy5lbWl0KCdzdGF0dXNfdXBkYXRlJywgZGF0YSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICB9XG4gIH1cblxuICAvLyBBZGQgZXZlbnQgbGlzdGVuZXJcbiAgb24oZXZlbnQ6IHN0cmluZywgY2FsbGJhY2s6IChkYXRhOiBhbnkpID0+IHZvaWQpIHtcbiAgICBpZiAoIXRoaXMubGlzdGVuZXJzLmhhcyhldmVudCkpIHtcbiAgICAgIHRoaXMubGlzdGVuZXJzLnNldChldmVudCwgbmV3IFNldCgpKTtcbiAgICB9XG4gICAgdGhpcy5saXN0ZW5lcnMuZ2V0KGV2ZW50KSEuYWRkKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8vIFJlbW92ZSBldmVudCBsaXN0ZW5lclxuICBvZmYoZXZlbnQ6IHN0cmluZywgY2FsbGJhY2s6IChkYXRhOiBhbnkpID0+IHZvaWQpIHtcbiAgICBjb25zdCBldmVudExpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzLmdldChldmVudCk7XG4gICAgaWYgKGV2ZW50TGlzdGVuZXJzKSB7XG4gICAgICBldmVudExpc3RlbmVycy5kZWxldGUoY2FsbGJhY2spO1xuICAgIH1cbiAgfVxuXG4gIC8vIEVtaXQgZXZlbnQgdG8gbGlzdGVuZXJzXG4gIHByaXZhdGUgZW1pdChldmVudDogc3RyaW5nLCBkYXRhOiBhbnkpIHtcbiAgICBjb25zdCBldmVudExpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzLmdldChldmVudCk7XG4gICAgaWYgKGV2ZW50TGlzdGVuZXJzKSB7XG4gICAgICBldmVudExpc3RlbmVycy5mb3JFYWNoKGNhbGxiYWNrID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjYWxsYmFjayhkYXRhKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBbU1NFXSBFcnJvciBpbiBldmVudCBsaXN0ZW5lciBmb3IgJHtldmVudH06YCwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvLyBDaGVjayBpZiBjb25uZWN0ZWRcbiAgZ2V0Q29ubmVjdGlvblN0YXR1cygpIHtcbiAgICByZXR1cm4gdGhpcy5pc0Nvbm5lY3RlZDtcbiAgfVxuXG4gIC8vIENoZWNrIGlmIGNvbm5lY3Rpb24gaGFzIHBlcm1hbmVudGx5IGZhaWxlZFxuICBoYXNDb25uZWN0aW9uRmFpbGVkKCkge1xuICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb25GYWlsZWQ7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUmVhbHRpbWVDbGllbnQ7Il0sIm5hbWVzIjpbIlJlYWx0aW1lQ2xpZW50IiwiY29ubmVjdCIsImNvbm5lY3Rpb25GYWlsZWQiLCJldmVudFNvdXJjZSIsImRpc2Nvbm5lY3QiLCJ1cmwiLCJiYXNlVXJsIiwiY29ubmVjdFdpdGhGZXRjaCIsImVycm9yIiwiY29uc29sZSIsIndhcm4iLCJlbWl0IiwicmVhc29uIiwicmVzcG9uc2UiLCJmZXRjaCIsImNyZWRlbnRpYWxzIiwiaGVhZGVycyIsIm9rIiwiRXJyb3IiLCJzdGF0dXMiLCJzdGF0dXNUZXh0IiwiYm9keSIsImlzQ29ubmVjdGVkIiwicmVjb25uZWN0QXR0ZW1wdHMiLCJyZWFkZXIiLCJnZXRSZWFkZXIiLCJkZWNvZGVyIiwiVGV4dERlY29kZXIiLCJidWZmZXIiLCJwcm9jZXNzU3RyZWFtIiwiZG9uZSIsInZhbHVlIiwicmVhZCIsImhhbmRsZURpc2Nvbm5lY3QiLCJkZWNvZGUiLCJzdHJlYW0iLCJsaW5lcyIsInNwbGl0IiwicG9wIiwibGluZSIsInN0YXJ0c1dpdGgiLCJkYXRhIiwiSlNPTiIsInBhcnNlIiwic2xpY2UiLCJoYW5kbGVNZXNzYWdlIiwiY29ubmVjdFdpdGhFdmVudFNvdXJjZSIsIkV2ZW50U291cmNlIiwid2l0aENyZWRlbnRpYWxzIiwib25vcGVuIiwicmVjb25uZWN0RGVsYXkiLCJvbm1lc3NhZ2UiLCJldmVudCIsIm9uZXJyb3IiLCJtYXhSZWNvbm5lY3RBdHRlbXB0cyIsInNldFRpbWVvdXQiLCJjbG9zZSIsInR5cGUiLCJvbiIsImNhbGxiYWNrIiwibGlzdGVuZXJzIiwiaGFzIiwic2V0IiwiU2V0IiwiZ2V0IiwiYWRkIiwib2ZmIiwiZXZlbnRMaXN0ZW5lcnMiLCJkZWxldGUiLCJmb3JFYWNoIiwiZ2V0Q29ubmVjdGlvblN0YXR1cyIsImhhc0Nvbm5lY3Rpb25GYWlsZWQiLCJNYXAiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/realtime.ts\n"));

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["main-app"], () => (__webpack_exec__("(app-pages-browser)/../node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2Fhome%2Fcoder%2FOrchePlan%2Ffrontend%2Fsrc%2Fapp%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);